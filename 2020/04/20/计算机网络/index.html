<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络 | Fyind's Blog</title><meta name="author" content="Fyind"><meta name="copyright" content="Fyind"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="层次模型 一共有7层   image-20200426100702045  物理层 信号是随时间变换的，可物理测量的量。信号变化可以对于一个符号。这些符号就是信息。 信息含量(Informationsgehalt)是这个符号可以传递多少信息。  一个信息出现次数越少，它的信息含量越高 字符串的信息含量是所有字符信息含量的和 可预测的字符信息含量是0  信息的定义 信息存在于一个信号的变化预知的不确">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://fyind.de/2020/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Fyind&#39;s Blog">
<meta property="og:description" content="层次模型 一共有7层   image-20200426100702045  物理层 信号是随时间变换的，可物理测量的量。信号变化可以对于一个符号。这些符号就是信息。 信息含量(Informationsgehalt)是这个符号可以传递多少信息。  一个信息出现次数越少，它的信息含量越高 字符串的信息含量是所有字符信息含量的和 可预测的字符信息含量是0  信息的定义 信息存在于一个信号的变化预知的不确">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://fyind.de/img/pic1.PNG">
<meta property="article:published_time" content="2020-04-20T10:56:23.000Z">
<meta property="article:modified_time" content="2025-07-18T10:49:53.883Z">
<meta property="article:author" content="Fyind">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyind.de/img/pic1.PNG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络",
  "url": "http://fyind.de/2020/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",
  "image": "http://fyind.de/img/pic1.PNG",
  "datePublished": "2020-04-20T10:56:23.000Z",
  "dateModified": "2025-07-18T10:49:53.883Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fyind",
      "url": "http://fyind.de"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pic1.PNG"><link rel="canonical" href="http://fyind.de/2020/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://fyindex.work/PicGo/liuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yae.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Fyind's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机网络</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-04-20T10:56:23.000Z" title="Created 2020-04-20 10:56:23">2020-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-18T10:49:53.883Z" title="Updated 2025-07-18 10:49:53">2025-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TUM%E7%AC%94%E8%AE%B0/">TUM笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="层次模型">层次模型</h2>
<p>一共有7层</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20200426100702045.png"
alt="image-20200426100702045" />
<figcaption aria-hidden="true">image-20200426100702045</figcaption>
</figure>
<h2 id="物理层">物理层</h2>
<p><strong>信号</strong>是随时间变换的，可物理测量的量。信号变化可以对于一个符号。这些符号就是信息。</p>
<p><strong>信息含量</strong>(Informationsgehalt)是这个符号可以传递多少信息。</p>
<ul>
<li><p>一个信息出现次数越少，它的信息含量越高</p></li>
<li><p>字符串的信息含量是所有字符信息含量的和</p></li>
<li><p>可预测的字符信息含量是0</p></li>
</ul>
<h3 id="信息的定义">信息的定义</h3>
<p>信息存在于一个信号的变化预知的不确定性。一个字符 <span
class="math inline">\(x \in X\)</span>
的<strong>信息含量</strong>与它出现的概率 <span
class="math inline">\(p(x)\)</span> 有关。 <span class="math display">\[
I(x)=-\log _{2} p(x) \quad \text { mit } \quad[I]= bit.
\]</span> <strong>熵</strong>(Entropie)是一个信息源的信息含量 <span
class="math display">\[
H(X)=\sum_{x \in X } p(x) I(x)=-\sum_{x \in X } p(x) \log _{2}(p(x))
\]</span> 其中的<span class="math inline">\(p(x)\)</span> 也可以写成
<span class="math inline">\(Pr[X=x]\)</span></p>
<h4 id="有条件的熵">有条件的熵</h4>
<p>有条件的熵(bedingte Entropie)指当X已知的时候Y的不确定性 <span
class="math display">\[
H(Y | X)=\sum_{x \in X } p(x) H(Y | X=x)=-\sum_{x \in X } p(x) \sum_{y
\in Y } p(y | x) \log _{2} p(y | x)
\]</span></p>
<h4 id="组合熵">组合熵</h4>
<p>X，Y一起发生. <span class="math inline">\(p(x,y)\)</span>
是Verbunddichte. <span class="math display">\[
p(x, y)=\operatorname{Pr}[X=x | Y=y] \operatorname{Pr}[Y=y] \\
H(X, Y)=-\sum_{x \in X } \sum_{y \in Y } p(x, y) \log _{2} p(x, y)
\]</span> 组合熵和有条件熵的计算 <span class="math display">\[
H(X, Y)=H(X)+H(Y | X) \\
H(Y | X)=-\sum_{x \in X } \sum_{y \in Y } p_{X Y}(X=x, Y=y) \log
_{2}\left(p_{Y}(Y=y | X=x)\right)
\]</span></p>
<h4 id="传递信息">传递信息</h4>
<figure>
<img src="https://fyindex.work/PicGo/image-20200426110459205.png"
alt="image-20200426110459205" />
<figcaption aria-hidden="true">image-20200426110459205</figcaption>
</figure>
<p>传递信息(Transinformation)是原来的信息减去失去的信息 <span
class="math display">\[
I(X ; Y)=H(X)-H(X | Y)=H(Y)-H(Y | X)
\]</span></p>
<h2 id="数据链路层-sicherungsschicht">数据链路层 Sicherungsschicht</h2>
<p>我们首先考虑直接连接的网络</p>
<ul>
<li>所有节点可以直接到达</li>
<li>节点用简单地址表示</li>
<li>没有数据传递Vermittlung</li>
<li>可以简单继续传接(Bridging, Switching)</li>
</ul>
<p>数据链路层的主要任务是</p>
<ul>
<li>控制媒介寻址</li>
<li>检查携带的信息是否有错误</li>
<li>在直接连接的网络中寻址</li>
</ul>
<h3 id="网络的图表示">网络的图表示</h3>
<h4 id="有向图">有向图</h4>
<p>一个非对称asymmetrisch 的网络可以用图有向图<span
class="math inline">\(\mathcal{G}=(\mathcal{N}, \mathcal{A})\)</span>
表示</p>
<p>其中 <span class="math inline">\(\mathcal{N}\)</span> 是点的集合,
<span class="math inline">\(\mathcal{A}=\{(i,j)|i,j \in \mathcal{N}
\}\)</span> 是有向边的集合</p>
<h4 id="无向图">无向图</h4>
<p>一个对称的symmetrisch网络可以用无向图 <span
class="math inline">\(\mathcal{G}=(\mathcal{N}, \mathcal{E})\)</span>
表示</p>
<p>其中 <span class="math inline">\(\mathcal{N}\)</span> 是点的集合,
<span class="math inline">\(\mathcal{E}=\{\{i,j\}|i,j \in \mathcal{N}
\}\)</span> 是无向边的集合</p>
<h4 id="路径pfad">路径Pfad</h4>
<p>一个路径从 <span class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 可以用集合表示： <span
class="math display">\[
\mathcal{P}_{s t}=\{(s, i),(i, j), \ldots,(k, l),(l, t)\}
\]</span> 路径的花费Pfadkosten是所有边花费的总和 <span
class="math display">\[
c\left(\mathcal{P}_{s t}\right)=\sum_{(i, j) \in \mathcal{P}_{s t}} c_{i
j}
\]</span> 路径长度 Pfadlänge是所有边的数量,也叫 Hop Count <span
class="math display">\[
l\left(\mathcal{P}_{s t}\right)=\left|\mathcal{P}_{s t}\right| .
\]</span></p>
<h4 id="网络拓扑结构">网络拓扑结构</h4>
<p>Topologie 描述图的结构</p>
<ul>
<li>物理结构</li>
<li>逻辑结构</li>
</ul>
<p>重要的拓扑结构</p>
<ul>
<li><p>点对点 Punkt-zu-Punkt</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223259448.png"
alt="image-20210625223259448" />
<figcaption aria-hidden="true">image-20210625223259448</figcaption>
</figure></li>
<li><p>链 Kette</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223443911.png"
alt="image-20210625223443911" />
<figcaption aria-hidden="true">image-20210625223443911</figcaption>
</figure></li>
<li><p>星星Stern</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223456683.png"
alt="image-20210625223456683" />
<figcaption aria-hidden="true">image-20210625223456683</figcaption>
</figure></li>
<li><p>Vermaschung</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223524112.png"
alt="image-20210625223524112" />
<figcaption aria-hidden="true">image-20210625223524112</figcaption>
</figure></li>
<li><p>树 Baum</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223544737.png"
alt="image-20210625223544737" />
<figcaption aria-hidden="true">image-20210625223544737</figcaption>
</figure></li>
<li><p>总线 Bus</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223601885.png"
alt="image-20210625223601885" />
<figcaption aria-hidden="true">image-20210625223601885</figcaption>
</figure></li>
</ul>
<h4 id="邻接矩阵和距离矩阵">邻接矩阵和距离矩阵</h4>
<p>邻接矩阵Adjazenzmatirx： <span class="math display">\[
\boldsymbol{A}=(a)_{i j}=\left\{\begin{array}{ll}
1 &amp; \exists(i, j) \in \mathcal{A} \\
0 &amp; \text { sonst }
\end{array}, \forall i, j \in \mathcal{N}, \quad \boldsymbol{A}
\in\{0,1\}^{N \times N}\right.
\]</span> <img
src="https://fyindex.work/PicGo/image-20210625223704683.png"
alt="image-20210625223704683" /></p>
<p>距离矩阵Distanzmatrix： <span class="math display">\[
\boldsymbol{D}=(d)_{i j}=\left\{\begin{array}{ll}
c_{i j} &amp; \exists(i, j) \in \mathcal{A} \\
0 &amp; \text { wenn } i=j, \quad \forall i, j \in \mathcal{N}, \quad
\boldsymbol{D} \in \mathbb{R}_{0+}^{N \times N} \\
\infty &amp; \text { sonst }
\end{array}\right.
\]</span> <img
src="https://fyindex.work/PicGo/image-20210625223749771.png"
alt="image-20210625223749771" /></p>
<h4 id="生成树结构">生成树结构</h4>
<ul>
<li>最短路径树(Shortest Path Tree)</li>
<li>最小生成树(Minimum Spanning Tree)</li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20210625223910908.png"
alt="image-20210625223910908" />
<figcaption aria-hidden="true">image-20210625223910908</figcaption>
</figure>
<h3 id="连接特征">连接特征</h3>
<ul>
<li>传递率 Übertragungsrate</li>
<li>传递延迟Übertragungsverzögerung</li>
<li>传递方向Übertragungsrichtung</li>
<li>多次访问Mehrfachzugriff</li>
</ul>
<p>我们首先讨论点对点的连接</p>
<h4 id="传递率">传递率</h4>
<p>传递率 <span class="math inline">\(r\)</span> (bit/s) 决定传递 <span
class="math inline">\(L\)</span>
的数据块所需要的时间，这个时间称为序列化时间 Serialisierungszeit <span
class="math display">\[
t_{s}=\frac{L}{r}
\]</span></p>
<h4 id="ausbreitungsgeschwindigkeit">Ausbreitungsgeschwindigkeit</h4>
<p>是一个距离 <span class="math inline">\(d\)</span></p>
<h5
id="ausarbeitungsverzögerung传递延迟">Ausarbeitungsverzögerung传递延迟</h5>
<p><span class="math display">\[
t_{p}=\frac{d}{\nu c_{0}} .
\]</span></p>
<p>其中 <span class="math inline">\(d\)</span> 是传输距离，<span
class="math inline">\(c_0\)</span> 是光速，<span
class="math inline">\(\nu\)</span> 是介质的传输倍率(relative
Ausbreitungsgeschwindigkeit in einem Medium)</p>
<h5 id="传输时间übertragungszeit">传输时间Übertragungszeit</h5>
<p><span class="math display">\[
t_{d}=t_{s}+t_{p}=\frac{L}{r}+\frac{d}{\nu c_{0}}
\]</span></p>
<h5
id="bandbreitenverzögerungsprodukt">Bandbreitenverzögerungsprodukt</h5>
<p>同一时间传输的bit数 <span class="math display">\[
C=t_{p} r=\frac{d}{\nu c_{0}} r
\]</span></p>
<h3 id="multiplex">Multiplex</h3>
<h4 id="aloha">ALOHA</h4>
<p>假设有很多节点 <span class="math inline">\(N&gt;15\)</span> ,
每个结点有相同且独立的发送概率，发送的信息大小相同(发送时间$ T$ )</p>
<p>每个节点发送到中心，如果两个节点同时发送数据就会产生冲突collision</p>
<p>可以用伯努利实验来建模，因为有许多节点，所以它是二项分布的。当 <span
class="math inline">\(N\)</span> 很大的时候，可以用泊松分布近似</p>
<p><span class="math inline">\(Np=\lambda\)</span> 是泊松分布的参数</p>
<p>事件 <span class="math inline">\(X_t\)</span> 是在区间 <span
class="math inline">\([t,t+T)\)</span> 中发送数据的节点数量 <span
class="math display">\[
\operatorname{Pr}\left[X_{t}=k\right]=\frac{\lambda^{k} e^{-\lambda}}{k
!}
\]</span> 假设一个节点在 <span class="math inline">\(t_0\)</span>
的时候发送了数据</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701122623774.png"
alt="image-20210701122623774" />
<figcaption aria-hidden="true">image-20210701122623774</figcaption>
</figure>
<p>那么在 <span class="math inline">\([t_0-T,t_0+T]\)</span>
的时间里都不能有其他节点发送数据 <span class="math display">\[
p_{0}=\operatorname{Pr}\left[X_{t_{0}-T}=0\right]
\operatorname{Pr}\left[X_{t_{0}}=1\right]=\mathrm{e}^{-\lambda} \lambda
\mathrm{e}^{-\lambda}=\lambda \mathrm{e}^{-2 \lambda}
\]</span> 那么 <span class="math inline">\(p_0\)</span>
就是不发生冲突的概率</p>
<h5 id="slotted-aloha">Slotted ALOHA</h5>
<p>节点不会在任意一个时间点发送，而是在离散的点发送 <span
class="math inline">\(t = nT, n=0,1,2,...\)</span> <span
class="math display">\[
S=\lambda \cdot e^{-\lambda} .
\]</span> 现在Kritischer Bereich就变小了，不发生冲突的概率就增大了为
<span class="math inline">\(S\)</span></p>
<h4 id="carrier-sense-multiple-access-csma">Carrier Sense Multiple
Access (CSMA)</h4>
<p>CSMA 一个队 slotted aloha 的优化: „Listen Before Talk“在说之前听</p>
<p>它监听，只在空闲的时候发送</p>
<p>它还有不同的种类</p>
<ul>
<li><p><span class="math inline">\(1\)</span>-persistentes CSMA</p>
<p>当没有媒体的时候，开始发送</p>
<p>如果有媒体，那么等到它结束了再发送</p></li>
<li><p><span class="math inline">\(p\)</span>-persistentes CSMA</p>
<p>当没有媒体的时候，有 <span class="math inline">\(p\)</span>
的概率开始发送。<span class="math inline">\(1-p\)</span>
的概率等待一会，然后重新判断</p>
<p>当有媒体，那么等到结束之后再重新判断</p></li>
<li><p>nicht-persistentes CSMA</p>
<p>当没有媒体的时候，开始发送</p>
<p>如果有媒体，随机等待一个时间段然后再判断</p></li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701123807074.png"
alt="image-20210701123807074" />
<figcaption aria-hidden="true">image-20210701123807074</figcaption>
</figure>
<p>这个是目前所有时间的比较</p>
<h4 id="csmacd-collision-detection">CSMA/CD (Collision Detection)</h4>
<p>检查到冲突的时候，重新发送</p>
<p>如果没有冲突那么就发送</p>
<ul>
<li>发送端要能在发送的同时检测冲突</li>
</ul>
<p>要检测冲突，那么对发送数据的长度也有要求</p>
<p>发送数据的最短长度是 <span class="math inline">\(L_{min}\)</span>
<span class="math display">\[
L_{\min }=\frac{2 d}{\nu c_ {0}} r
\]</span> <img
src="https://fyindex.work/PicGo/image-20210701130330769.png"
alt="image-20210701130330769" /></p>
<p>否则 <span class="math inline">\(i\)</span> 识别不出冲突</p>
<p>如果用 <span class="math inline">\(1\)</span>-persistentes CSMA
会有问题</p>
<ul>
<li>冲突会影响两个发送站</li>
<li>至少1个发送站要发送 Jam-Signal</li>
<li>等待过后又会有冲突</li>
</ul>
<p>解决方案：</p>
<p>在第 <span class="math inline">\(k\)</span>
次等待的时候，等待如下的时间 <span class="math display">\[
n \in\left\{0, \ldots, \min \left\{2^{k-1}-1,1023\right\}\right\}
\]</span></p>
<p>这样就会减小重复发送的时间</p>
<h4 id="csmaca-collision-avoidance">CSMA/CA (Collision Avoidance)</h4>
<p>如果是一个WIFI的无限网络，那么就很难检测冲突。因为 <span
class="math inline">\(i\)</span> 对于 <span
class="math inline">\(j\)</span> 是隐藏的站点 „Hidden Station“</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701131151115.png"
alt="image-20210701131151115" />
<figcaption aria-hidden="true">image-20210701131151115</figcaption>
</figure>
<p>这个时候用 <span class="math inline">\(p\)</span>-persistentes
CSMA</p>
<p>RTS/CTS是这个方法的一个拓展</p>
<p>有一个控制中心，站点发送数据前先向数据中心发送请求 RTS(Request to
send). 数据中心再发送 CTS(Clear to send)
回复。站点被允许发送的时候就可以发送，否则就继续等待一个CTS里要求的时间</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701134408992.png"
alt="image-20210701134408992" />
<figcaption aria-hidden="true">image-20210701134408992</figcaption>
</figure>
<p>优点：Longest Prefix Matching</p>
<ul>
<li>避免隐藏站点来减少冲突，但是不能完全避免</li>
<li>减少冲突</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果 B 不接受 CTS的话就会发生冲突</li>
<li>RTS/CTS 减少最大可以达到的传递率Datenrate</li>
</ul>
<h4 id="token-passing">Token Passing</h4>
<p>所有站点连成一个环，然后传递一个Token，只有当拿到Token的时候才可以发送，发送完之后，要将Token传递给下一个站点</p>
<p>会有一个站点Monitor-Station来监督,如果
Token丢失了，那么会重新生成一个</p>
<p>优点：</p>
<ul>
<li>高效，没有冲突</li>
<li>保证最大延迟</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要监督站点</li>
<li>一个站点出错会影响其他站点</li>
<li>发送延迟会更高，因为要等待Token</li>
<li>把站点连成环的代价高</li>
</ul>
<h3 id="源数据寻址识别错误">源数据，寻址，识别错误</h3>
<h4 id="识别数据">识别数据</h4>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701135224953.png"
alt="image-20210701135224953" />
<figcaption aria-hidden="true">image-20210701135224953</figcaption>
</figure>
<p>如何在一串数据流中识别两个不同的数据。</p>
<h5 id="längenangabe-der-nutzdaten">Längenangabe der Nutzdaten</h5>
<p>在数据的开始标明长度</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701135352639.png"
alt="image-20210701135352639" />
<figcaption aria-hidden="true">image-20210701135352639</figcaption>
</figure>
<p>但是怎么知道一个数据从哪里开始：</p>
<p>通过控制字符Steuerzeichen</p>
<p>每个 4bit 的数据会被唯一的映射到 5bit的数据里</p>
<p>通过 J/K 控制开始，T/R 控制结束</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701135602516.png"
alt="image-20210701135602516" />
<figcaption aria-hidden="true">image-20210701135602516</figcaption>
</figure>
<h5
id="通过分隔符begrenzungsfelder-und-bit-stopfen">通过分隔符Begrenzungsfelder
und Bit-Stopfen</h5>
<p>用一定的bit序列来标注开始和结束，然后再源数据中不会出现这些符号</p>
<p>比如开始结束用 <code>01111110</code></p>
<p>然后数据是 <code>1100101111110111111</code> ，在每5个1后加入一个0</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701140221374.png"
alt="image-20210701140221374" />
<figcaption aria-hidden="true">image-20210701140221374</figcaption>
</figure>
<h5 id="coderegelverletzung">Coderegelverletzung</h5>
<p>通过特定的信号控制来识别</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701140328046.png"
alt="image-20210701140328046" />
<figcaption aria-hidden="true">image-20210701140328046</figcaption>
</figure>
<h4 id="寻址adressierung">寻址Adressierung</h4>
<p>在直接连接的网络中，节点之间是直接连接的，不需要路由Vermittlung
(engl. Routing)。我们需要唯一确定在网络中的每一个节点。</p>
<p>在Schicht2中的的地址是 MAC地址(Media Access Control)</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701140821637.png"
alt="image-20210701140821637" />
<figcaption aria-hidden="true">image-20210701140821637</figcaption>
</figure>
<p>在IEEE 802-Standards标准下的MAC地址是有如下的结构</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701140924389.png"
alt="image-20210701140924389" />
<figcaption aria-hidden="true">image-20210701140924389</figcaption>
</figure>
<p>网卡在工作后会在 RAM里留下MAC地址</p>
<p>在制造网卡的时候MAC地址是唯一的,
制造商可以通过MAC地址确定他们的设备，比如苹果的是
<code>7c:6d:62</code></p>
<p>如果是广播的话，MAC地址都是1：<code>ff:ff:ff:ff:ff:ff</code></p>
<h4 id="识别错误">识别错误</h4>
<p>在传播数据的时候，会产生错误。为了减少错误就需要可以识别错误的编码fehlererkennende
Codes</p>
<p>Cyclic Redundancy Check (CRC) 是一个识别错误的编码族群</p>
<p>长度为 <span class="math inline">\(n\)</span>
的数据串可以表示成一个多项式 <span class="math display">\[
a(x)=\sum_{i=0}^{n-1} a_{i} x^{i} \text { mit } a_{i} \in \mathbb{F}_{2}
\text { mit } \mathbb{F}_{2}=\{0,1\}
\]</span> 设 <span class="math inline">\(F_q[x]\)</span>
是表示所有长度为 <span class="math inline">\(n\)</span>
的数据的集合，<span class="math inline">\(q=2^n\)</span> <span
class="math display">\[
F_{q}[x]=\left\{a \mid a(x)=\sum_{i=0}^{n-1} a_{i} x^{i}, a_{i} \in
\mathbb{F}_{2}\right\}
\]</span> 我们可以定义加法和乘法 <span class="math display">\[
c(x)=a(x)+b(x)=\sum_{i=0}^{n-1}\left(a_{i}+b_{i}\right) x^{i}
\]</span> 这里相加是 <code>XOR</code> 运算 <span class="math display">\[
d(x)=(a(x) \cdot b(x)) \bmod r(x)
\]</span> 计算乘法的时候，我们选取一个Reduktionspolynom <span
class="math inline">\(r(x)\)</span>, 这里 <span
class="math inline">\(r(x)\)</span> 必须满足 irreduzibel 且 如果 <span
class="math inline">\(a(x),b(x)\)</span> 的最高位是 <span
class="math inline">\(n-1\)</span>, 那么 <span
class="math inline">\(r(x)\)</span> 的最高位是<span
class="math inline">\(n\)</span></p>
<p>也就是 <span class="math inline">\(r(x)\)</span> 不能表示为两个 <span
class="math inline">\(n-1\)</span> 集合中多项式相乘的结果</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701154525978.png"
alt="image-20210701154525978" />
<figcaption aria-hidden="true">image-20210701154525978</figcaption>
</figure>
<p>对于CRC策略，它选取 <span
class="math inline">\(r(x)=p(x)(x+1)\)</span></p>
<p>若信息是 <span class="math inline">\(m(x)\)</span></p>
<ol type="1">
<li>首先在结尾加上 <span class="math inline">\(n\)</span> 个 <span
class="math inline">\(0\)</span>, 即<span
class="math inline">\(m^{\prime}(x)=m(x) \cdot x^{n}\)</span></li>
<li>然后求余数 <span class="math inline">\(c(x)=m&#39;(x) \bmod
r(x)\)</span></li>
<li>最后发送 <span class="math inline">\(s(x) = m&#39;(x)
+c(x)\)</span></li>
</ol>
<p>对于接受方而言，收到的信息是 <span
class="math inline">\(s^{\prime}(x)=s(x)+e(x)\)</span></p>
<p>如果满足 <span class="math display">\[
c^{\prime}(x)=s^{\prime}(x) \bmod r(x)=(s(x)+e(x)) \bmod r(x)
\]</span> 若 <span class="math inline">\(c&#39;(x)=0\)</span>
那么大概率是没有错误的</p>
<p>否则就有错误</p>
<p>CRC能纠错的类型</p>
<ul>
<li>所有 1 bit-Fehler</li>
<li>隔离的 2bit-Fehler ，就是两个 <span
class="math inline">\(i,j\)</span> 距离 <span
class="math inline">\(i-j&gt;n\)</span></li>
<li>一些长度大于 <span class="math inline">\(n\)</span> 的
Burst-Fehler</li>
</ul>
<h3 id="层和2层的连接方式">1层和2层的连接方式</h3>
<h4 id="hub-bridges-und-switches">Hub, Bridges und Switches</h4>
<p>Hub:</p>
<p>A 发送到 D点，
Hub通过总线连接所有节点。发送的信息所有节点都能收到。每次只能1个节点发送，否则会产生冲突</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210701155353342.png"
alt="image-20210701155353342" />
<figcaption aria-hidden="true">image-20210701155353342</figcaption>
</figure>
<p>Aktive Hubs (Repeater): 增强物理信号后转发</p>
<p>Passive Hubs： 只是转发</p>
<p>Switch交换机</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702081628084.png"
alt="image-20210702081628084" />
<figcaption aria-hidden="true">image-20210702081628084</figcaption>
</figure>
<p>两组通过Hub连接的主机，再连上了交换机。交换机相当于有2个端口的Hub，它知道数据从哪个端口传输过来。只街上2个的交换机也叫做桥
Bridge</p>
<p>如果发送的信息有Eintrag登记，那么只会发送到登记的那个端口。</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702082007193.png"
alt="image-20210702082007193" />
<figcaption aria-hidden="true">image-20210702082007193</figcaption>
</figure>
<p>交换机可以划分冲突区域(Kollisionsdomänen,Segmentierung),不同区域的可以同时发送信息</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702082343169.png"
alt="image-20210702082343169" />
<figcaption aria-hidden="true">image-20210702082343169</figcaption>
</figure>
<p>如果每个区域只有一个主机，那么称为(Microsegmentation,vollständig
geswitchtem Netz)</p>
<p>交换机可以连接不同通讯协议(Zugriffsverfahren)的网络段, 这种连接是
transparent 的。节点不知道是否使用了交换机。</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702082543204.png"
alt="image-20210702082543204" />
<figcaption aria-hidden="true">image-20210702082543204</figcaption>
</figure>
<h4 id="wlan-access-points">WLAN Access Points</h4>
<p>WLAN Access Point是连接有线和无限传递(Funkübertragung)的桥梁,
在有线连接是 RJ45-Interface， 在无线方向是Wireless Transceiver。</p>
<p>与交换机不同的是，对于WLAN的客户端来说是nicht transparent 的</p>
<p>如果PC1给NB2发送信息，首先确定Source Address (SA) und Destination
Address (DA)</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702083719157.png"
alt="image-20210702083719157" />
<figcaption aria-hidden="true">image-20210702083719157</figcaption>
</figure>
<p>然后经过交换机，因为交换机不知道
NB2，所以会发送给除了发送者的所有人</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702083753979.png"
alt="image-20210702083753979" />
<figcaption aria-hidden="true">image-20210702083753979</figcaption>
</figure>
<p>然后AP知道NB2的地址，发送给NB2，Transmitter Address
(TA)就是AP的地址，然后NB1会忽略这个信息</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702083911532.png"
alt="image-20210702083911532" />
<figcaption aria-hidden="true">image-20210702083911532</figcaption>
</figure>
<p>然后NB2再发送回来</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702084059867.png"
alt="image-20210702084059867" />
<figcaption aria-hidden="true">image-20210702084059867</figcaption>
</figure>
<p>再发给交换机</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702084122539.png"
alt="image-20210702084122539" />
<figcaption aria-hidden="true">image-20210702084122539</figcaption>
</figure>
<p>交换机知道PC1，所以只发个PC1</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702084143221.png"
alt="image-20210702084143221" />
<figcaption aria-hidden="true">image-20210702084143221</figcaption>
</figure>
<h2 id="网络层vermittlungsschicht">网络层Vermittlungsschicht</h2>
<h3 id="中转的类型vermittlungsarten">中转的类型Vermittlungsarten:</h3>
<ol type="1">
<li>Leitungsvermittlung</li>
<li>Nachrichtenvermittlung</li>
<li>Paketvermittlung</li>
</ol>
<h4 id="leitungsvermittlung电路交换">Leitungsvermittlung电路交换</h4>
<p>有3步</p>
<ol type="1">
<li>建立连接Verbindungsaufbau</li>
<li>交换数据Datenaustausch</li>
<li>断开连接Verbindungsabbau</li>
</ol>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702090258393.png"
alt="image-20210702090258393" />
<figcaption aria-hidden="true">image-20210702090258393</figcaption>
</figure>
<p>计算传输时间： <span class="math display">\[
T_{L V}=2 t_{p}+t_{s}+2 t_{p}=t_{s}+4 t_{p}=\frac{L}{r}+\frac{4 d}{\nu
c_{0}}
\]</span> 优点：</p>
<p>传输质量稳定，传递快速，不需要其他传递</p>
<p>缺点：</p>
<p>如果不一直用的话，会浪费资源。建立连接复杂。建立物理连接花费高</p>
<h4 id="报文交换">报文交换</h4>
<p>长度为 <span class="math inline">\(L\)</span> 的信息会加入长度为
<span class="math inline">\(L_H\)</span> 的头</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702092836254.png"
alt="image-20210702092836254" />
<figcaption aria-hidden="true">image-20210702092836254</figcaption>
</figure>
<p>头包含发送者，接收者地址，中站站以及一些信息。然后头和信息一起传输</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702094819239.png"
alt="image-20210702094819239" />
<figcaption aria-hidden="true">image-20210702094819239</figcaption>
</figure>
<p>如果有2个中转站： <span class="math display">\[
T_{N V}=(n+1) \cdot t_{s}+t_{p}=(n+1) \cdot
\frac{L_{H}+L}{r}+\frac{d}{\nu c_{0}}
\]</span> <span class="math inline">\(t_s\)</span> 是序列化时间，<span
class="math inline">\(t_p\)</span> 是总共传输时间</p>
<p>Multiplexing的情况：</p>
<p>如果是多个在一起的话，可以重复使用某个路段，称为(Zeitmultiplex) (Time
Division Multiplex, TDM)</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702100235315.png"
alt="image-20210702100235315" />
<figcaption aria-hidden="true">image-20210702100235315</figcaption>
</figure>
<p>优点：</p>
<p>Flexibles Zeitmultiplex von Nachrichten</p>
<p>节约资源，开始没有建立连接的延迟</p>
<p>缺点：</p>
<p>如果 <span class="math inline">\(i,j\)</span>
在使用中，那么信息传输会被缓存Pufferung</p>
<p>如果 Puffer 有限，那么会丢失信息</p>
<p>同一个信息会有多次序列化时间</p>
<h4 id="分组交换">分组交换</h4>
<p>信息被分成若干个小单元，分次发送</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702100627511.png"
alt="image-20210702100627511" />
<figcaption aria-hidden="true">image-20210702100627511</figcaption>
</figure>
<p>每个小单元会有自己的头</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702100656321.png"
alt="image-20210702100656321" />
<figcaption aria-hidden="true">image-20210702100656321</figcaption>
</figure>
<p>每个小单元不一定是相同长度的，但是有一个长度的上限<span
class="math inline">\(p_{max}\)</span></p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702100807798.png"
alt="image-20210702100807798" />
<figcaption aria-hidden="true">image-20210702100807798</figcaption>
</figure>
<p>此时的传输时间是： <span class="math display">\[
T_{P V}=\frac{1}{r}\left(\left[\frac{L}{p_{\max }}\right] \cdot
L_{h}+L\right)+\frac{d}{\nu c_{0}}+n \cdot \frac{L_{h}+p_{\max }}{r}
\]</span> 如果是多个传输的话</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702100959210.png"
alt="image-20210702100959210" />
<figcaption aria-hidden="true">image-20210702100959210</figcaption>
</figure>
<p>如果丢失包了，只需要重新发送一小段</p>
<p>优点：</p>
<p>Flexibles Zeitmultiplex einzelner Pakete</p>
<p>只需要缓冲小的数据包</p>
<p>缺点：</p>
<p>可能会丢失数据包，每个数据包必须有头，接收者要重新组合数据包</p>
<h3 id="网络中的地址">网络中的地址</h3>
<h4 id="ipv4-internet-protocol-v4">IPv4 (Internet Protocol v4)</h4>
<p>我们考虑一个路由器的网络</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702101422743.png"
alt="image-20210702101422743" />
<figcaption aria-hidden="true">image-20210702101422743</figcaption>
</figure>
<p>每个主机有一个IP地址，每个IP地址是四组数字用点分隔</p>
<p>每个发送包要有发送者的IP和接收者的IP</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702101602606.png"
alt="image-20210702101602606" />
<figcaption aria-hidden="true">image-20210702101602606</figcaption>
</figure>
<h5 id="ipv4-header">IPv4-Header</h5>
<figure>
<img src="https://fyindex.work/PicGo/image-20210702101738903.png"
alt="image-20210702101738903" />
<figcaption aria-hidden="true">image-20210702101738903</figcaption>
</figure>
<p><strong>Version</strong>是IP地址的版本，可能的值是 <code>4</code> 和
<code>6</code></p>
<p><strong>IHL (IP Header Length)</strong>
是IP头长度，长度一般是<code>32bit</code> 的倍数</p>
<p><strong>TOS (Type of Service)区分服务，</strong></p>
<p><strong>Total Length</strong></p>
<ul>
<li>这个IP包裹的长度(Header+Daten)</li>
<li>最长的是 <code>65535 B</code></li>
</ul>
<p><strong>标志Flag:</strong></p>
<ul>
<li>DF(Don’t Fragment) 不能分片</li>
<li>MF(More Fragment) 后面还有分片(=1), 后面没有分片(=0)</li>
</ul>
<p><strong>Fragment Offset片偏移：</strong></p>
<p>该分片在原来数据中的位置</p>
<p><strong>生存时间TTL(Time To Live):</strong></p>
<p>表示这个数据的再网络中的寿命，转发一次就减1,0就丢弃</p>
<p><strong>协议Protocol</strong> 如 TCP，UDP</p>
<p><strong>首部检验和Header Checksum</strong>
只检验数据报的首部，只检查，不修改</p>
<p><strong>源地址Source Address</strong> 发送者的IP地址</p>
<p><strong>目的地址Destination Address</strong> 接受者的IP地址</p>
<p><strong>可变部分Options / Padding</strong>
IP支持的选项可以填在这里，如果不足4B的倍数可以在这里填充</p>
<p>在发送之前要把 Host Byte Order (Little Endian bei x86) 转成 Network
Byte Order (Big Endian)</p>
<h4 id="arp请求">ARP请求</h4>
<p>主机1知道主机2的IP地址，但不知道它的MAC地址。所以主机1发送一个ARP请求，询问主机2的MAC地址。然后主机2发送ARP回复，回复它的MAC地址</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703051114332.png"
alt="image-20210703051114332" />
<figcaption aria-hidden="true">image-20210703051114332</figcaption>
</figure>
<h4 id="icmp协议">ICMP协议</h4>
<p>IP协议支持发送数据包到目的主机，但是可能会发生问题：包陷入死循环，不能找到目标主机，不能解析MAC地址…</p>
<p>ICMP可以告知发生的错误类型和支持其他操作，如Ping,Redirect</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703055653971.png"
alt="image-20210703055653971" />
<figcaption aria-hidden="true">image-20210703055653971</figcaption>
</figure>
<p>从主机1 Ping 主机2</p>
<p>首先主机1选择一个随机的Identifier(16bit), Echo
Request像IP包那样传递。如果主机2拿到了 Echo Request，那么它会回复 Echo
Reply。如果出错了，ICMP互发回一个错误码</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703065230457.png"
alt="image-20210703065230457" />
<figcaption aria-hidden="true">image-20210703065230457</figcaption>
</figure>
<p>如果包的TTL变成0了，那么会返回超时的错误</p>
<p>ICMP还可以Traceroute，跟踪数据包经过的节点</p>
<p>它发送若干个数据包，第一次发送一个
TTL=1的，第二次TTL=2的,然后就能知道经过哪些节点了</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703065501278.png"
alt="image-20210703065501278" />
<figcaption aria-hidden="true">image-20210703065501278</figcaption>
</figure>
<h4 id="dynamic-host-configuration-protocol-dhcp">Dynamic Host
Configuration Protocol (DHCP)</h4>
<p>主机如何获得IP地址：自动分配(通过DHCP服务器)和手动分配</p>
<p>首先客户端发送DHCP-Discover(广播)，DHCP服务器回复DHCP-Offer里面有分配的IP地址。</p>
<p>客户端回复DHCP-Request
表示确定要这个地址，然后DHCP服务器回复DHCP-ACK或者
DHCP-NACK表示接受或者拒绝。</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703065846776.png"
alt="image-20210703065846776" />
<figcaption aria-hidden="true">image-20210703065846776</figcaption>
</figure>
<p>IP地址的类型分成5类</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703070000960.png"
alt="image-20210703070000960" />
<figcaption aria-hidden="true">image-20210703070000960</figcaption>
</figure>
<p>因为后来IP地址不够用了，于是就引入了子网的概念Subnetze</p>
<p>网络接口除了IP地址外，还有32bit的子网掩码Subnetzmaske</p>
<p>子网掩码把IP地址分为网络部分Netzanteil和主机部分Hostanteil</p>
<p>1表示Netzanteil，0表示Hostanteil</p>
<p>IP地址和子网掩码共同组成网络地址Netzadresse</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210703070411261.png"
alt="image-20210703070411261" />
<figcaption aria-hidden="true">image-20210703070411261</figcaption>
</figure>
<h4 id="ipv6">IPv6</h4>
<p>它与IPv4的变化主要是：增大了IP地址到128bit,简化了头，改变了IP-Fragmentierung..</p>
<p>IPv6地址和IPv4地址类似，但是分成了16组</p>
<p><img src="https://fyindex.work/PicGo/image-20210704040337269.png"
alt="image-20210704040337269" /> <span class="math display">\[
2001:0db8:0000:0000:0001:0000:0000:0001
\]</span> 对于这个地址</p>
<p>多个0可以用1个0表示： <span class="math display">\[
2001:db8:0:0:1:0:0:1
\]</span> 最前面的最长的连续0可以省略 <span class="math display">\[
2001:db8::1:0:0:1
\]</span></p>
<h5 id="ipv6头">IPv6头</h5>
<figure>
<img src="https://fyindex.work/PicGo/image-20210704040540324.png"
alt="image-20210704040540324" />
<figcaption aria-hidden="true">image-20210704040540324</figcaption>
</figure>
<p>Traffic Class：和IPv4的TOS类似</p>
<p>Flow Label：用于识别哪些数据包是在一起的</p>
<p>Payload Length: 后面数据的长度</p>
<p>Next Header: 下一个头的类型(如TCP,UDP)</p>
<p>Hop Limit ： 对于Ipv4 的 TTL</p>
<p>扩展的IPv6协议支持把 Layer 3的信息也一起打包</p>
<h5 id="特殊的ipv6地址">特殊的IPv6地址</h5>
<p><code>::1/128</code> Localhost</p>
<p><code>::/128</code> 未指定的地址</p>
<p><code>fe80:: / 10</code> – Link-Local Adressen</p>
<p><code>fc00: / 7</code> Unique-Local Unicast-Adressen</p>
<p><code>ff00:: / 8</code> Multicast-Adressen</p>
<h5 id="multicast">Multicast</h5>
<p><code>ff02::1</code> – All Nodes</p>
<p><code>ff02::2</code> – All Routers</p>
<p><code>ff02::1:2</code> – All DHCP-Agents</p>
<p><code>ff02::1:ff00:0/104</code> – Solicited-Node Address</p>
<p>从 IPv6地址映射到MAC地址 <span class="math display">\[
f f 02:: 1: f f c 6: 938 b \quad \mapsto \quad 33: 33: f f: c 6: 93: 8 b
\]</span></p>
<h5 id="slaac">SLAAC</h5>
<p>IPv6允许在子网里自动配置主机</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20210704043643168.png"
alt="image-20210704043643168" />
<figcaption aria-hidden="true">image-20210704043643168</figcaption>
</figure>
<p>前缀是 <code>fe80::/10</code></p>
<p>Subnet Identifier 是 <code>0</code></p>
<h5 id="icmpv6">ICMPv6</h5>
<figure>
<img src="https://fyindex.work/PicGo/image-20210704043847439.png"
alt="image-20210704043847439" />
<figcaption aria-hidden="true">image-20210704043847439</figcaption>
</figure>
<h5 id="neighbor-discovery-protocol-ndp">Neighbor Discovery Protocol
(NDP)</h5>
<h3 id="路由wegwahlrouting">路由Wegwahl(Routing)</h3>
<h4 id="静态路由statisches-routing">静态路由Statisches Routing</h4>
<figure>
<img src="https://fyindex.work/PicGo/image-20210704044115882.png"
alt="image-20210704044115882" />
<figcaption aria-hidden="true">image-20210704044115882</figcaption>
</figure>
<p>R1 如何确定数据包该往哪里走</p>
<h5 id="routing-table">Routing Table</h5>
<p>在路由表里有</p>
<ul>
<li>目标地址</li>
<li>前缀长度</li>
<li>下一个Next-Top（网关）</li>
<li>可以到大Next-Top的接口</li>
<li>达到目标的花费</li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20210704044338044.png"
alt="image-20210704044338044" />
<figcaption aria-hidden="true">image-20210704044338044</figcaption>
</figure>
<h5 id="匹配最长前缀longest-prefix-matching">匹配最长前缀Longest Prefix
Matching</h5>
<h4 id="动态路由">动态路由</h4>
<p>bellmanford算法，dijkstra算法</p>
<h2 id="运输层">运输层</h2>
<h3 id="udp">UDP</h3>
<h3 id="tcp">TCP</h3>
<h2 id="sitzungsschicht">Sitzungsschicht</h2>
<h2 id="应用层anwendungsschicht">应用层Anwendungsschicht</h2>
<h1 id="网络安全">网络安全</h1>
<h3 id="网络分析工具">网络分析工具</h3>
<h4 id="wireshark">Wireshark</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wireshark-qt</span><br></pre></td></tr></table></figure>
<p>用 <code>sudo wireshark</code> 来启动，这样才能读取到网卡信息</p>
<h3 id="arp协议">ARP协议</h3>
<p>Socket抽象层是应用层和传输层直接的软件抽象层。它把TCP/IP协议封装成一个借口给程序员使用。</p>
<ul>
<li>流套接字 TCP</li>
<li>数据表套接字 UDP</li>
<li>原始套接字 可以发送从应用层到链路层的数据。</li>
</ul>
<h2 id="vpn">VPN</h2>
<p>VPN(Virtual Private Network)
是利用开放的公众IP网络建立专用数据传输通道，将远程的分之机构、移动办公人员连接起来。</p>
<h3 id="按隧道网络">按隧道网络</h3>
<p>第二层隧道网络：L2TP，PPTP，L2F。</p>
<p>原始数据包 -&gt; PPP封装-&gt; L2TP封装 - &gt;
新增ip头+L2TP头+PPP头+原始数据包</p>
<p>第三层隧道协议：如IPSec</p>
<p>SSTap-beta</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://fyind.de">Fyind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://fyind.de/2020/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://fyind.de/2020/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post-share"><div class="social-share" data-image="/img/pic1.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/04/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="线性代数"><img class="cover" src="/img/a2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">线性代数</div></div><div class="info-2"><div class="info-item-1">矩阵 \(K\) 永远是个物体(Körper) ，比如\(K= R , C , Q , F _{2} \ldots\) 定义1.1 矩阵的定义 \(m,n \in N_{&gt;0}\) , 一个\(m*n\)的矩阵式一个矩形的序列 \[ A=\left(\begin{array}{cccc} a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1, n} \\ a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2, n} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{m, 1} &amp; a_{m, 2} &amp; \cdots &amp; a_{m, n} \end{array}\right) \] 其中 \(a_{i, j} \in K\) 。根据定义我们知道，若两个矩阵相等，当且仅当它里面所有元素都相等。矩阵还有其他写法： \[ A=\left(a_{i, j}\right)_{i=1, \ldots, m\atop j=1,\dots,n}=\...</div></div></div></a><a class="pagination-related" href="/2020/04/02/%E6%A6%82%E7%8E%87%E8%AE%BA/" title="概率论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">概率论</div></div><div class="info-2"><div class="info-item-1">离散概率空间 基础部分 定义1 离散概率空间 离散概率空间(diskreter Wahrscheinlichkeitsraum)是单位元事件(Elementarereignis)的所有结果集合(Ergebnismenge)  。 定义2 单位元事件 每个事件元素  都对应一个可能性  ,其中, 并且  #### 定义3 事件 集合  是事件，该事件的概率是  事件  是事件  的对立事件(komplementäres Ereignis)。两个事件是分离的(disjunkt/unvereinbar)若  . 定义4 相对频繁度(relative Häufigkeit) 事件相对频繁度的绝对频繁度所有观测次数的所有出现次数所有观测次数 定义5 无限概率空间 概率空间  是有限概率空间。关于无限概率空间，我们只考虑  ，也就是离散的情况 例子 假设我们扔一个硬币，直到正面出现。 是反面出现的概率，正面出现的概率是  .那么概率空间我们可以表示为丢硬币的次数直到正面出现。  设  仍硬币  次的事件元素。那么  . 并且：  #### 数学公式补充   定理8 性质 对于事件  有：  ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fyind</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fyind"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Fyind" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tarjan0025@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=d0kMY0nN" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来逛逛我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">层次模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">信息的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%86%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">有条件的熵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%86%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">组合熵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">传递信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-sicherungsschicht"><span class="toc-number">3.</span> <span class="toc-text">数据链路层 Sicherungsschicht</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.1.</span> <span class="toc-text">网络的图表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">3.1.2.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84pfad"><span class="toc-number">3.1.3.</span> <span class="toc-text">路径Pfad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.4.</span> <span class="toc-text">网络拓扑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5"><span class="toc-number">3.1.5.</span> <span class="toc-text">邻接矩阵和距离矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.6.</span> <span class="toc-text">生成树结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%89%B9%E5%BE%81"><span class="toc-number">3.2.</span> <span class="toc-text">连接特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%8E%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">传递率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ausbreitungsgeschwindigkeit"><span class="toc-number">3.2.2.</span> <span class="toc-text">Ausbreitungsgeschwindigkeit</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ausarbeitungsverz%C3%B6gerung%E4%BC%A0%E9%80%92%E5%BB%B6%E8%BF%9F"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">Ausarbeitungsverzögerung传递延迟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4%C3%BCbertragungszeit"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">传输时间Übertragungszeit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bandbreitenverz%C3%B6gerungsprodukt"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">Bandbreitenverzögerungsprodukt</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiplex"><span class="toc-number">3.3.</span> <span class="toc-text">Multiplex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aloha"><span class="toc-number">3.3.1.</span> <span class="toc-text">ALOHA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slotted-aloha"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">Slotted ALOHA</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#carrier-sense-multiple-access-csma"><span class="toc-number">3.3.2.</span> <span class="toc-text">Carrier Sense Multiple
Access (CSMA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csmacd-collision-detection"><span class="toc-number">3.3.3.</span> <span class="toc-text">CSMA&#x2F;CD (Collision Detection)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csmaca-collision-avoidance"><span class="toc-number">3.3.4.</span> <span class="toc-text">CSMA&#x2F;CA (Collision Avoidance)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#token-passing"><span class="toc-number">3.3.5.</span> <span class="toc-text">Token Passing</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E8%AF%86%E5%88%AB%E9%94%99%E8%AF%AF"><span class="toc-number">3.4.</span> <span class="toc-text">源数据，寻址，识别错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.1.</span> <span class="toc-text">识别数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#l%C3%A4ngenangabe-der-nutzdaten"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">Längenangabe der Nutzdaten</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%88%86%E9%9A%94%E7%AC%A6begrenzungsfelder-und-bit-stopfen"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">通过分隔符Begrenzungsfelder
und Bit-Stopfen</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#coderegelverletzung"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">Coderegelverletzung</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80adressierung"><span class="toc-number">3.4.2.</span> <span class="toc-text">寻址Adressierung</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E9%94%99%E8%AF%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text">识别错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%92%8C2%E5%B1%82%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">1层和2层的连接方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hub-bridges-und-switches"><span class="toc-number">3.5.1.</span> <span class="toc-text">Hub, Bridges und Switches</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wlan-access-points"><span class="toc-number">3.5.2.</span> <span class="toc-text">WLAN Access Points</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82vermittlungsschicht"><span class="toc-number">4.</span> <span class="toc-text">网络层Vermittlungsschicht</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E8%BD%AC%E7%9A%84%E7%B1%BB%E5%9E%8Bvermittlungsarten"><span class="toc-number">4.1.</span> <span class="toc-text">中转的类型Vermittlungsarten:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#leitungsvermittlung%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="toc-number">4.1.1.</span> <span class="toc-text">Leitungsvermittlung电路交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2"><span class="toc-number">4.1.2.</span> <span class="toc-text">报文交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">4.1.3.</span> <span class="toc-text">分组交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text">网络中的地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ipv4-internet-protocol-v4"><span class="toc-number">4.2.1.</span> <span class="toc-text">IPv4 (Internet Protocol v4)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ipv4-header"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">IPv4-Header</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arp%E8%AF%B7%E6%B1%82"><span class="toc-number">4.2.2.</span> <span class="toc-text">ARP请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#icmp%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.3.</span> <span class="toc-text">ICMP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic-host-configuration-protocol-dhcp"><span class="toc-number">4.2.4.</span> <span class="toc-text">Dynamic Host
Configuration Protocol (DHCP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ipv6"><span class="toc-number">4.2.5.</span> <span class="toc-text">IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ipv6%E5%A4%B4"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">IPv6头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84ipv6%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">特殊的IPv6地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#multicast"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">Multicast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#slaac"><span class="toc-number">4.2.5.4.</span> <span class="toc-text">SLAAC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#icmpv6"><span class="toc-number">4.2.5.5.</span> <span class="toc-text">ICMPv6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#neighbor-discovery-protocol-ndp"><span class="toc-number">4.2.5.6.</span> <span class="toc-text">Neighbor Discovery Protocol
(NDP)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1wegwahlrouting"><span class="toc-number">4.3.</span> <span class="toc-text">路由Wegwahl(Routing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1statisches-routing"><span class="toc-number">4.3.1.</span> <span class="toc-text">静态路由Statisches Routing</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#routing-table"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">Routing Table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80longest-prefix-matching"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">匹配最长前缀Longest Prefix
Matching</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">4.3.2.</span> <span class="toc-text">动态路由</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#udp"><span class="toc-number">5.1.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp"><span class="toc-number">5.2.</span> <span class="toc-text">TCP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sitzungsschicht"><span class="toc-number">6.</span> <span class="toc-text">Sitzungsschicht</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82anwendungsschicht"><span class="toc-number">7.</span> <span class="toc-text">应用层Anwendungsschicht</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-number"></span> <span class="toc-text">网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">0.1.</span> <span class="toc-text">网络分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wireshark"><span class="toc-number">0.1.1.</span> <span class="toc-text">Wireshark</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arp%E5%8D%8F%E8%AE%AE"><span class="toc-number">0.2.</span> <span class="toc-text">ARP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vpn"><span class="toc-number">1.</span> <span class="toc-text">VPN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%9A%A7%E9%81%93%E7%BD%91%E7%BB%9C"><span class="toc-number">1.1.</span> <span class="toc-text">按隧道网络</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程">C++高性能编程</a><time datetime="2025-07-17T19:47:19.000Z" title="Created 2025-07-17 19:47:19">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="操作系统概念">操作系统概念</a><time datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置">Kubuntu配置</a><time datetime="2025-07-15T05:25:37.000Z" title="Created 2025-07-15 05:25:37">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E6%88%91%E4%BB%AC%E5%9C%A8AI%E6%97%B6%E4%BB%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/" title="我们在AI时代该如何学习">我们在AI时代该如何学习</a><time datetime="2025-07-12T23:12:19.000Z" title="Created 2025-07-12 23:12:19">2025-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CA-Top-Down-Approach/" title="计算机网络A Top Down Approach">计算机网络A Top Down Approach</a><time datetime="2025-07-12T22:02:58.000Z" title="Created 2025-07-12 22:02:58">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fyind</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>