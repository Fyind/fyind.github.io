<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>动态规划入门 | Fyind's Blog</title><meta name="author" content="Fyind"><meta name="copyright" content="Fyind"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态规划入门（一） 动态规划(Dynamic Programming)，简称dp，是算法竞赛中一种非常重要的解决问题的手段之一。 一、什么是动态规划 从本质上来说，动态规划就是递推，我们先来看一个有关地推的例子。  例题1、 斐波那契数列  输入\(n\), 求斐波那契数列的第n项   我们在上小学的时候就知道，斐波那契数列的递推式是 \[ f(n) &#x3D; f(n-1) + f(n-2), f(1)">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划入门">
<meta property="og:url" content="http://fyind.de/2019/12/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Fyind&#39;s Blog">
<meta property="og:description" content="动态规划入门（一） 动态规划(Dynamic Programming)，简称dp，是算法竞赛中一种非常重要的解决问题的手段之一。 一、什么是动态规划 从本质上来说，动态规划就是递推，我们先来看一个有关地推的例子。  例题1、 斐波那契数列  输入\(n\), 求斐波那契数列的第n项   我们在上小学的时候就知道，斐波那契数列的递推式是 \[ f(n) &#x3D; f(n-1) + f(n-2), f(1)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://fyind.de/img/a3.jpg">
<meta property="article:published_time" content="2019-12-03T20:13:44.000Z">
<meta property="article:modified_time" content="2025-07-18T10:49:53.877Z">
<meta property="article:author" content="Fyind">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyind.de/img/a3.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "动态规划入门",
  "url": "http://fyind.de/2019/12/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/",
  "image": "http://fyind.de/img/a3.jpg",
  "datePublished": "2019-12-03T20:13:44.000Z",
  "dateModified": "2025-07-18T10:49:53.877Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fyind",
      "url": "http://fyind.de"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pic1.PNG"><link rel="canonical" href="http://fyind.de/2019/12/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态规划入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://fyindex.work/PicGo/liuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/a3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Fyind's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">动态规划入门</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">动态规划入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-12-03T20:13:44.000Z" title="Created 2019-12-03 20:13:44">2019-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-18T10:49:53.877Z" title="Updated 2025-07-18 10:49:53">2025-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="动态规划入门一">动态规划入门（一）</h2>
<p>动态规划(Dynamic
Programming)，简称dp，是算法竞赛中一种非常重要的解决问题的手段之一。</p>
<h3 id="一什么是动态规划">一、什么是动态规划</h3>
<p>从本质上来说，动态规划就是递推，我们先来看一个有关地推的例子。</p>
<ul>
<li><h4 id="例题1-斐波那契数列">例题1、 斐波那契数列</h4>
<blockquote>
<p>输入<span class="math inline">\(n\)</span>, 求斐波那契数列的第n项</p>
</blockquote></li>
</ul>
<p>我们在<del>上小学</del>的时候就知道，斐波那契数列的递推式是 <span
class="math display">\[
f(n) = f(n-1) + f(n-2), f(1) = f(2) = 1
\]</span>
要计算第n项，需要先知道第n-1项和n-2项。要知道第n-1项就要知道n-2和n-3项……直到遇到边界条件f(1)和f(2)。那么反过来说，知道了第1项和第2项，就能知道第3项，第4项及以后。</p>
<p>为什么我要从两种角度说明呢，因为这两种角度正是设计和编写动态规划算法的两种思路和实现方式</p>
<p>第一种角度是从后往前推，用<strong>递归</strong>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">1</span> || x == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">f</span>(x<span class="number">-1</span>) + <span class="built_in">f</span>(x<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有一个问题：当n教大的时候，运行时间会非常长。因为其中存在重复计算的问题。比如计算f(6)的时候会需要计算f(5),f(4)。而计算f(5)的时候要计算f(4)和f(3)。其中我们多次重复计算了f(4)。而当n越来越大的时候，重复计算的问题会越来越明显。它的时间复杂度会达到搜索的指数复杂度。如果我们可以在计算完f(4)的时候记住他的答案，等到下次计算的时候就不用再调用递归了，直接返回我们记住的答案就可以了，这会大幅度提升程序运行的速度。在实现动态规划的递归代码的时候，这是不可缺少的。我们称它为<strong>记忆化</strong>。由于用递归解决问题的方式类似搜索，所以也这种用递归实现的也叫<strong>记忆化搜索</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[x]) <span class="keyword">return</span> dp[x]; <span class="comment">// 别忘了在之前初始化dp[]数组</span></span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">1</span> || x == <span class="number">2</span> ? <span class="number">1</span> : dp[x] = <span class="built_in">f</span>(x<span class="number">-1</span>) + <span class="built_in">f</span>(x<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种角度是从前往后推，用<strong>for循环</strong>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>] = f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>;i &lt;= n; ++i) f[i] = f[i<span class="number">-1</span>] + f[i];</span><br></pre></td></tr></table></figure>
<p>可以看到，for循环实现的代码相比递归的更加简洁，而且本身自带“记忆化”。所以一般我们都会用for循环的递推方式来实现动态规划。</p>
<p><strong>状态转移方程，子结构：</strong></p>
<p>我们再看斐波那契数列的递推式: <span class="math display">\[
f(n) = f(n-1) + f(n-2), f(1) = f(2) = 1
\]</span> 这个递推式在动态规划中称作<strong>状态转移方程</strong>。<span
class="math inline">\(f(n)，f(n-1)，f(n-2)\)</span>是问题的状态。<span
class="math inline">\(f(n)\)</span>这个状态可以由<span
class="math inline">\(f(n-1)\)</span>与<span
class="math inline">\(f(n-2)\)</span>转移过来。因此称它为状态转移方程。在这里，状态f(n)的定义是，斐波那契数列的第n项。而<span
class="math inline">\(f(n-1)\)</span>与<span
class="math inline">\(f(n-2)\)</span>是<span
class="math inline">\(f(n)\)</span>的<strong>子结构</strong>。因为<span
class="math inline">\(f(n)\)</span>和<span
class="math inline">\(f(n-1)\)</span>，<span
class="math inline">\(f(n-2)\)</span>的问题是相同的，都是求数列的第几项。<u>不同的只是问题的大小。</u><span
class="math inline">\(f(n)\)</span>比<span
class="math inline">\(f(n-1)\)</span>和<span
class="math inline">\(f(n-2)\)</span>要大。<strong>一个问题的解，可以由它的子结构通过状态转移方程转移而来，那么这个问题可以使用动态规划解。</strong>而<span
class="math inline">\(f(1),f(2)\)</span>是<strong>边界条件</strong>，<span
class="math inline">\(f(n)\)</span>是<strong>总问题</strong></p>
<p><strong>状态转移方程是动态规划的核心。我们解决一个问题首先就应该思考这个问题的状态转移方程该怎么写</strong></p>
<p>然而，例题1却不是真正意义上的动态规划。通过例子1，我介绍了动态规划的几个关键概念。它最多只能称得上“规划”，而没有“动态”。下面让我们来看一个动态的例子。</p>
<ul>
<li><h4 id="例题201背包问题">例题2、01背包问题</h4>
<blockquote>
<p>有<span
class="math inline">\(n\)</span>个物品，第i个物品的价值是<span
class="math inline">\(v_{i}&gt;0\)</span>，重量是<span
class="math inline">\(w_{i}&gt;0\)</span>。 你有个容量为<span
class="math inline">\(V\)</span>的背包。每个物品只能拿一次。请问该如何拿才能是背包内物品价值最大化。<span
class="math inline">\(1&lt;=n&lt;=2000,0&lt;=V&lt;=2000\)</span></p>
</blockquote></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1048">评测链接</a></p>
<p>这是一个十分典型的动态规划例题。</p>
<p>首先，<strong>每个物品只有拿或者不拿这两种选项（这也是01的意思）</strong>，如果我们已经考虑了<span
class="math inline">\(n-1\)</span>个物品，只剩下最后一个物品了。
我的背包还放得下这个物品，那么我肯定可以拿走它。如果我的背包放不下，那么我就不会选它，我当前背包的价值就是最终的答案。</p>
<p>如果<span class="math inline">\(f(i, j)\)</span>代表我要选完第<span
class="math inline">\(i\)</span>个物品，我的已经用掉的空间是<span
class="math inline">\(j\)</span>，所得出的总价值。那么有 <span
class="math display">\[
f(n,j) =max\left\{\begin{matrix}f(n-1,j-w_{i}) +
v_{i}   \qquad\qquad\qquad (选第n个物品)
&amp;  &amp; \\ f(n-1,j)\qquad\qquad\qquad\qquad\qquad(不选第n个物品)
&amp;  &amp;
\end{matrix}\right.
\]</span> 可以看到，我们在选和不选之间做了一个求最大化的决策。而如果$
f(n-1,j-w_{i}) <span class="math inline">\(是我选完\)</span>n-1<span
class="math inline">\(个物品后得出的最大价值的状态，并且\)</span>f(n-1,j)<span
class="math inline">\(也是选完\)</span>n-1$个物品后的最大值。（注意：这两个状态是不一样的因为背包容量不一样）。因为最后的状态只会从这两种状态转移而来，那么最后我们总得取一个最大值，那得出的肯定就是全部的最大值了。</p>
<p>然后我们思考状态转移方程。从上面的方程我们可以观察到一件很巧的事情：<span
class="math inline">\(f(n-1,j-w_{i})\)</span> 和 <span
class="math inline">\(f(n-1,j)\)</span> 正是<span
class="math inline">\(f(n,j)\)</span>
的子结构。他们都是从选完某个物品后，背包剩余了某个容量所得出的价值最大值。只是数据的大小不一样。<strong>所以，我们可以用相同的策略解决子问题，从而得出子问题的最大值。</strong>因为问题是相同的，我们只要把n改成i，就有了状态转移方程：
<span class="math display">\[
f(i,j) =max\left\{\begin{matrix}f(i-1,j-w_{i}) + v_{i}   \qquad,j &gt;=
w_{i}\qquad\qquad (选第i个物品)
&amp;  &amp; \\ f(i-1,j)\qquad\qquad\qquad\qquad\qquad(不选第i个物品)
&amp;  &amp;
\end{matrix}\right.
\]</span> 这里我补充了 <span
class="math inline">\(j&gt;=w_{i}\)</span>因为显然，已经用掉的背包容量不可能是负数。然后考虑一下边界条件和问题的解。如果还没有开始选物品，显然价值是0，已经用掉的背包可以大于零（因为可以不使用一部分背包容量）。即边界条件为<span
class="math inline">\(f(0,j)=0\)</span>。总问题的解显然就是<span
class="math inline">\(f(n,V)\)</span>了。</p>
<p>为了便于理解，我们可以画一个状态转移的表格：</p>
<p>比如<span class="math inline">\(n=3, V =
3。w_{1}=3,v_{1}=2;w_{2}=2,v_{2}=1;w_{3}=1,v_{3}=2;\)</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">i</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
f(0,0)\mathbb{R}ightarrow f(1,0)\mathbb{R}ightarrow
f(2,1)\mathbb{R}ightarrow f(3,3)
\]</span></p>
<p>所以最终答案是3。</p>
<p>至此，我们可以写出记忆化搜索的，和for循环版本的代码。</p>
<p>记忆化搜索：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j]) <span class="keyword">return</span> dp[i][j]; <span class="comment">//别忘了记忆化</span></span><br><span class="line">    <span class="keyword">return</span> dp[i][j] = j &gt;= w[i] ? <span class="built_in">max</span>(<span class="built_in">f</span>(i<span class="number">-1</span>,j - w[i]) + v[i], <span class="built_in">f</span>(i<span class="number">-1</span>, j)) : <span class="built_in">f</span>(i<span class="number">-1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= V; ++j) </span><br><span class="line">        f[i][j] = j &gt;= w[i] ? <span class="built_in">max</span>(f[i<span class="number">-1</span>][j-w[i]] + v[i], f[i<span class="number">-1</span>][j]) : f[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>
<p>我们观察动态规划的方程与斐波那契数列递推的方程，可以发现，动态规划的方程中，有一个max取最大值的操作。这就是动态规划与递推不同的地方。<strong>动态规划在递推的过程中会动态地取最大值，最后得出问题的总最大值。</strong></p>
<h3 id="二动态规划的步骤">二、动态规划的步骤</h3>
<p>通过背包问题，我们可以总结出，思考动态规划问题的几个步骤</p>
<ul>
<li><p><strong>思考问题的状态转移关系，寻找子结构</strong>
在这里我们分析了，每个问题的转移性质：每个物品只有拿或者不拿这两种选项。也就是问题从两个状态转移来：选或者不选。接着我们分析了：<u>问题的解可以从它的子结构的最优解转移来。</u>然后我们确定了问题的状态：<span
class="math inline">\(f(i,j)\)</span>表示<span
class="math inline">\(i\)</span>个物品，使用了<span
class="math inline">\(j\)</span>的背包容量得出的最有解。</p></li>
<li><p><strong>定义出合适的状态，写出状态转移方程</strong>
接着我们就可以写出问题的状态转移方程了，注意这里别补充限制条件。比如某些地方不能出现负数<span
class="math inline">\((j&gt;=w_{i})\)</span></p></li>
<li><p><strong>确定边界条件和最终解的形式</strong>
边界条件确定了解最终是从哪个状态转移过来的。找到最终解是哪个状态。</p></li>
<li><p><strong>写出代码</strong>
递归版的代码和for循环的都可以写。不够对于某些题目，for循环的版本可以进行空间复杂度的优化，所以for循环更普遍。关于优化的技巧，我们将在后续谈到。</p></li>
</ul>
<h3 id="三为什么动态规划是对的">三、为什么动态规划是对的</h3>
<p>然后是动态规划正确性的证明： <strong>1、对方程正确性的证明</strong>
<strong>数学归纳：</strong></p>
<ul>
<li>只有<span class="math inline">\(1\)</span>个物品的时候。容量有<span
class="math inline">\(0~V\)</span>种情况的子问题就是<span
class="math inline">\(f(0,j),0&lt;=j&lt;=V\)</span> 当<span
class="math inline">\(j≥w_{1}\)</span>时答案就是<span
class="math inline">\(v_{1}\)</span>， 否则就是0当</li>
<li>选到第<span class="math inline">\(i\)</span>个物品的时候<span
class="math inline">\(f(i,j)\)</span>这个问题，我们通过转移方程知道，它只会由<span
class="math inline">\(f(i-1,j)\)</span>和<span
class="math inline">\(f(i-1,j-w_{i})\)</span>这两个状态过来，而这两个状态我们已经得到了最优解，那么我从两个里面选一个更优的出来，就是我自己的最优解。
这样从<span
class="math inline">\(1\)</span>开始，依次迭代，最终出来的<span
class="math inline">\(f(n,V)\)</span>一定是最优解</li>
</ul>
<p><strong>2、对于最优子结构性质的证明：</strong></p>
<p><strong>我需要证明两个性质</strong>：</p>
<ul>
<li><u>性质1、该问题的解只会由子结构转移得来。</u>在这个问题里，<span
class="math inline">\(f(i,j)\)</span>只会由<span
class="math inline">\(f(i-1,j)\)</span>和<span
class="math inline">\(f(i-1,j-w_{i})\)</span>转移来，而且都是这个问题的子结构。证毕。</li>
<li><u>性质2、该问题的最优解，只会由子结构的最优解转移过来。</u>比如对于这道题，<span
class="math inline">\(f(i,j)\)</span>的最优解只会由它的子结构<span
class="math inline">\(f(i-1,j)\)</span>和<span
class="math inline">\(f(i-1,j-w_{i})\)</span>转移过来。我已经计算出来了子结构的最优解，我可以由此算出一个更优的解。假设有另一种情况：问题的解是由子结构的某一个非最优解转移过来得出的最优解。设这个解是<span
class="math inline">\(f(i-1,j)’&lt; f(i-1,j)\)</span>那么根据方程，<span
class="math inline">\(f(i,j)’\)</span>&lt;<span
class="math inline">\(f(i,j)\)</span>矛盾。所以该问题的最优解只会从子结构的最优解转移过来，证毕。</li>
</ul>
<p><strong>一个问题是否能用动态规划解决，就是看它有没有最优子结构性质。</strong></p>
<p>​
换句话说，只要一个问题具备了最优子结构性质就可以用动态规划解决。但是却不能用来在一开始判断一个问题是否能用动态规划解决。因为这个判断是基于状态转移方程和子结构来作为基础的。而一个问题可能会有多种状态的定义方式，而有些定义方式是没有最优子结构的性质，有些定义方式是有最优子结构性质的。所以到底一个问题能不能用动态规划来解决，要先尝试后才知道。
所以这个证明方法可以用来判断自己的算法，状态转移方程有没有错误。也就是证明方程正确性的方法。
虽然说没有一个固定的方法判断一个题是否能用动态规划来做，但在做题的时候多多少少都会给一些提示信息，比如数据范围，明显的选择性。
<strong>3、关于动态规划证明的推论：</strong></p>
<p>​
对于一个方程而言，如果它除了子结构部分和上一层有关，其他用到的数据都只与这一层有关，那么在证明完性质1后，性质2也必然正确。举个例子，这个方程里面子结构部分是带有<span
class="math inline">\(f\)</span>符合的<span
class="math inline">\(f(i-1,j),f(i-1,j-w_{i})\)</span>，这一层是第<span
class="math inline">\(i，j\)</span>层。其他用到的数据是<span
class="math inline">\(w_{i},v_{i}\)</span>。于是可以发现，除了子结构部分，其他数据都只与这一层有关。所以性质2是正确的，因为，只要其他数据只与这一层有关，你总可以通过反证法证明出性质2是正确的。
<strong>4、动态规划的性质</strong> ​ 动态规划和搜索有什么不同之处？
首先，我提出两个概念：后效性和重叠子结构。</p>
<ul>
<li>后效性是指，这一层的抉择会影响后面状态的抉择。</li>
<li>重叠子结构是指，在动态规划的求解过程中，有很多相同的问题会被多次求解。</li>
</ul>
<p><strong>在搜索中，问题是有后效性。并且几乎没有重叠子结构。</strong></p>
<p><strong>在动态规划中，问题没有后效性。并且有大量重叠子结构。</strong></p>
<p>​
在背包问题中，我考虑前i个物品的时候，i前面的物品的选择是不会对我第i个物品的选择造成影响的。如果背包问题有依赖性，比如选了某一个物品后，另一个物品就不能选了。这样就会有后效性。因为我不知道前面有没有物品选择过，我这个物品有可能就不具备状态转移方程中“要么选，要么不选”的性质了。那为什么会有重叠子结构呢？不加上记忆化的动态规划就是普通的搜索，它的复杂度是指数级的。也就是它会需要产生指数个子问题需要求解。但这些子问题大部分都是重复的。在搜索的时候做了大量重复的工作。我们可以从方程总知道。一共只有
$ nV $ 种不同的问题需要求解，而通过递推，这些问题都可以在 $ O(1) $
的时间内解决。所以总的问题复杂度是$ O(n
V)$。它使得我们可以在多项式复杂度内求解它。</p>
<p>​ 所以动态规划有以下的性质</p>
<ul>
<li><p>最优子结构</p></li>
<li><p>无后效性</p></li>
<li><p>大量重叠子结构</p>
<p>可以用动态规划解的问题必然具备这几个性质。</p></li>
</ul>
<h3 id="四动态规划方程的多样性">四、动态规划方程的多样性</h3>
<p>一个问题的方程不一定是一致的。一个问题通过不同的思考角度，可能会有不同的方程。有些方程可以正确解题，而有些却不能。我们还是以上面的背包问题进行举例。</p>
<p>比如状态的定义不同，<span
class="math inline">\(f(i,j)\)</span>表示考虑完第<span
class="math inline">\(i\)</span>个物品后，<span
class="math inline">\(j\)</span>表示<strong>剩余的背包容量</strong>的最优解。那么可以写出下面的方程
<span class="math display">\[
f(i,j)=max \begin{cases} f(i-1,j+w_{i})+v_{i}
&amp; \text { , } j+w_{i}&lt;=V \\ f(i-1,j)
&amp;
\end{cases}\\
边界条件：f(0,V)=0，最终解： f(n,k) ,0&lt;=k&lt;=V
\]</span> 比如<span class="math inline">\(f(i,j)\)</span>
表示考虑完第i个物品后，j表示<strong>剩余背包容量</strong>的最优解，但是<strong>正着推</strong>。
<span class="math display">\[
f(i,j)=max \begin{cases} f(i+1,j-w_{i})+v_{i}
&amp; \text { , } j&gt;=w_{i} \\ f(i+1,j)
&amp;
\end{cases}\\边界条件：f(n,k)=0,1&lt;=k&lt;=V,最sf终解：f(0,V)
\]</span>
这两个方程都是正确的。但是相比上面给出的方程却不便于编写。具体代码编写留给读者作为练习完成。（注意for循环的方向需要保证子结构先计算好）。</p>
<h3 id="五空间复杂度优化">五、空间复杂度优化</h3>
<p>观察背包问题的方程的方程： <span class="math display">\[
f(i,j) =max\left\{\begin{matrix}f(i-1,j-w_{i}) + v_{i}   \qquad,j
\geqslant w_{i}\qquad\qquad (选第i个物品) &amp;  &amp; \\
f(i-1,j)\qquad\qquad\qquad\qquad\qquad(不选第i个物品) &amp;  &amp;
\end{matrix}\right.
\]</span></p>
<p>可以发现，<span class="math inline">\(f(i,j)\)</span>的答案之和<span
class="math inline">\(f(i-1,k)\)</span>有关也就是，只和<span
class="math inline">\(i\)</span>的上一层<span
class="math inline">\(i-1\)</span>，而不需要<span
class="math inline">\(i-2,i-3\)</span>有关。而我们再整个计算过程用二维数组存储了所有的答案。这样是有些浪费空间的。不妨把与计算无关的空间利用起来，可以省去一个维度，这就是所谓的<strong>滚动数组</strong>。</p>
<p>比较稳妥的方法是使用两行的数组，区分上一行与这一行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now = <span class="number">1</span>, pre = <span class="number">0</span>; <span class="comment">// 设置现在要计算的now，和之前的答案pre</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= V; ++j) </span><br><span class="line">        f[now][j] = j &gt;= w[i] ? <span class="built_in">max</span>(f[pre][j-w[i]] + v[i], f[pre][j]) : f[pre][j];</span><br><span class="line">    <span class="built_in">swap</span>(now,pre); <span class="comment">// 滚动</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[pre][V] &lt;&lt; endl; <span class="comment">// 最终答案</span></span><br></pre></td></tr></table></figure>
<p>最佳的压缩方式可以直接压缩成一维数组，但此时要特别注意for循环的方向。不能把之后需要计算答案的部分给覆盖了，所以这里第二个for循环需要反过来。如果不反过来的话。那么先计算了<span
class="math inline">\(f(i,0)\)</span> 然后计算<span
class="math inline">\(f(i,5)\)</span>的时候需要用到<span
class="math inline">\(f(i-1,0)\)</span>而此时它已经被覆盖了，此时就会算错。而滚动数组则再压缩的时候不用考虑这个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = V;j &gt;= <span class="number">0</span>; --j) <span class="comment">// 注意for循环方向反过来了</span></span><br><span class="line">        f[j] = j &gt;= w[i] ? <span class="built_in">max</span>(f[j-w[i]] + v[i], f[j]) : f[j];</span><br></pre></td></tr></table></figure>
<p>由于递归的调用不是一层一层的，所以不能进行空间压缩。</p>
<h2
id="动态规划入门二线性dp之背包问题">动态规划入门（二）——线性DP之背包问题</h2>
<p>背包问题分为很多种，其实不止01背包问题。其他的比如完全背包问题，多重背包问题，分组背包问题…….而背包问题的模型思想适用于解决很多问题。</p>
<h3 id="一完全背包问题">一、完全背包问题</h3>
<blockquote>
<p>有<span
class="math inline">\(n\)</span>个物品，第i个物品的价值是<span
class="math inline">\(v_{i}&gt;0\)</span>，重量是<span
class="math inline">\(w_{i}&gt;0\)</span>。 你有个容量为<span
class="math inline">\(V\)</span>的背包。每个物品可以拿无限次。请问该如何拿才能是背包内物品价值最大化。<span
class="math inline">\(1\leqslant n\leqslant 2000, 0 \leqslant V
\leqslant 2000\)</span></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">评测链接</a></p>
<p>完全背包问题是01背包问题的一个变种：每个物品数量从只能拿一次，变成了可以拿无限次。在01背包中，我们考虑完了第i个物品后，要去向第i+1个。但是完全背包问题中。我们却不能直接去下一个，而是可能继续考虑当前的。总得来说，当我们考虑第i个物品的时候，我们有2种选择：</p>
<ul>
<li>当背包还有空间的时候，拿走这个物品</li>
<li>不拿物品，考虑下一个物品</li>
</ul>
<p>于是我们可以写出如下的方程： <span class="math display">\[
f(i,j)=max \begin{cases} f(i,j-w_{i})+v_{i} &amp; ,j \geqslant w_{i}\\
f(i-1,j)
\end{cases} \\
边界条件:f(0,k)=0 , 0 \leqslant k \leqslant V ,  最终解 f(n,V)
\]</span> 对应的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= V; ++j) </span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(j &gt;= w[i] ? f[i][j-w[i]] + v[i] : <span class="number">0</span>, f[i<span class="number">-1</span>][j]);</span><br></pre></td></tr></table></figure>
<p>我们发现，<span class="math inline">\(f(i,j)\)</span>
的答案恰好和上一层i和这一层i有关，所以我们可以用滚动数组压缩一个维度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= V; ++j) </span><br><span class="line">        f[now][j] = <span class="built_in">max</span>(j &gt;= w[i] ? f[now][j-w[i]] + v[i] : <span class="number">0</span>, f[pre][j]);</span><br><span class="line">    <span class="built_in">swap</span>(now,pre);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[pre][V] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>如果还要压缩得极限一点，我们可以只使用1个一维数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= V; ++j) </span><br><span class="line">        f[j] = <span class="built_in">max</span>(j &gt;= w[i] ? f[j-w[i]] + v[i] : <span class="number">0</span>, f[j]);</span><br></pre></td></tr></table></figure>
<p>如果我们把这一段代码和01背包压成一维数组的代码进行比较的话，会发现。除了第二层的for的方向反过来了，其他的都没有边。这是为什么呢？</p>
<p>(留坑待填)</p>
<h3 id="二分组背包问题">二、分组背包问题</h3>
<blockquote>
<p>有<span class="math inline">\(n\)</span> 组物品，每组有 <span
class="math inline">\(s\)</span> 个物品 每组物品只能选 <span
class="math inline">\(1\)</span> 个，第 $ i$ 组第 <span
class="math inline">\(k\)</span> 个物品的价值是<span
class="math inline">\(v_{i,k}&gt;0\)</span>，重量是<span
class="math inline">\(w_{i,k}&gt;0\)</span>。 你有个容量为<span
class="math inline">\(V\)</span>的背包。请问该如何拿才能是背包内物品价值最大化。<span
class="math inline">\(1\leqslant n\leqslant 2000, 0 \leqslant V
\leqslant 2000\)</span></p>
</blockquote>
<p>我们先枚举组的方案，然后，对于每一组，有 <span
class="math inline">\(s\)</span> 种选择。那么通过枚举选择可以写出方程:
<span class="math inline">\(f(i,j)\)</span> 表示对于前 <span
class="math inline">\(i\)</span> 组物品, 用了 <span
class="math inline">\(j\)</span> 容量的背包的子问题。 <span
class="math display">\[
f(i,j)=max \begin{cases} f(i-1,j-w_{i,k})+v_{i,k}
&amp; \text { , } j \ge w_{i,k} &amp; 1 \le k \le s \\ f(i-1,j)
&amp;
\end{cases}\\
\]</span></p>
<h4 id="例1金明的预算方案">例1、金明的预算方案</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1064">题目连接</a></p>
<p>思路：我们可以把每个主件和它的从属附件看成一个组。那么枚举这个组的所有可能性：</p>
<ul>
<li><p>啥也不选</p></li>
<li><p>只选主件</p></li>
<li><p>选主件和附件1(如果有附件1)</p></li>
<li><p>选主件和附件2(如果有附件2)</p></li>
<li><p>选主件和附件1和附件2 (如果有附件3)</p></li>
</ul>
<p>那么就可以转化成分组背包的模型了。用分组背包来解释就是每组物品有5个(5种选择),每组物品只能选一个.(选一种可能性作为最大值).
所以我们就可以用分组背包来解决它。我们把方程写出来 <span
class="math display">\[
f(i,j)=max \begin{cases}
f(i-1,j-w_{i,0})+v_{i,0}\cdot w_{i,0}
&amp; \text { , } j \ge w_{i,0}\cdot v_{i,0}  \land 存在主件
\\
f(i-1,j-w_{i,0}-w_{i,1})+v_{i,0}\cdot w_{i,0}+v_{i,1}\cdot w_{i,1}
&amp; \text { , } j \ge w_{i,0}\cdot v_{i,0} + v_{i,1}\cdot
w_{i,1}  \land 存在附件1
\\
f(i-1,j-w_{i,0}-w_{i,2})+v_{i,0}\cdot w_{i,0}+v_{i,2}\cdot w_{i,2}
&amp; \text { , } j \ge w_{i,0}\cdot v_{i,0} + v_{i,2}\cdot
w_{i,2}  \land 存在附件2
\\
f(i-1,j-w_{i,0}-w_{i,1}-w_{i,2})+v_{i,0}\cdot w_{i,0}+v_{i,1}\cdot
w_{i,1}+v_{i,2}\cdot w_{i,2}
&amp; \text { , } j \ge w_{i,0}\cdot v_{i,0} + v_{i,1}\cdot
w_{i,1}  +v_{i,2}\cdot w_{i,2} \land 存在附件1,2
\\
f(i-1,j)
&amp;
\end{cases}\\
\]</span> 如此我们就可以把代码写出来了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m, V;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>)), <span class="built_in">p</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>)), <span class="built_in">c</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>)), <span class="built_in">f</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V<span class="number">+1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, x;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (!x) v[i][<span class="number">0</span>] = a, p[i][<span class="number">0</span>] = b, c[i][<span class="number">0</span>] = a * b;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[x][<span class="number">1</span>]) v[x][<span class="number">1</span>] = a, p[x][<span class="number">1</span>] = b, c[x][<span class="number">1</span>] = a * b;</span><br><span class="line">            <span class="keyword">else</span> v[x][<span class="number">2</span>] = a, p[x][<span class="number">2</span>] = b, c[x][<span class="number">2</span>] = a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= V; ++j) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (!p[i][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i][<span class="number">0</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][<span class="number">0</span>]] + c[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (p[i][<span class="number">1</span>] &amp;&amp; j &gt;= v[i][<span class="number">0</span>] + v[i][<span class="number">1</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - v[i][<span class="number">0</span>] - v[i][<span class="number">1</span>]] + c[i][<span class="number">0</span>] + c[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (p[i][<span class="number">2</span>] &amp;&amp; j &gt;= v[i][<span class="number">0</span>] + v[i][<span class="number">2</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - v[i][<span class="number">0</span>] - v[i][<span class="number">2</span>]] + c[i][<span class="number">0</span>] + c[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (p[i][<span class="number">1</span>] &amp;&amp; p[i][<span class="number">2</span>] &amp;&amp; j &gt;= v[i][<span class="number">0</span>] + v[i][<span class="number">1</span>] + v[i][<span class="number">2</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - v[i][<span class="number">0</span>] - v[i][<span class="number">1</span>] - v[i][<span class="number">2</span>]]</span><br><span class="line">                + c[i][<span class="number">0</span>] + c[i][<span class="number">1</span>] + c[i][<span class="number">2</span>]);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][V] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2排兵布阵">例2、排兵布阵</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5322">题目链接</a></p>
<p>首先发现，如果对某个城市发兵打过了某个玩家 <span
class="math inline">\(i\)</span>,
那么对于发兵数量不如他的所有玩家我们都可以打得过。所以我们可以按每个城市的发兵数量排序。然后预处理出打过第
<span class="math inline">\(i\)</span>
个玩家所可以获得的分数。如果我们可以把城市看做一个组，那么每个城市有
<span class="math inline">\(s\)</span> 个玩家，就有 <span
class="math inline">\(s\)</span> 种选择，打过第 <span
class="math inline">\(i\)</span>
个玩家，或者不打这个城市。那么我们就可以按照分组背包的思路写出方程。</p>
<p><span class="math inline">\(f(i,j)\)</span> 代表攻打前 <span
class="math inline">\(i\)</span> 坐城池，派出 <span
class="math inline">\(j\)</span> 个士兵的收益。<span
class="math inline">\(sol_{i,k}\)</span> 表示攻打第 <span
class="math inline">\(i\)</span> 个城池，第 <span
class="math inline">\(k\)</span> 大派出兵力的玩家派出的兵力。 <span
class="math inline">\(sum_{i,k}\)</span> 代表攻下第 <span
class="math inline">\(i\)</span> 坐城池，派出刚好可以攻下第 <span
class="math inline">\(k\)</span> 大的玩家的兵力所得到的收益。 <span
class="math display">\[
f(i,j)=max \begin{cases} f(i-1,j-sol_{i,k}*2-1)+sum_{i,k}
&amp; \text { , } j \ge sol_{i,k}*2+1 &amp; 1 \le k \le s \\ f(i-1,j)
&amp;
\end{cases}\\
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oo (1e9+1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;d.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sol</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s<span class="number">+1</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sum</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s<span class="number">+1</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; sol[j][i];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123; </span><br><span class="line">        <span class="built_in">sort</span>(sol[i].<span class="built_in">begin</span>()<span class="number">+1</span>, sol[i].<span class="built_in">end</span>());  <span class="comment">// i 做城池按兵力排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= s; ++j) &#123;</span><br><span class="line">            sum[i][j] = sum[i][j<span class="number">-1</span>] + i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; ++j) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= s; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - sol[i][k]*<span class="number">2</span> - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - sol[i][k]*<span class="number">2</span> - <span class="number">1</span>] + sum[i][k]);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="动态规划入门三其他线性dp模型">动态规划入门（三）——其他线性DP模型</h2>
<h3 id="一区间环形动态规划">一、区间/环形动态规划</h3>
<h4 id="例1石子合并">例1：石子合并</h4>
<blockquote>
<p>在一个圆形操场的四周摆放<span
class="math inline">\(N\)</span>堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆。并将新的一堆的石子数，记为该次合并的得分。试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分。<span
class="math inline">\(1&lt;=N&lt;=100\)</span></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1880">评测链接</a></p>
<p>可以看到，石子是环形摆放的。如果直接写方程的话，会有后效性，因而无法用动态规划求解。处理环形动态规划的基本方发是：转化成一般的线性动态规划。我们这个环拆成一条线性的链。每堆石子都有可能摆在链的第一个位置。所以枚举N次。对拆出来的每个链，我们都计算一次动态规划，最后综合出一个总的答案。</p>
<p>对于每一条链，我们考虑最后一次合并，一定是只剩下某两堆合并过的石子，然后将他们合并。那两堆石子可以看作是子问题。对于合并某个区间<span
class="math inline">\([i,j]\)</span>之间的石子这个问题，把一个区间<span
class="math inline">\([i,j]\)</span>分成两堆，则一共有<span
class="math inline">\((j-i+1)\)</span>种分发。也就是分成<span
class="math inline">\([i,k],[k+1,j]\)</span>两堆，其中<span
class="math inline">\(i&lt;=k&lt;=j-1\)</span>。</p>
<p>设<span class="math inline">\(f(i,j)\)</span>是合并区间<span
class="math inline">\([i,j]\)</span>的石子的最大分数，若第<span
class="math inline">\(i\)</span>个石子的分数为<span
class="math inline">\(v_{i}\)</span>。所以它就是分成两个区间合并的最大值，加上从<span
class="math inline">\(i\)</span>到<span
class="math inline">\(j\)</span>石子数量的和。因为两堆合并，把它们的个数都加起来就是总个数了。我们就可以写出状态转移方程：
<span class="math display">\[
f(i,j) = _{max}\{f(i,k)+f(k+1,j)\} + \sum _{m=i}^{j}v_{m}  \text { ,
}i&lt;=k&lt;=j-1
\\边界条件：f(i,i)=0,最终解：f(1,N)
\]</span> 我们可以用前缀和的技巧来求<span
class="math inline">\(i\)</span>到<span
class="math inline">\(j\)</span>的和。这里<span
class="math inline">\(sum[i]\)</span>表示从第一个加到<span
class="math inline">\(i\)</span>个石子的综合。那么<span
class="math inline">\(\sum_{m=i}^{j}v_{m}\)</span> 就是<span
class="math inline">\(sum[j]-sum[i-1]\)</span>了。求解最小值的和求最大值的类似，只是把min改成max而已。下面我们看一下关键代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> oo = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, v[maxn*<span class="number">2</span>], DP[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>], dp[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>], sum[maxn*<span class="number">2</span>], ans, ANS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="comment">// 求解i到j的的最小答案</span></span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j]) <span class="keyword">return</span> dp[i][j]; <span class="comment">//记忆化</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp; ans = dp[i][j] = oo; <span class="comment">// 给dp[i][j]取别名为ans</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i;k &lt;= j<span class="number">-1</span>; ++k) </span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">f</span>(i,k) + <span class="built_in">f</span>(k<span class="number">+1</span>,j) );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans = ans + sum[j]-sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="comment">// 求解i到j的最大答案</span></span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (DP[i][j]) <span class="keyword">return</span> DP[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; ANS = DP[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i;k &lt;= j<span class="number">-1</span>; ++k) </span><br><span class="line">        ANS = <span class="built_in">max</span>(ANS, <span class="built_in">F</span>(i,k) + <span class="built_in">F</span>(k<span class="number">+1</span>,j) );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ANS = ANS + sum[j]-sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>; ++i) &#123; <span class="comment">//这里我把数组赋值了2遍，这样便于枚举</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; n) v[i] = v[i-n];    <span class="comment">//  比如 4 5 9 4： 4 5 9 4 4 5 9 4 </span></span><br><span class="line">       						        <span class="comment">//                    i     j  </span></span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + v[i];   <span class="comment">//  求sum数组                </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = oo; ANS = <span class="number">0</span>; <span class="comment">// 小写的ans和dp存最小值的答案，大写的存最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="built_in">sizeof</span>(DP)); <span class="built_in">memset</span>(dp, <span class="number">0</span>,<span class="built_in">sizeof</span>(dp)); <span class="comment">// 初始化算最大值的记忆化数组</span></span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">f</span>(i, i+n<span class="number">-1</span>)); ANS = <span class="built_in">max</span>(ANS, <span class="built_in">F</span>(i, i+n<span class="number">-1</span>)); <span class="comment">// 更新全局最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; ANS &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是推荐的练习题：</p>
<ul>
<li>习题1： <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1063">能量项链</a></li>
<li>习题2： <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2964">金币游戏</a></li>
</ul>
<h3 id="断环成链">断环成链</h3>
<p>[IOI1998]Polygon</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oo (1e9+1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcf</span><span class="params">(<span class="type">char</span> op, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(a) == oo || <span class="built_in">abs</span>(b) == oo) <span class="keyword">return</span> -oo;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;t&#x27;</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcg</span><span class="params">(<span class="type">char</span> op, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(a) == oo || <span class="built_in">abs</span>(b) == oo) <span class="keyword">return</span> oo;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;t&#x27;</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max4(a, b, c, d) (max(max(a, b), max(c, d)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min4(a, b, c, d) (min(min(a, b), min(c, d)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">op</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; op[i] &gt;&gt; A[i];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        op.<span class="built_in">push_back</span>(op[i]);</span><br><span class="line">        A.<span class="built_in">push_back</span>(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">2</span>*n<span class="number">+2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*n<span class="number">+2</span>, -oo));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(<span class="number">2</span>*n<span class="number">+2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*n<span class="number">+2</span>, oo));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        f[i][i] = g[i][i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n*<span class="number">2</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j;i &gt;= <span class="number">1</span>; --i) &#123;        </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i;k &lt; j; ++k) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], <span class="built_in">max4</span>(<span class="built_in">calcf</span>(op[k<span class="number">+1</span>], f[i][k], f[k<span class="number">+1</span>][j]),</span><br><span class="line">                              <span class="built_in">calcf</span>(op[k<span class="number">+1</span>], f[i][k], g[k<span class="number">+1</span>][j]), </span><br><span class="line">                              <span class="built_in">calcf</span>(op[k<span class="number">+1</span>], g[i][k], f[k<span class="number">+1</span>][j]),</span><br><span class="line">                              <span class="built_in">calcf</span>(op[k<span class="number">+1</span>], g[i][k], g[k<span class="number">+1</span>][j])));</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], <span class="built_in">min4</span>(<span class="built_in">calcg</span>(op[k<span class="number">+1</span>], f[i][k], f[k<span class="number">+1</span>][j]),</span><br><span class="line">                              <span class="built_in">calcg</span>(op[k<span class="number">+1</span>], f[i][k], g[k<span class="number">+1</span>][j]), </span><br><span class="line">                              <span class="built_in">calcg</span>(op[k<span class="number">+1</span>], g[i][k], f[k<span class="number">+1</span>][j]),</span><br><span class="line">                              <span class="built_in">calcg</span>(op[k<span class="number">+1</span>], g[i][k], g[k<span class="number">+1</span>][j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ansv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i][i + n - <span class="number">1</span>] == ans) ansv.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ansv) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二最长上升子序列">二、最长上升子序列</h3>
<blockquote>
<p>给出<span class="math inline">\(1\sim n\)</span>的一个序列 <span
class="math inline">\(A_n\)</span>，求它们的最长上升子序列的长度。例如 3
2 1 4 2 5 的最长上升子序列为 1 4 5，长度为3</p>
</blockquote>
<h4 id="二分优化">二分优化</h4>
<p>我们用 <span class="math inline">\(low_i\)</span> 表示长度为 <span
class="math inline">\(i\)</span>
的最长上升子序列的最后一项的最小值。这个 <span
class="math inline">\(low_i\)</span> 一定是单调不减的序列。因为假如
<span class="math inline">\(low_3 &gt; low_4\)</span>
，就是长度为3的上升序列的最后一项比长度为 4
的上升序列的最后一项还大，也就是这种情况: <span
class="math inline">\(low_3=[1,4,7]\)</span> ,$ low_4=[1,4,5,6]$
那么可以把<span class="math inline">\(low_4\)</span> 答案的一部分给
<span class="math inline">\(low_3\)</span> 使得 $low_3 $ 达到更优解。
<span class="math inline">\(low_3&#39;=[1,4,5]\)</span> 所以计算好的
<span class="math inline">\(low_i\)</span> 是单调不减的序列。</p>
<p>对于要求的序列的某个元素 <span class="math inline">\(A_i\)</span> ,
它的每一项有两个选择。</p>
<ul>
<li><p>它比当前的最长 <span class="math inline">\(low_{ans}\)</span>
的值还大，那么就通过把 <span class="math inline">\(A_i\)</span> 加入
<span class="math inline">\(low_{ans}\)</span> 的后面构造一个 <span
class="math inline">\(low_{ans+1}\)</span> 的答案</p></li>
<li><p>它小于 <span class="math inline">\(low_{ans}\)</span>
的答案，但是它或许可以更新 <span
class="math inline">\(low_{ans}\)</span> 前面的答案。 因为 <span
class="math inline">\(low_i\)</span>
是单调序列，我们可以二分找到刚好可以比它大的那个 <span
class="math inline">\(low_k\)</span> 然后更新它的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> n)</span> </span>&#123; <span class="comment">// 严格上升子序列</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n<span class="number">+1</span>, oo)</span></span>; <span class="comment">// const int oo = 1e9 + 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span> || A[i] &gt; low[ans]) low[++ans] = A[i];</span><br><span class="line">        <span class="keyword">else</span> low[<span class="built_in">lower_bound</span>(low.<span class="built_in">begin</span>()<span class="number">+1</span>, low.<span class="built_in">begin</span>()+ans<span class="number">+1</span>, A[i]) - low.<span class="built_in">begin</span>()] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LDS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> n)</span> </span>&#123; <span class="comment">// 最长不上升子序列</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n<span class="number">+1</span>, oo)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span> || -A[i] &gt;= low[ans]) low[++ans] = -A[i];</span><br><span class="line">        <span class="keyword">else</span> low[<span class="built_in">upper_bound</span>(low.<span class="built_in">begin</span>()<span class="number">+1</span>, low.<span class="built_in">begin</span>()+ans<span class="number">+1</span>, -A[i]) - low.<span class="built_in">begin</span>()] = -A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三最长公共子序列">三、最长公共子序列</h3>
<blockquote>
<p>给出<span class="math inline">\(1\sim n\)</span>的两个排列<span
class="math inline">\(P1\)</span>和<span
class="math inline">\(P2\)</span>，求它们的最长公共子序列的长度。例如 3
2 1 4 5 和 1 2 3 4 5 的最长公共子序列是 2 4 5，长度为3</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1439">评测链接</a></p>
<p>设有2个数列 : <span class="math display">\[
A_{1},A_{2},A_{3},A_{4},A_{5}...,A_{n}\\B_{1},B_{2},B_{3},B_{4},B_{5}...,B_{n}
\]</span> 我们从<span class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>各取任意一个数<span
class="math inline">\(A_{i}和B_{j}\)</span>，那么只有两种情况:</p>
<ul>
<li><p><span class="math inline">\(A_{i}=B_{j}\)</span>
这种情况下，它可以加在之前的公共子序列上。所以设<span
class="math inline">\(f(i,j)\)</span>是包含<span
class="math inline">\(A_{i},B_{j}\)</span>前面的最长公共子序列的长度是那么我们可以知道
<span
class="math inline">\(f(i,j)=f(i-1,j-1)+1\)</span>。当然，我们也可以选择不加在它上面。于是<span
class="math inline">\(f(i,j)=f(i,j-1);f(i,j)=f(i-1,j)\)</span>。在这三者间我们取个最大值</p></li>
<li><p><span class="math inline">\(A_{i}\neq B_{j}\)</span>
这种情况下，我们只能从前面的公共子序列转移过来。<span
class="math inline">\(f(i,j)=f(i,j-1);f(i,j)=f(i-1,j)\)</span>,并在它们之间取最大值。</p></li>
</ul>
<p>于是我们可以写出状态转移方程： <span class="math display">\[
f(i,j)=max \begin{cases} f(i-1,j-1)+1 &amp; ,A_{i}=B_{j} \\ f(i,j-1)
\\f(i-1,j)
&amp;
\end{cases}\\
边界条件:f(0,0) = 0, 最终解: f(n,n)
\]</span> 于是我们可以写出代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; ++j) &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于<span
class="math inline">\(f(i,j)\)</span>值只和这一层i和上一层<span
class="math inline">\(i\)</span>有关。所以可以用滚动数组压缩一个维度的空间复杂度，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; ++j) &#123;</span><br><span class="line">        f[now][j] = <span class="built_in">max</span>(f[pre][j], f[now][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[j]) f[now][j] = <span class="built_in">max</span>(f[now][j], f[pre][j<span class="number">-1</span>]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(now,pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nlogn优化">nlogn优化</h4>
<p>我们可以按照 <span class="math inline">\(A\)</span> 序列的值，给
<span class="math inline">\(B\)</span> 序列编号。于是问题就转化成了求
<span class="math inline">\(B\)</span> 编号的最长不下降子序列即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n<span class="number">+1</span>, oo)</span></span>; <span class="comment">// const int oo = 1e9 + 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span> || A[i] &gt;= low[ans]) low[++ans] = A[i];</span><br><span class="line">        <span class="keyword">else</span> low[<span class="built_in">upper_bound</span>(low.<span class="built_in">begin</span>()<span class="number">+1</span>, low.<span class="built_in">begin</span>()+ans<span class="number">+1</span>, A[i]) - low.<span class="built_in">begin</span>()] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M</span><span class="params">(n<span class="number">+1</span>, oo)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) M[A[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) B[i] = M[B[i]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LIS</span>(B, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划入门四dag动态规划">动态规划入门（四）——DAG动态规划</h2>
<p>另一个动态规划的经典模型是DAG（有向无环图）动态规划。很多问题都可以转换为有向无环图的模型，从而使用动态规划求解最长路来求解原问题。</p>
<p>且看下面这个例子</p>
<h3 id="例1求dag的最长路">例1：求DAG的最长路</h3>
<blockquote>
<p>给定一个图<span class="math inline">\(G(V,E)\)</span>, <span
class="math inline">\(n\)</span>是节点数，<span
class="math inline">\(m\)</span>是边数。每一条边都是有向边并且每个节点<span
class="math inline">\(i\)</span>有个权值<span
class="math inline">\(v_{i}\)</span>，并且图中没有环。求从节点<span
class="math inline">\(1\)</span>到<span
class="math inline">\(n\)</span>的一条路径，使得路径上的点权值和最大。<span
class="math inline">\(1&lt;=n&lt;=100000,0&lt;=m&lt;=500000\)</span></p>
</blockquote>
<p>首先，为什么DAG的求最长路可以动态规划。因为是没有环，所以没有后效性。假设<span
class="math inline">\(f(i)\)</span>表示从<span
class="math inline">\(i\)</span>走到<span
class="math inline">\(n\)</span>的最长路</p>
<p>我们可以写出如下的方程 <span class="math display">\[
f(i)=_{max}\{f(v)\}+v_{i}  \text { , } (i,v)是一条由i到v的边 \\
边界条件:f(n) = v_{n},最终解:f(1)
\]</span>
当然也可以从终点往起点推，根据问题的不同，不同的设法会有不同的编写难度。但都是正确的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n) <span class="keyword">return</span> v[x]; <span class="comment">//边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (dp[x][t]) <span class="keyword">return</span> dp[x]; <span class="comment">// 记忆化</span></span><br><span class="line">    dp[x] = v[x];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// 用邻接表存图</span></span><br><span class="line">        <span class="type">int</span> e = G[x][i]; <span class="type">int</span> v = to[e]; </span><br><span class="line">        mx = <span class="built_in">max</span>(mx, <span class="built_in">f</span>(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x] = dp[x] + mx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面让我们来看几个个转换的例题：</p>
<h3
id="一通过转换成有向无环图解决依赖关系">一、通过转换成有向无环图解决依赖关系</h3>
<p>很多题目里会给许多“约束条件”。比如选择某物品，或者到某个点的先决条件是XXX。我们可以把诸如此类的约束条件转换成有向无环图的边，来解。</p>
<h4 id="例2矩形嵌套问题">例2：矩形嵌套问题</h4>
<blockquote>
<p>有<span
class="math inline">\(n\)</span>个矩形，每个矩形可以用两个整数<span
class="math inline">\(a，b\)</span>描述，表示它的长和宽。矩形<span
class="math inline">\(X(a,b)\)</span>可以嵌套在矩形<span
class="math inline">\(Y(c,d)\)</span>中，当且仅当<span
class="math inline">\(a&lt;c,b&lt;d,或者b&lt;c,a&lt;d\)</span>（相当于旋转<span
class="math inline">\(90^{\circ}\)</span>）。例如<span
class="math inline">\((1,5)\)</span>可以嵌套在<span
class="math inline">\((6,2)\)</span>内，但不能嵌套在<span
class="math inline">\((3,4)\)</span>内。求最多的矩形排成一排，使得后一个恰好嵌套在前一个矩形里。</p>
</blockquote>
<p>这道题目中的约束条件就是嵌套关系，要选这个矩形必须要先选比它大的矩形。</p>
<ul>
<li>假设矩形<span class="math inline">\(X\)</span>可以嵌套矩形<span
class="math inline">\(Y\)</span>那么我们可以<strong>从<span
class="math inline">\(X\)</span>到<span
class="math inline">\(Y\)</span>建立一条有向边，表示要选Y必须先选X</strong>。</li>
<li>添加一个超级原点<span
class="math inline">\(S\)</span>。因为可以从任何一个矩形开始，所以我们从<span
class="math inline">\(S\)</span>到每一个矩形建立一条有向边。同样的我们添加一个超级终点<span
class="math inline">\(T\)</span>。因为可以从任何一个矩形结束，所以每个矩形还要通向<span
class="math inline">\(T\)</span>。</li>
<li>每个节点有一个权值为1。在寻找路径的时候，<strong>假设我们经过了一个点</strong>，那么我们加上它的权值1，<strong>表示我们选取这一个矩形。</strong>那么一条从S到T的路径上所有经过点的路径总和就对应了我们选取矩形的个数。<strong>因为走的是有向边，所以每一条路径都是合法的</strong>（也就是一个接一个嵌套的）。</li>
<li>因为大的矩形不能排在小的矩形后面，所以必然不可能出现环。这样DAG上从S到T的最长路径，就对应了我们要求的最优解。</li>
</ul>
<h3
id="二以时间为推移顺序构造有向无环图">二、以时间为推移顺序，构造有向无环图</h3>
<h4 id="例3打鼹鼠">例3：打鼹鼠</h4>
<blockquote>
<p>在一个<span class="math inline">\(n \ast
n\)</span>的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果i时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为<span
class="math inline">\((i,j)\)</span>的网格移向<span
class="math inline">\((i-1, j),(i+1,
j),(i,j-1),(i,j+1)\)</span>四个网格，机器人不能走出整个<span
class="math inline">\(n\ast
n\)</span>的网格。游戏开始时，你可以自由选定机器人的初始位置。</p>
<p>现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2285">评测链接</a></p>
<p>（留坑待填）</p>
<h3
id="三理论上任何一个动态规划都可以用dag的有向无环图解释">三、理论上任何一个动态规划都可以用DAG的有向无环图解释</h3>
<p>（留坑待填）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// 背包问题</span></span><br><span class="line">    <span class="keyword">if</span> (x == t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[x][y]) <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x<span class="number">+1</span>;i &lt;= t; ++i) &#123;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, y&gt;=w[i] ? <span class="built_in">f</span>(i,y-w[i]) : <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y] = v[x] + mx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形动态规划">树形动态规划</h2>
<p>有线电视网</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20200928203906346.png"
alt="image-20200928203906346" />
<figcaption aria-hidden="true">image-20200928203906346</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oo (1&lt;&lt;20)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">G</span>(n<span class="number">+1</span>, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;());</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, -oo)));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n<span class="number">+1</span>)</span>, <span class="title">sz</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> v, len;</span><br><span class="line">            cin &gt;&gt; v &gt;&gt; len;</span><br><span class="line">            G[i].<span class="built_in">push_back</span>(&#123;v, len&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n-m<span class="number">+1</span>;i &lt;= n; ++i) cin &gt;&gt; c[i];</span><br><span class="line">    </span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f = [&amp;](<span class="type">int</span> u)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt;= n-m<span class="number">+1</span>) &#123;</span><br><span class="line">            sz[u] = <span class="number">1</span>;</span><br><span class="line">            dp[<span class="number">0</span>][u][<span class="number">1</span>] = c[u];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        dp[pre][u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= G[u].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [v, len] = G[u][k<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; k&lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="built_in">f</span>(v);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            dp[now][u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= sz[u]; ++j) &#123;</span><br><span class="line">                dp[now][u][j] = dp[pre][u][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= sz[v]; ++i) &#123; <span class="comment">// 当前子树选i个</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= i) dp[now][u][j] = <span class="built_in">max</span>(dp[now][u][j], dp[pre][u][j-i] + dp[G[v].<span class="built_in">size</span>() % <span class="number">2</span>][v][i] - len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(now, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sz[<span class="number">1</span>];i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[G[<span class="number">1</span>].<span class="built_in">size</span>() % <span class="number">2</span>][<span class="number">1</span>][i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树形背包dp">树形背包dp</h3>
<p>我们以选课这题为例子，因为它非常的经典。它不仅包含了树形01背包的模型，它还是一个有依赖的背包问题。因此这道题有很多种解法，也有很多的地方值得讲一讲。</p>
<h4 id="选课">选课</h4>
<blockquote>
<p>现在有 <span class="math inline">\(N\)</span>
门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b
的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择
<span class="math inline">\(M\)</span>
门课程学习，问他能获得的最大学分是多少？</p>
<p>$ 1≤N≤300 , 1 M $</p>
</blockquote>
<h4 id="最简单的写法-on3">最简单的写法 <span
class="math inline">\(O(n^3)\)</span></h4>
<p>首先考虑状态转移方程。首先对于一个问题来说，它如果可以动态规划的话，那么他一定存在最优子结构。也就是说他是存在可以分解的子问题，并且答案是可从这个子问题中转移过来。对于一个树而言，它有一个天然的子问题结构：那就是子树的结构。【什么是子树】也就是说，可以把问题拆解为子树的问题，等子树解决完问题了之后，在和自己合并就可以得出自己的答案了。那么对于这道题而言，它是一个树形的结构。</p>
<p>那么第一个最容易想到的拆分思想就是, 以子树为单位做状态的划分：</p>
<p>假设 <span class="math inline">\(f(x,j)\)</span> 是当前这个根节点
<span class="math inline">\(x\)</span> 的子树中选 <span
class="math inline">\(j\)</span>
个节点的最大值。那么对于这个跟节点代表的这门课而言，我们只要两种选择：要么我选这门课，要么我不选这门课。</p>
<p>如果我不选这门课，那么我的价值就是 <span
class="math inline">\(0\)</span> ,
因为如果你不选这门课的话，你子树中的课也都不能选。</p>
<p>如果我选这门课，那么我的价值就是在我的子树中选 <span
class="math inline">\(j-1\)</span>
门课的最大价值加上自己的价值。那么怎么表示在子树中选 “j-1”
门课这个动作呢。我们可以枚举子树。如果 <span
class="math inline">\(v\)</span> 是我的子树，然后它选了 <span
class="math inline">\(k\)</span> 个节点。</p>
<p>我们可以从根节点开始考虑，每个先</p>
<p>修课的我可以选或者不选。如果我不选，那么我的子树也不能选。如果我选了，那么我就可以考虑子树选多少个了。</p>
<p><span class="math display">\[
f(x,i, j)=_{max} \{ f(v, v的孩子数, k)+ f(x, i-1, j-k)   \}
\\
f(x,1,1) = 1 \\
f(x,1,0) = 0
\]</span></p>
<h2 id="状态压缩dp">状态压缩dp</h2>
<p>宝藏</p>
<p>首先处理出每个状态走1步最多能到的状态。然后枚举每一个状态，然后枚举状态的子集，如果可以扩展，就计算一下最小的距离。</p>
<p>(待填)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> oo = <span class="number">1e9</span><span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">hasi</span><span class="params">(<span class="type">int</span> mask, <span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 从1 编号</span></span><br><span class="line">    <span class="keyword">return</span> (mask &amp; (<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>))) &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">seti</span><span class="params">(<span class="type">int</span> mask, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mask | (<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">subset</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b | a) == b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">tobits</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>(), ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= len; ++i) <span class="keyword">if</span> (s[len-i] == <span class="string">&#x27;1&#x27;</span>) ret = <span class="built_in">seti</span>(ret, i);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">tobstr</span><span class="params">(<span class="type">int</span> mask)</span> </span>&#123;</span><br><span class="line">    string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; <span class="built_in">seti</span>(<span class="number">0</span>, i) &lt;= mask; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasi</span>(mask, i)) ret = <span class="string">&quot;1&quot;</span> + ret;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="string">&quot;0&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">G</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, oo));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        G[x][y] = G[y][x] = <span class="built_in">min</span>(G[x][y], z);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> all = (<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cango</span><span class="params">(all + <span class="number">1</span>)</span></span>;   </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(all<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, oo));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">1</span>;mask &lt;= all; ++mask) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; ++j) <span class="keyword">if</span> (<span class="built_in">hasi</span>(mask, j)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n; ++k) <span class="keyword">if</span> (G[j][k] != oo) &#123;</span><br><span class="line">                cango[mask] = <span class="built_in">seti</span>(cango[mask], k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) f[<span class="built_in">seti</span>(<span class="number">0</span>, i)][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">1</span>;mask &lt;= all; ++mask) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s0 = mask<span class="number">-1</span>; s0 &gt;= <span class="number">1</span>; --s0) <span class="keyword">if</span> (<span class="built_in">subset</span>(s0, mask) &amp;&amp; <span class="built_in">subset</span>(mask, cango[s0]))&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; ++j) <span class="keyword">if</span> (!<span class="built_in">hasi</span>(s0, j) &amp;&amp; <span class="built_in">hasi</span>(mask, j)) &#123;</span><br><span class="line">                <span class="type">int</span> _min = oo;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) <span class="keyword">if</span> (<span class="built_in">hasi</span>(s0, i)) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">                    _min = <span class="built_in">min</span>(_min, G[i][j]);</span><br><span class="line">                &#125; </span><br><span class="line">                sum += _min;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) <span class="keyword">if</span> (f[s0][i<span class="number">-1</span>] != oo) &#123;</span><br><span class="line">                f[mask][i] = <span class="built_in">min</span>(f[s0][i<span class="number">-1</span>] + sum * i, f[mask][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = n == <span class="number">1</span> ? <span class="number">0</span> : oo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(f[all][i], ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划计数">动态规划计数</h2>
<p>子串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> oo = (<span class="number">1e9</span><span class="number">+1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(((ll)a + (ll)b) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">A</span><span class="params">(n<span class="number">+1</span>)</span>, <span class="title">B</span><span class="params">(m<span class="number">+1</span>)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; ++i) cin &gt;&gt; B[i];</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;   <span class="built_in">f</span>(<span class="number">2</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, <span class="number">0</span>)));</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;  <span class="built_in">sum</span>(<span class="number">2</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        f[<span class="number">0</span>][i][<span class="number">0</span>] = sum[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt;= t; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; ++j) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">                f[now][i][j] = f[now][i<span class="number">-1</span>][j];  <span class="comment">// i 正 </span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; A[i] == B[j]) f[now][i][j] = <span class="built_in">add</span>(f[now][i][j], sum[pre][i<span class="number">-1</span>][j<span class="number">-1</span>]); <span class="comment">// 计算上一层</span></span><br><span class="line">                <span class="keyword">if</span> (A[i] != B[j]) sum[now][i][j] = f[now][i][j];</span><br><span class="line">                <span class="keyword">else</span> sum[now][i][j] = <span class="built_in">add</span>(sum[now][i<span class="number">-1</span>][j<span class="number">-1</span>], f[now][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; ++i)  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; ++j)&#123;</span><br><span class="line">            f[pre][i][j] = <span class="number">0</span>;</span><br><span class="line">            sum[pre][i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(now, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[pre][n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数位dp">数位dp</h2>
<p>可以作为变量的</p>
<ul>
<li>数位之和 一共 9*12 = 110 左右</li>
<li>数字的个数</li>
<li>是否前导零</li>
</ul>
<p>首先数字转数位，然后再计算, 模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">13</span>][<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line">ll mod;</span><br><span class="line">ll A[<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos, ll sum, ll sumd, <span class="type">bool</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) <span class="keyword">return</span> sum == <span class="number">0</span> &amp;&amp; sumd == mod;  <span class="comment">// 边界条件</span></span><br><span class="line">    ll mx = limit ? A[pos] : <span class="number">9</span>; <span class="comment">// 设置上限</span></span><br><span class="line">    <span class="keyword">auto</span> ret = dp[pos][sum][sumd]; </span><br><span class="line">    <span class="keyword">if</span> (!limit &amp;&amp; ~ret) <span class="keyword">return</span> ret; <span class="comment">// 只有当不是沿着边界走的时候才记忆化，减少递归层数</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= mx; ++i) <span class="keyword">if</span> (sumd+i &lt;= mod) &#123;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(pos<span class="number">-1</span>, (sum*<span class="number">10</span> + i)%mod, sumd+i, limit &amp;&amp; i == A[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!limit) dp[pos][sum][sumd] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll len = <span class="number">0</span>; <span class="comment">// 数字转数位</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        A[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>*<span class="number">12</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">// 初始化</span></span><br><span class="line">        mod = i;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难题</p>
<p>https://blog.csdn.net/winter2121/article/details/81264324</p>
<h3 id="数位dp-1">数位dp</h3>
<p>最优子结构的理解：</p>
<blockquote>
<p>找出 <span class="math inline">\(\le x\)</span> 的个数</p>
</blockquote>
<p>答案就是 <span class="math inline">\(x+1\)</span> ,
然后我们用数位dp的思想来考虑这件事。</p>
<p>假设 <span class="math inline">\(x=5674\)</span></p>
<p>把 <span class="math inline">\(x\)</span> 存在数组 <span
class="math inline">\(A\)</span> 里面，要<strong>倒着存</strong>
(不使用0号位)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;4, 7, 6, 5&#125;</span><br></pre></td></tr></table></figure>
<p>设 <span class="math inline">\(dp(pos,limit)\)</span> 为：构造长度为
<span class="math inline">\(pos\)</span> 的数字，且之前是否沿着 <span
class="math inline">\(x\)</span> 的边界构造。 <span
class="math display">\[
\begin{align*}
dp(pos,1) &amp;= dp(pos-1,1) + (A[pos]-1)*dp(pos-1,i-1) \\
dp(pos,0) &amp;= 9*dp(pos-1,0)
\end{align*}
\]</span> 如果沿着边界构造(limit = 1)，那么下一位只能选择不超过 <span
class="math inline">\(x\)</span> 的下一位的数也就是 <span
class="math inline">\([0,A[pos]]\)</span></p>
<p>如果limit = 0, 那么下一位以及后面的所有位都可以选 <span
class="math inline">\([0,9]\)</span> 中的数字</p>
<p>性质：limit=1 的状态只有 <span class="math inline">\(len(A)\)</span>
个，如果还有其余状态也要乘上</p>
<p>也就是只有沿着 <span class="math inline">\(x\)</span> 构造才会出现
limit = 1，而且如果 limit = 1，那么之前所有的limit必定为1</p>
<p>所以可以省略limit这个参数，让limit=1的情况不用记忆化</p>
<p>如果只需要构造位数与 <span class="math inline">\(x\)</span>
相同的数字，只需要判断一下在第一次的时候从 <span
class="math inline">\(1\)</span> 开始就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mxnum = limit ? A[k] : <span class="number">9</span>;    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (pos==n);i &lt;= mxnum; ++i) &#123;</span><br><span class="line">   <span class="comment">// 代码</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>对于 <span class="math inline">\(x \le 0\)</span>
的情况要特判，不然转换数字会出错</p>
<p>对于 <span class="math inline">\(x\)</span>
的位数很大的情况，要使用字符串进行输入</p>
<p>对于要求最大最小值的问题，那么就要用两个边界来dp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ll tl = l;</span><br><span class="line"><span class="type">int</span> tota = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tl) &#123;</span><br><span class="line">    A[++tota] = tl % <span class="number">10</span>;</span><br><span class="line">    tl /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll tr = r;</span><br><span class="line"><span class="type">int</span> totb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tr) &#123;</span><br><span class="line">    B[++totb] = tr % <span class="number">10</span>;</span><br><span class="line">    tr /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="built_in">max</span>(tota, totb);</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> l1, <span class="type">int</span> l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span> || (l1 == <span class="number">0</span> &amp;&amp; l2 == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;cur = dp[pos][l1][l2];</span><br><span class="line">    <span class="keyword">if</span> (cur.first != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][l1][l2];</span><br><span class="line">    cur = &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> down = l1 ? A[pos] : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = l2 ? B[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = down;i &lt;= up; ++i) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://fyind.de">Fyind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://fyind.de/2019/12/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/">http://fyind.de/2019/12/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div><div class="post-share"><div class="social-share" data-image="/img/a3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/01/01/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机架构笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">计算机架构笔记</div></div><div class="info-2"><div class="info-item-1">一、冯诺依曼结构 Von-Neumann 概念  计算机的结构与处理的问题无关 计算机由4个单元构成 主存储器里的格子是相同大小的，每个都有个地址 程序和数据放在相同的存储器里 使用二进制 程序由一系列命令构成 顺序可以通过跳转指令改变    image-20200215163311067  Von-Neumann Architektur   image-20200215163344965  RISC &amp; CISC CISC: Complex Instruction Set Computer  通过微程序实现 优点：易编程，少的存储需求 缺点：复杂的解码  RISC: Reduced Instruction Set Computer  通过固定接线(feste Verdrahtung)实现 优点：简单，高效的实施 缺点：难编程    image-20200215164015342  Befehlsformat Einadressform   image-20200217191456458  Zweiadressform（IA-32）  计算结果覆盖第一个操作数 只有一个操...</div></div></div></a><a class="pagination-related" href="/2019/11/18/Python-basic/" title="Python基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Python基础</div></div><div class="info-2"><div class="info-item-1">python包管理器pip 安装 12python -m ensurepippython -m pip install --upgrade pip  安装对应版本的python 123sudo add-apt-repository ppa:deadsnakes/ppasudo apt updatesudo apt install python3.8 虚拟环境 123python3 -m venv myenvsource myenv/bin/activatedeactivate # 退出 Python 基础语法 注释 123456789# 单行注释print(&quot;helldo world&quot;)  # 行尾注释&quot;&quot;&quot;这是一个多行注释.....结束注释&quot;&quot;&quot; 运算符操作 12345620 // 6  #整除20 / 6   #除法10 % 3   #取余数2 ** 5	 #乘方1&lt;&lt;30  #位运算1 if x=2 else 2 # 三目运算符 字符串  双引号 中间可以加转义字符 单引号 纯字符输...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/08/10/AtCoder%E9%A2%98%E8%A7%A3/" title="AtCoder题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="info-item-2">AtCoder题解</div></div><div class="info-2"><div class="info-item-1">AtCoder Grand Contest 047 AtCoder Grand Contest 047 A. Integer Product 给定 \(n\) 个浮点数，计算有多少个 \((i, j)\) 使得 \(A_{i} \cdot A_{j}\) 是整数 \(2\leq N \leq 200 \  000\) , $ 0 &lt; A_{i} ^{4}$ , \(A_{i}\) 最多 \(9\) 为小数. 思路  通过题设条件缩小范围， 枚举  由于数据比较大，不能直接暴力做。判断是整数这个条件不太好集体维护。所以要找出题目中的特性，看看有没有机会让范围缩小。最好是可以 先考虑 \(A_{i} \cdot A_{j}\) 什么情况下是整数。发现，对于任意有限小数 \(x\), 可以在乘上 \(10^{n}\) 后肯定会变成整数。所以每个数必然是 \(k\cdot 2^{m}\cdot 5^{n}\) 的形式, 通过乘 \(10^{n}\) 把分母上的 \(2^{m}\cdot 5^{n}\) 约去. 而之前的 \(k\) 不影响答案。所以我们只要考虑 \(2^{m}\cd...</div></div></div></a><a class="pagination-related" href="/2020/07/29/CodeForces%E9%A2%98%E8%A7%A3/" title="CodeForces题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-29</div><div class="info-item-2">CodeForces题解</div></div><div class="info-2"><div class="info-item-1">Educational Codeforces Round 92 (Rated for Div. 2) link A. LCM Problem  构造  给定区间 \([l,r]\) 求 \(2\) 个在里面的数，使得它们的最小公倍数也在区间内，否则输出-1 -1 . 可以知道 \(l, l*2\) 是2个最小的可能组合，只要判断 \(l*2 &gt; r\) 即可. B. Array Walk  贪心  由于可以折返的步数比较少。我们可以枚举折返的步数。当折返的步数固定为 \(j\) 的时候。有2种情况，  \(j\) 步都是折返后又回来。这种情况最远走到了 \([1,k-2j]\) \(j-1\) 步是折返后又回来，最后一步是折返后不回来。这种情况的区间是 \([1,k-2(j-1)-1]\)  可以证明：若折返，则必定是在当前区间的最大两个相邻元素间折返。 那么我们用前缀和的方式求出 \([1,i]\) 的和还有最大相邻元素的位置。那么分情况讨论这两种情况的最大值。最后取个更优的解即可 \(O(n)\) 123456789101112131415161718192021222...</div></div></div></a><a class="pagination-related" href="/2020/05/26/Python%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/" title="三行写完高斯消元，这就是Python!!!"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-26</div><div class="info-item-2">三行写完高斯消元，这就是Python!!!</div></div><div class="info-2"><div class="info-item-1">三行写完高斯消元，这就是Python!!! 洛谷评测链接 先给大家看一眼核心代码 核心代码 123for i in range(len(a)):    row = [j for j in range(len(a)) if a[j][i] != 0 and sum(a[j][:i]) &lt; 1e-8][0]    a[:] = [r + a[row]*(-r[i]/a[row][i]) if j != row else r/a[row][i] for (j,r) in enumerate(a)] 没错，就只有三行，完成了高斯消元最核心的操作，把矩阵消元成主对角线为1，其余除了常数项全是0的形式。我只用了Python中的切片操作，列表解析式，还有numpy中array的性质。 为了方便大家理解，我先来介绍一些这些python中的语法 python语法介绍 切片 语法格式是 [开始:结束] 可以取出列表中的一段区间,如果不填写就是默认开始位置是0，结束位置是列表最后一个元素位置。注意这里的区间是左闭右开区间。并且支持倒着数，也就是使用负号 比如： 12345l = [0,2,3,4...</div></div></div></a><a class="pagination-related" href="/2020/08/10/Trie/" title="Trie"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="info-item-2">Trie</div></div><div class="info-2"><div class="info-item-1">Trie Trie 是一个用树来存储字符串的结构。 基本操作  插入一个字符串 查找一个字符串是否在树中 维护对应字符串的附加信息(如个数之类的)  模板  P2580 于是他错误的点名开始了  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int maxnode = maxn * 50;const int sigma_size = 26;#define c ((ch)-&#x27;a&#x27;)int child[maxnode][sigma_size], val[maxnode];int sz, n;void insert(string s) &#123;    int u = 0; // 从根节点 u = 0 开始插入    for (char ch : s) &#123;        i...</div></div></div></a><a class="pagination-related" href="/2020/08/14/%E5%81%9A%E9%A2%98%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%95%99%E8%AE%AD/" title="做题经验与教训"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-14</div><div class="info-item-2">做题经验与教训</div></div><div class="info-2"><div class="info-item-1">思维CheatSheet 思路 多角度思维 这个题有多少种思路，目前选择一条路。每个思路都要想一点。如果是dp，有多种方程，那每个都要考虑一下。 推导Observation  眼看出来的 基本公式，基于基本公式的Ob  卡住了 你想的题根本不是原问题  中间推导错了 题目读错了  换角度理解问题 转换问题的表示方法。换一种理解方式 常规推导  考虑答案由什么组成(拆分出可以维护的情况) 考虑最简单的几种情况(best case) 考虑状态的转移 什么会产生贡献，哪些会对答案产生贡献 考虑答案的单调性，时空转移  分类讨论  问题可以分为几种情况  贪心  什么构成答案最好（构造一个最好的答案）  计算操作的最大值最小值： 以某种贪心的策略一定可以达到最优，模拟这种策略的步骤  分析最大值  二分/枚举  如给定某个参数，是不是会好做一定  动态规划、递推  考虑问题的子结构 考虑状态是什么，如何转移 换一种更好的状态 简化子结构（去除冗余状态） 通过贪心优化转移，减少转移的数量 用数据结构维护一维度  整理思维 筛选合理的推断和考虑不确定的推断  题目的位置与代码量和思路深度对应...</div></div></div></a><a class="pagination-related" href="/2020/11/10/%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/" title="几何习题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-10</div><div class="info-item-2">几何习题</div></div><div class="info-2"><div class="info-item-1">几何习题 二分 ABC181F Silver Woods 题意 有 \(n \le 100\) 个木桩在 \(-100\le y \le100\) 的范围里。你有一个圆，圆的半径你可以选择的。求可以把圆从最左边移动到最右边的最大半径。 思路 首先题目具有单调性：如果一个半径可以移动，那么更小的也可以。如果一个半径不能移动，那么更大的肯定不行。所以我们考虑二分。那给定一个 \(r\) 怎么检查呢。对于两个点\(x,y\)，如果 \(r\) 不能从他们之间通过，那么我们就将这两个点连起来。对于上下界\((y=\pm 100)\) 如果不能这个线和这个点之间穿过去，那么我们就连上他们。我们枚举把所有的点都连线完。如果存在一条由上界连向下界的边，那么这个半径就被 “拦住了”不能通过。如果没有就一定存在一条路径可以通过。所以我们用并查集连接就好了，最后检查一下上下界有没有连起来即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fyind</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fyind"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Fyind" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tarjan0025@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=d0kMY0nN" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来逛逛我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">动态规划入门（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.1.</span> <span class="toc-text">一、什么是动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">例题1、 斐波那契数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98201%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">例题2、01背包问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.</span> <span class="toc-text">二、动态规划的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%98%AF%E5%AF%B9%E7%9A%84"><span class="toc-number">1.3.</span> <span class="toc-text">三、为什么动态规划是对的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E7%A8%8B%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">四、动态规划方程的多样性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">五、空间复杂度优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E4%BA%8C%E7%BA%BF%E6%80%A7dp%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">动态规划入门（二）——线性DP之背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">一、完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">二、分组背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B1%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.1.</span> <span class="toc-text">例1、金明的预算方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B2%E6%8E%92%E5%85%B5%E5%B8%83%E9%98%B5"><span class="toc-number">2.2.2.</span> <span class="toc-text">例2、排兵布阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E4%B8%89%E5%85%B6%E4%BB%96%E7%BA%BF%E6%80%A7dp%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">动态规划入门（三）——其他线性DP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%8C%BA%E9%97%B4%E7%8E%AF%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.1.</span> <span class="toc-text">一、区间&#x2F;环形动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B1%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">例1：石子合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%8E%AF%E6%88%90%E9%93%BE"><span class="toc-number">3.2.</span> <span class="toc-text">断环成链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">二、最长上升子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.1.</span> <span class="toc-text">二分优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">三、最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nlogn%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.1.</span> <span class="toc-text">nlogn优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E5%9B%9Bdag%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.</span> <span class="toc-text">动态规划入门（四）——DAG动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B1%E6%B1%82dag%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF"><span class="toc-number">4.1.</span> <span class="toc-text">例1：求DAG的最长路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%80%9A%E8%BF%87%E8%BD%AC%E6%8D%A2%E6%88%90%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">4.2.</span> <span class="toc-text">一、通过转换成有向无环图解决依赖关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B2%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.1.</span> <span class="toc-text">例2：矩形嵌套问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E4%BB%A5%E6%97%B6%E9%97%B4%E4%B8%BA%E6%8E%A8%E7%A7%BB%E9%A1%BA%E5%BA%8F%E6%9E%84%E9%80%A0%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-number">4.3.</span> <span class="toc-text">二、以时间为推移顺序，构造有向无环图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B3%E6%89%93%E9%BC%B9%E9%BC%A0"><span class="toc-number">4.3.1.</span> <span class="toc-text">例3：打鼹鼠</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%90%86%E8%AE%BA%E4%B8%8A%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%94%A8dag%E7%9A%84%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A7%A3%E9%87%8A"><span class="toc-number">4.4.</span> <span class="toc-text">三、理论上任何一个动态规划都可以用DAG的有向无环图解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.</span> <span class="toc-text">树形动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85dp"><span class="toc-number">5.1.</span> <span class="toc-text">树形背包dp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E8%AF%BE"><span class="toc-number">5.1.1.</span> <span class="toc-text">选课</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%99%E6%B3%95-on3"><span class="toc-number">5.1.2.</span> <span class="toc-text">最简单的写法 \(O(n^3)\)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp"><span class="toc-number">6.</span> <span class="toc-text">状态压缩dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%A1%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">动态规划计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="toc-number">8.</span> <span class="toc-text">数位dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp-1"><span class="toc-number">8.1.</span> <span class="toc-text">数位dp</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程">C++高性能编程</a><time datetime="2025-07-17T19:47:19.000Z" title="Created 2025-07-17 19:47:19">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="操作系统概念">操作系统概念</a><time datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置">Kubuntu配置</a><time datetime="2025-07-15T05:25:37.000Z" title="Created 2025-07-15 05:25:37">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E6%88%91%E4%BB%AC%E5%9C%A8AI%E6%97%B6%E4%BB%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/" title="我们在AI时代该如何学习">我们在AI时代该如何学习</a><time datetime="2025-07-12T23:12:19.000Z" title="Created 2025-07-12 23:12:19">2025-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CA-Top-Down-Approach/" title="计算机网络A Top Down Approach">计算机网络A Top Down Approach</a><time datetime="2025-07-12T22:02:58.000Z" title="Created 2025-07-12 22:02:58">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fyind</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>