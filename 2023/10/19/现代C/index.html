<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>现代C++ | Fyind's Blog</title><meta name="author" content="Fyind"><meta name="copyright" content="Fyind"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="现代c++编程 12345#include &lt;print&gt;int main() &#123;	std::println(&quot;Hello world!&quot;);&#125; 编译 1c++ -std&#x3D;c++23 -Wall -Werror first.cpp -o first 运行 1.&#x2F;first 编译和运行   image-20231019093714449  首先被编">
<meta property="og:type" content="article">
<meta property="og:title" content="现代C++">
<meta property="og:url" content="http://fyind.de/2023/10/19/%E7%8E%B0%E4%BB%A3C/index.html">
<meta property="og:site_name" content="Fyind&#39;s Blog">
<meta property="og:description" content="现代c++编程 12345#include &lt;print&gt;int main() &#123;	std::println(&quot;Hello world!&quot;);&#125; 编译 1c++ -std&#x3D;c++23 -Wall -Werror first.cpp -o first 运行 1.&#x2F;first 编译和运行   image-20231019093714449  首先被编">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://fyind.de/img/pic1.PNG">
<meta property="article:published_time" content="2023-10-19T09:27:15.000Z">
<meta property="article:modified_time" content="2025-07-18T10:49:53.880Z">
<meta property="article:author" content="Fyind">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyind.de/img/pic1.PNG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "现代C++",
  "url": "http://fyind.de/2023/10/19/%E7%8E%B0%E4%BB%A3C/",
  "image": "http://fyind.de/img/pic1.PNG",
  "datePublished": "2023-10-19T09:27:15.000Z",
  "dateModified": "2025-07-18T10:49:53.880Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fyind",
      "url": "http://fyind.de"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pic1.PNG"><link rel="canonical" href="http://fyind.de/2023/10/19/%E7%8E%B0%E4%BB%A3C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '现代C++',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://fyindex.work/PicGo/liuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yae.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Fyind's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">现代C++</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">现代C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-10-19T09:27:15.000Z" title="Created 2023-10-19 09:27:15">2023-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-18T10:49:53.880Z" title="Updated 2025-07-18 10:49:53">2025-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="现代c编程">现代c++编程</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;print&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::<span class="built_in">println</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++ -std=c++23 -Wall -Werror first.cpp -o first</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./first</span><br></pre></td></tr></table></figure>
<h3 id="编译和运行">编译和运行</h3>
<figure>
<img src="https://fyindex.work/PicGo/image-20231019093714449.png"
alt="image-20231019093714449" />
<figcaption aria-hidden="true">image-20231019093714449</figcaption>
</figure>
<p>首先被编译成object code 然后linker会link一些库最后编程可执行文件</p>
<ul>
<li>translation unit: input of compiler</li>
<li>object code is the output of compiler</li>
<li><code>#include</code> is done vis the preprocessor (literally
included = long compilation time)</li>
<li>compiler uses the declaration to know the signature of object, not
resolve external thing</li>
<li>linker check these symbols</li>
</ul>
<h3 id="头文件和源文件">头文件和源文件</h3>
<ul>
<li>declarations in header files</li>
<li>definitions in source files</li>
</ul>
<h3 id="odr">ODR</h3>
<ul>
<li>all object have at most one definition in any translation unit</li>
<li>all object that are used have exactly one definitions</li>
</ul>
<h3 id="head-guards">Head guards</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> H_HEAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H_HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>
<h3 id="modules-doesnt-work-yet">modules (doesn’t work yet)</h3>
<p>定义module</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> sayHello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &lt;print&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::<span class="built_in">println</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sayHello;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cmake">CMake</h3>
<p><code>CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.27</span>)</span><br><span class="line"><span class="keyword">project</span>(exampleProject LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(exampleProject main.cpp)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cmake_minimum_required</code> require at least a version</li>
<li><code>project</code> define a project with name</li>
<li><code>add_executable</code> build executable with name and source
file</li>
<li><code>add_library</code> define a library</li>
<li><code>target_include_directories(myProgram PUBLIC inc)</code> where
to look for include files for the target “myProgram”</li>
<li><code>target_link_libraries(myProgram PUBLIC myLibrary)</code> which
libraries to add to target “myProgram”</li>
</ul>
<h2 id="c-basic">C++ Basic</h2>
<h3 id="types-and-built-in-types">Types and built-in types</h3>
<ul>
<li><p>static type safety</p>
<p>a program that violates type safety will not compile, compiler report
violation</p></li>
<li><p>dynamic type safety</p>
<p>if a program violates type safety it will be detected at
run-time</p></li>
</ul>
<blockquote>
<p>C++ is neither statically nor dynamically type safe!</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE variablename&#123;initializer&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://fyindex.work/PicGo/image-20240219221308510.png"
alt="image-20240219221308510" />
<figcaption aria-hidden="true">image-20240219221308510</figcaption>
</figure>
<p>Integer literal</p>
<ul>
<li>decimal: <code>42</code></li>
<li>octal(base 8): <code>052</code></li>
<li>hex: <code>0x42</code></li>
<li><code>1'000'000'000'000ull</code></li>
</ul>
<p>careful <code>0xffff</code> maybe <code>-1</code> or
<code>65536</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">0xffff</span> &lt;&lt; endl; <span class="comment">// 65536</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::ptrdiff_t</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::<span class="type">size_t</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="type">int</span>* end = a + N;</span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">ptrdiff_t</span> i = N; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    std::cout &lt;&lt; (*(end - i) = i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>double (64bit): approx. 15 digits</p></li>
<li><p>long double (64-128bit): approx. 19 digits
<code>1.0l</code></p></li>
<li><p><code>float128_t</code></p></li>
</ul>
<h3 id="initialization">Initialization</h3>
<p>safe: <code>variableName&#123;&#125;</code></p>
<p>unsafe: <code>variableName =  or variableName()</code></p>
<p>the unsafe version may do (silent) implicit conversions</p>
<p>local variables are usually not default-initialized, this can lead to
undefined behavior when accessing an uninitialized variable</p>
<h4 id="const">const</h4>
<p><code>const T</code></p>
<p>a const object is considered immutable and cannot be modified</p>
<p><code>extern int errorNumber;</code> declare, no definition</p>
<p><code>using Cmplx = std::complex;</code></p>
<p><code>float sqrt(float);</code> declares the function sqrt, taking a
float as argument, returning a float, no definition!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">99</span>&#125;; <span class="comment">// v1 is a vector of 1 element</span></span><br><span class="line"><span class="comment">// with value 99</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">99</span>)</span></span>; <span class="comment">// v2 is a vector of 99 elemen</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; v1&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// v1 is a vector with 1 element with value &quot;hello&quot;</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">v2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// ERROR: no constructor of vector accepts a string literal</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::complex&lt;<span class="type">double</span>&gt; <span class="title">z1</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>; <span class="comment">// uses constructor</span></span><br><span class="line">std::complex&lt;<span class="type">double</span>&gt; z2&#123;&#125;; <span class="comment">// uses constructor,</span></span><br><span class="line"><span class="comment">// default value &#123;0,0&#125;</span></span><br><span class="line"><span class="function">std::complex&lt;<span class="type">double</span>&gt; <span class="title">z3</span><span class="params">()</span></span>; <span class="comment">// function declaration!</span></span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; v1&#123;<span class="number">10</span>, <span class="number">3.3</span>&#125;; <span class="comment">// list constructor</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>, <span class="number">3.3</span>)</span></span>; <span class="comment">// constructor, v has 10 elements set to 3.3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x&#123;&#125;; <span class="comment">// x == 0</span></span><br><span class="line"><span class="type">double</span> d&#123;&#125;; <span class="comment">// d == 0.0</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;&#125;; <span class="comment">// v is the empty vector</span></span><br><span class="line">std::string s&#123;&#125;; <span class="comment">// s == &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="type-alias">Type Alias</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> myNewInt; <span class="comment">// equivalent to using myNewInt = int</span></span><br></pre></td></tr></table></figure>
<h3 id="scope">Scope</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">// global x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123; <span class="comment">// y local to function f1</span></span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// local x that hides global x</span></span><br><span class="line">    x = <span class="number">1</span>; <span class="comment">// assign to local x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x; <span class="comment">// hides the first local x</span></span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// assign to second local x</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = <span class="number">3</span>; <span class="comment">// assign to first local x</span></span><br><span class="line">    y = <span class="number">2</span>; <span class="comment">// assign to local y</span></span><br><span class="line">    ::x = <span class="number">4</span>; <span class="comment">// assign to global x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = x; <span class="comment">// assigns global x to y (also global)</span></span><br></pre></td></tr></table></figure>
<h4 id="lifetime">Lifetime</h4>
<p>The lifetime of an object</p>
<ul>
<li>starts when its constructor completes</li>
<li>ends when its destructor starts executing</li>
</ul>
<p>using an object outside its lifetime leads to undefined behavior!</p>
<p>storage duration: which begins when its memory is allocated and ends
when its memory is deallocated, the lifetime of an object never exceeds
its storage duration</p>
<ul>
<li><p><code>automatic</code> allocated at beginning of scope,
deallocated when it goes out of scope</p></li>
<li><p><code>static</code>: allocated when program starts, lives until
end of program</p></li>
<li><p><code>dynamic</code>: allocation and deallocation is handled
manually (see later) (using <code>new, delete</code>)</p></li>
<li><p><code>thread-local</code> : allocated when thread starts,
deallocated automatically when thread ends; each thread gets its own
copy</p></li>
</ul>
<h3 id="auto">Auto</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;print&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::typeindex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = &#123;<span class="number">13</span>, <span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> u&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;()&#125;;</span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;Type a: &#123;&#125;&quot;</span>, <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(a)&gt;().<span class="built_in">pretty_name</span>());</span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;Type u: &#123;&#125;&quot;</span>, <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(u)&gt;().<span class="built_in">pretty_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array-and-vector">Array and Vector</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;print&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 10&gt; a&#123;&#125;; <span class="comment">// array of 10 int, default initialized</span></span><br><span class="line">    std::array&lt;<span class="type">float</span>, 3&gt; b&#123;<span class="number">0.0</span>, <span class="number">1.1</span>, <span class="number">2.2</span>&#125;; <span class="comment">// array of 3 float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    	a[i] = i + <span class="number">1</span>; <span class="comment">// no bounds checking</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : b) <span class="comment">// loop over all elements of b</span></span><br><span class="line">    	std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">at</span>(<span class="number">11</span>) = <span class="number">5</span>; <span class="comment">// run-time error: out_of_range exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Do not use:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">float</span> b[<span class="number">3</span>] = &#123;<span class="number">0.0</span>, <span class="number">1.1</span>, <span class="number">2.2</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Not-fixed size array: vector</p>
<h3 id="loop">Loop</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;print&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// initializer list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) <span class="comment">// regular for loop</span></span><br><span class="line">    	a.<span class="built_in">push_back</span>(i + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : a) <span class="comment">// range for loop</span></span><br><span class="line">    	std::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, e);</span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : &#123;<span class="number">47</span>, <span class="number">11</span>, <span class="number">3</span>&#125;) <span class="comment">// range for loop</span></span><br><span class="line">    	std::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lvalue-and-rvalue">lvalue and rvalue</h3>
<h4 id="lvalue">lvalue</h4>
<ul>
<li>lvalues that refer to the identity of an object, modifiable lvalues
can be used on left-hand side of assignment</li>
</ul>
<h4 id="rvalue">rvalue</h4>
<ul>
<li>rvalues that refer to the value of an object, lvalues and rvalues
can be used on right-hand side of assignment</li>
</ul>
<h3 id="increment">Increment</h3>
<ul>
<li>prefix variants increment/decrement the value of an object and
return a reference to the result</li>
<li>postfix variants create a copy of an object, increment/decrement the
value of the original object, and return the unchanged copy</li>
</ul>
<h3 id="precedence">Precedence</h3>
<ul>
<li><p>operators with higher precedence bind tighter than operators with
lower precedence</p></li>
<li><p>operators with equal precedence are bound in the direction of
their associativity</p></li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20240219230615694.png"
alt="image-20240219230615694" />
<figcaption aria-hidden="true">image-20240219230615694</figcaption>
</figure>
<figure>
<img src="https://fyindex.work/PicGo/image-20240219230723228.png"
alt="image-20240219230723228" />
<figcaption aria-hidden="true">image-20240219230723228</figcaption>
</figure>
<figure>
<img src="https://fyindex.work/PicGo/image-20240219230733643.png"
alt="image-20240219230733643" />
<figcaption aria-hidden="true">image-20240219230733643</figcaption>
</figure>
<h3 id="if-switch">if, switch</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> value&#123;<span class="built_in">computeValue</span>()&#125;; value &lt; <span class="number">42</span>) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">computeValue</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">        <span class="comment">// do something if computeValue() was 21</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">42</span>:</span><br><span class="line">        <span class="comment">// do something if computeValue() was 42</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something if computeValue() was != 21 and != 42</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="reference">Reference</h3>
<ul>
<li>LReference <code>&amp;declarator</code></li>
<li>RReference <code>&amp;&amp;declarator</code></li>
</ul>
<p>Refences are special</p>
<ul>
<li>there are no references to void</li>
<li>references are immutable (although the referenced object can be
mutable)</li>
<li>references are not objects, i.e. they do not necessarily occupy
storage</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;m&#123;i&#125;; <span class="comment">// valid</span></span><br><span class="line"><span class="type">int</span>&amp; n&#123;i&#125;; <span class="comment">// also valid, by convention</span></span><br></pre></td></tr></table></figure>
<ul>
<li>a reference to type T must be initialized to refer to a valid
object</li>
</ul>
<p>​ there are exceptions:function parameter declarations,function return
type declarations,when using extern modifier</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global0&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> global1&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="type">unsigned</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!which)</span><br><span class="line">    	<span class="keyword">return</span> global0;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> global1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>) = <span class="number">42</span>; <span class="comment">// global0 == 42</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>) = <span class="number">14</span>; <span class="comment">// global1 == 14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Rvalue references cannot (directly) bind to lvalues:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span>&amp;&amp; j&#123;i&#125;; <span class="comment">// ERROR: cannot bind rvalue ref to lvalue</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; k&#123;<span class="number">42</span>&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>Rvalue references can extend the lifetime of temporary objects:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> j&#123;<span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; k&#123;i + j&#125;; <span class="comment">// k == 42</span></span><br><span class="line">k += <span class="number">42</span>; <span class="comment">// k == 84</span></span><br></pre></td></tr></table></figure>
<p>Overload resolution (see later) allows to distinguish between lvalues
and rvalues:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> j&#123;<span class="number">84</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(i); <span class="comment">// calls foo(int&amp;)</span></span><br><span class="line">    <span class="built_in">foo</span>(j); <span class="comment">// calls foo(const int&amp;)</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">123</span>); <span class="comment">// calls foo(int&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">bar</span>()); <span class="comment">// calls foo(int&amp;)</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">baz</span>()); <span class="comment">// calls foo(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>references themselves cannot be const, however, the reference type
can be const</p>
<h4 id="dangling-references">Dangling references</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">// MISTAKE: returns dangling reference!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="converting">Converting</h3>
<p>static cast:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>
<ul>
<li>new_type must have same const-ness as the type of expression</li>
</ul>
<p>Do not use: (<code>const_cast</code>, <code>reinterpret_cast</code>,
C-style cast: (new_type) expression)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="type">double</span> b&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x&#123;<span class="built_in">sum</span>(a, b)&#125;; <span class="comment">// ERROR: ambiguous</span></span><br><span class="line">    <span class="type">double</span> y&#123;<span class="built_in">sum</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a), b)&#125;; <span class="comment">// OK</span></span><br><span class="line">    <span class="type">int</span> z&#123;<span class="built_in">sum</span>(a, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(b))&#125;; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="function">Function</h2>
<p>C++ also allows a trailing return type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> -&gt; <span class="type">int</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> U&amp; y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Return multiple</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">17</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="structured-binding">Structured Binding</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap; <span class="comment">// map with strings as keys</span></span><br><span class="line"><span class="comment">// ... fill the map ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate over the container using range-for loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : myMap)</span><br><span class="line">std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br></pre></td></tr></table></figure>
<p>you can also bind struct members or std::array entries:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">myStruct</span> &#123; <span class="type">int</span> a&#123;<span class="number">1</span>&#125;; <span class="type">int</span> b&#123;<span class="number">2</span>&#125;; &#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = myStruct&#123;&#125;; <span class="comment">// x, y are int, x == 1, y == 2</span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; myArray&#123;<span class="number">47</span>, <span class="number">11</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [i, j, k] = myArray; <span class="comment">// i == 47, j == 11, k == 9</span></span><br></pre></td></tr></table></figure>
<p>specifying the return type for multiple values can be annoying:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="parameter-passing">Parameter passing</h3>
<ul>
<li>in parameter</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span>; <span class="comment">// OK, pass by const reference</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(std::string s)</span></span>; <span class="comment">// potentially expensive</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">// OK, cheap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>; <span class="comment">// not good, unnecessary overhead</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>in-out</code> parameter</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Record&amp; r)</span></span>; <span class="comment">// assume that update writes to r</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>out</code> parameter</p>
<p>return them</p></li>
</ul>
<h3 id="overloading">Overloading</h3>
<p>the compiler automatically resolves the overloads in the current
scope and calls the best match</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// a function called f, taking an int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">// another function f, taking a double</span></span><br></pre></td></tr></table></figure>
<h4 id="criteria">Criteria</h4>
<ul>
<li>exact match. no or only trivial conversions, e.g. T to const T)</li>
<li>match using promotions (e.g. bool to int, char to int, or float to
double)</li>
<li>match using standard conversions (e.g. int to double, double to int,
or int to unsigned int)</li>
<li>match using user-defined conversions</li>
<li>match using ellipsis</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i, <span class="type">short</span> s, <span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(c); <span class="comment">// exact match: print(char)</span></span><br><span class="line">    <span class="built_in">print</span>(i); <span class="comment">// exact match: print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(s); <span class="comment">// integral promotion: print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(f); <span class="comment">// float to double promotion: print(double)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// exact match: print(char)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">49</span>); <span class="comment">// exact match: print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>); <span class="comment">// exact match: print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0L</span>); <span class="comment">// exact match: print(long)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> complex = std::complex&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function">complex <span class="title">pow</span><span class="params">(<span class="type">double</span>, complex)</span></span>;</span><br><span class="line"><span class="function">complex <span class="title">pow</span><span class="params">(complex, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">complex <span class="title">pow</span><span class="params">(complex, complex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(complex z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// invokes pow(int, int)</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">2.0</span>); <span class="comment">// invokes pow(double, double)</span></span><br><span class="line">    <span class="keyword">auto</span> z2 = <span class="built_in">pow</span>(<span class="number">2</span>, z); <span class="comment">// invokes pow(double, complex)</span></span><br><span class="line">    <span class="keyword">auto</span> z3 = <span class="built_in">pow</span>(z, <span class="number">2</span>); <span class="comment">// invokes pow(complex, int)</span></span><br><span class="line">    <span class="keyword">auto</span> z4 = <span class="built_in">pow</span>(z, z); <span class="comment">// invokes pow(complex, complex)</span></span><br><span class="line">    <span class="keyword">auto</span> e = <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">2</span>); <span class="comment">// ERROR: ambiguous</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="functors">Functors</h3>
<p>Functions are not objects in C++</p>
<ul>
<li>they cannot be passed as parameters</li>
<li>they cannot have state</li>
</ul>
<p>However, a type T can be a function object (or functor), if:</p>
<ul>
<li>T is an object</li>
<li>T defines <code>operator()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">	<span class="type">int</span> value&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Adder adder;</span><br><span class="line">    <span class="built_in">adder</span>(<span class="number">1</span>); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::function</code> is a wrapper for all callable targets</p>
<p>caution: can incur a slight overhead in both performance and
memory</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addFunc</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function adder&#123;addFunc&#125;;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="built_in">adder</span>(<span class="number">5</span>)&#125;; <span class="comment">// a == 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// alternatively specifying the function type:</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; adder2&#123;addFunc&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>other example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrintNum</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// store a function</span></span><br><span class="line">    std::function f_printNum&#123;printNum&#125;;</span><br><span class="line">    <span class="built_in">f_printNum</span>(<span class="number">-47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the functor</span></span><br><span class="line">    std::function f_PrintNum&#123;PrintNum&#123;&#125;&#125;;</span><br><span class="line">    <span class="built_in">f_PrintNum</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fix the function parameter using std::bind</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f_leet&#123;std::<span class="built_in">bind</span>(printNum, <span class="number">31337</span>)&#125;;</span><br><span class="line">    <span class="built_in">f_leet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lambda">Lambda</h3>
<p>Lambda expressions are a simplified notation for anonymous function
objects</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">find_if</span>(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>(),</span><br><span class="line">	[](<span class="type">int</span> val) &#123; <span class="keyword">return</span> <span class="number">1</span> &lt; val &amp;&amp; val &lt; <span class="number">10</span>; &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>the function object created by the lambda expression is called
closure</li>
<li>the closure can hold copies or references of captured variables</li>
</ul>
<p><code>[ capture_list ] ( param_list ) -&gt; return_type &#123; body &#125;</code></p>
<ul>
<li><p>capture_list specifies the variables of the environment to be
captured in the closure</p></li>
<li><p>return_type specifies the return type; it is optional!</p></li>
<li><p>if the param_list is empty, it can be omitted</p></li>
</ul>
<h4 id="storing-lambda">Storing lambda</h4>
<p>Lambda expressions can be stored in variables:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::function func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func2 = </span><br><span class="line">    [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">lambda</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// outputs 5	</span></span><br></pre></td></tr></table></figure>
<ul>
<li>the type of a lambda expression is not defined, no two lambdas have
the same type (even if they are identical otherwise)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myFunc</span><span class="params">(<span class="type">bool</span> first)</span> </span>&#123; <span class="comment">// ERROR: ambiguous return type</span></span><br><span class="line">    <span class="keyword">if</span> (first)</span><br><span class="line">    	<span class="keyword">return</span> []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="capture">Capture</h4>
<ul>
<li>all capture: by copy <code>=</code>, by reference
<code>&amp;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [i]() &#123; <span class="keyword">return</span> i + <span class="number">42</span>; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;i]() &#123; <span class="keyword">return</span> i + <span class="number">42</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">lambda1</span>(); <span class="comment">// a == 84</span></span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">lambda2</span>(); <span class="comment">// b == 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exception">Exception</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">42</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;What is the meaning of life?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>when an exception is thrown, C++ performs stack unwinding</li>
</ul>
<p>​ ensures proper clean up of objects with automatic storage
duration</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="built_in">foo</span>(<span class="number">42</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">int</span> i) &#123;</span><br><span class="line">    	<span class="comment">/* handle the exception somehow */</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    	std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    	<span class="comment">/* handle the exception somehow */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="no-except">No except</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// may not throw an exception</span></span><br></pre></td></tr></table></figure>
<ul>
<li>exceptions should be used rarely, main use case: establishing class
invariants</li>
<li>exceptions should not be used for control flow!</li>
<li>some functions must not throw exceptions,
<ul>
<li>destructors,move constructors and assignment operators</li>
</ul></li>
</ul>
<h4 id="expected">expected</h4>
<p><code>std::expected&lt;T,E&gt;</code> stores either a value of type T
or an error of type E</p>
<ul>
<li><p><code>has_value()</code> checks if the expected value is
there</p></li>
<li><p><code>value()</code> or <code>*</code> accesses the expected
value</p></li>
<li><p><code>error()</code> returns the unexpected value</p></li>
<li><p>monadic operations are also supported, such as
<code>and_then()</code> or <code>or_else()</code></p></li>
<li><p>performance guarantee: no dynamic memory allocation takes
place</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">parse_error</span> &#123; invalid_input &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">parse_number</span><span class="params">(std::string_view str)</span> -&gt; std::expected&lt;<span class="type">double</span>, parse_error&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">    	<span class="keyword">return</span> std::<span class="built_in">unexpected</span>(parse_error::invalid_input);</span><br><span class="line">    <span class="comment">// do actual parsing ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> process = [](std::string_view str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> num = <span class="built_in">parse_number</span>(str); num.<span class="built_in">has_value</span>())</span><br><span class="line">        	std::<span class="built_in">println</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, *num);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num.<span class="built_in">error</span>() == parse_error::invalid_input)</span><br><span class="line">        	std::<span class="built_in">println</span>(<span class="string">&quot;error: invalid input&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : &#123;<span class="string">&quot;42&quot;</span>, <span class="string">&quot;&quot;</span>&#125;)</span><br><span class="line">    	<span class="built_in">process</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::expected</code> is well suited for more regular errors,
such as errors in parsing</li>
<li>exception handling is well suited for the rare failures you cannot
do much about at the called function (e.g. out of memory)</li>
</ul>
<h2 id="stl">STL</h2>
<h3 id="optional">optional</h3>
<p>encapsulates a value that might or might not exist</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">mightFail</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> std::<span class="built_in">optional</span>&lt;std::string&gt;(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;one&quot;</span>; <span class="comment">// equivalent to the case above</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arg &lt; <span class="number">7</span>)</span><br><span class="line">    	<span class="keyword">return</span> std::<span class="built_in">make_optional</span>&lt;std::string&gt;(<span class="string">&quot;less than 7&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// alternatively: return &#123;&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mightFail</span>(<span class="number">3</span>).<span class="built_in">value</span>(); <span class="comment">// &quot;less than 7&quot;</span></span><br><span class="line"><span class="built_in">mightFail</span>(<span class="number">8</span>).<span class="built_in">value</span>(); <span class="comment">// throws std::bad_optional_access</span></span><br><span class="line"></span><br><span class="line">*<span class="built_in">mightFail</span>(<span class="number">3</span>); <span class="comment">// &quot;less than 7&quot;</span></span><br><span class="line"><span class="built_in">mightFail</span>(<span class="number">6</span>)-&gt;<span class="built_in">size</span>(); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">mightFail</span>(<span class="number">7</span>)-&gt;<span class="built_in">empty</span>(); <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure>
<p>check value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mightFail</span>(<span class="number">3</span>).<span class="built_in">has_value</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">mightFail</span>(<span class="number">8</span>).<span class="built_in">has_value</span>(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> opt5 = <span class="built_in">mightFail</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (opt5) <span class="comment">// contextual conversion to bool</span></span><br><span class="line">opt5-&gt;<span class="built_in">size</span>(); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>default</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mightFail</span>(<span class="number">42</span>).<span class="built_in">value_or</span>(<span class="string">&quot;default&quot;</span>); <span class="comment">// &quot;default&quot;</span></span><br></pre></td></tr></table></figure>
<p>reset</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> opt6 = <span class="built_in">mightFail</span>(<span class="number">6</span>);</span><br><span class="line">opt<span class="number">6.</span><span class="built_in">has_value</span>(); <span class="comment">// true</span></span><br><span class="line">opt<span class="number">6.</span><span class="built_in">reset</span>(); <span class="comment">// clears the value</span></span><br><span class="line">opt<span class="number">6.</span><span class="built_in">has_value</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="monadic-operations">monadic operations</h3>
<ul>
<li><code>and_then</code> : if optional has value, returns result of
provided function applied to the value, else empty optional</li>
<li><code>or_else</code> : if optional has value, return optional
itself, otherwise result of provided function</li>
<li><code>transform</code> if optional has value, return optional with
transformed value, else empty optional</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> o = <span class="built_in">foo</span>().<span class="built_in">or_else</span>([]&#123; <span class="keyword">return</span> std::optional&#123;<span class="number">0</span>&#125;; &#125;)</span><br><span class="line">        .<span class="built_in">and_then</span>([](<span class="type">int</span> n) -&gt; std::optional&lt;<span class="type">int</span>&gt; &#123; <span class="keyword">return</span> n<span class="number">+1</span>; &#125;)</span><br><span class="line">        .<span class="built_in">transform</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n*<span class="number">2</span>; &#125;)</span><br><span class="line">        .<span class="built_in">value_or</span>(<span class="number">-1337</span>);</span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pair">Pair</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">123</span>, <span class="number">4.56</span>)</span></span>;</span><br><span class="line">p<span class="number">1.f</span>irst; <span class="comment">// == 123</span></span><br><span class="line">p<span class="number">1.</span>second; <span class="comment">// == 4.56</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p2 = std::<span class="built_in">make_pair</span>(<span class="number">456</span>, <span class="number">1.23</span>);</span><br></pre></td></tr></table></figure>
<h4 id="structure-binding">structure binding</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = std::<span class="built_in">make_tuple</span>(<span class="number">123</span>, <span class="number">4.56</span>);</span><br><span class="line"><span class="keyword">auto</span> [a, b] = t; <span class="comment">// a is type int, b is type double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">auto</span>&amp; [x, y] = p; <span class="comment">// x, y have type int&amp;</span></span><br><span class="line">x = <span class="number">123</span>; <span class="comment">// p.first is now 123</span></span><br></pre></td></tr></table></figure>
<h3 id="variant">variant</h3>
<p>to store different alternative types in one object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>&gt; v;</span><br><span class="line">v = <span class="number">42</span>; <span class="comment">// v con	tains int</span></span><br><span class="line"><span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v); <span class="comment">// i is 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(v); <span class="comment">// v contains int, not float; will throw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">	std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v = <span class="number">1.0f</span>;</span><br><span class="line"><span class="built_in">assert</span>(std::<span class="built_in">holds_alternative</span>&lt;<span class="type">float</span>&gt;(v)); <span class="comment">// succeeds</span></span><br><span class="line"><span class="built_in">assert</span>(std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(v)); <span class="comment">// fails</span></span><br></pre></td></tr></table></figure>
<p>apply different</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SampleVisitor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;int: &#123;&#125;&quot;</span>, i); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">float</span> f)</span> </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;float: &#123;&#125;&quot;</span>, f); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;string: &#123;&#125;&quot;</span>, s); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; v;</span><br><span class="line">    v = <span class="number">1.0f</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(SampleVisitor&#123;&#125;, v);</span><br><span class="line">    v = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(SampleVisitor&#123;&#125;, v); </span><br><span class="line">    v = <span class="number">7</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(SampleVisitor&#123;&#125;, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>without struct, with overload pattern</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">overload</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; v&#123;<span class="string">&quot;Goodbye&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>( overload&#123;</span><br><span class="line">        [](<span class="type">int</span> i) &#123; std::<span class="built_in">println</span>(<span class="string">&quot;int: &#123;&#125;&quot;</span>, i); &#125;,</span><br><span class="line">        [](<span class="type">float</span> f) &#123; std::<span class="built_in">println</span>(<span class="string">&quot;float: &#123;&#125;&quot;</span>, f); &#125;,</span><br><span class="line">        [](<span class="type">const</span> std::string&amp; s) &#123; std::<span class="built_in">println</span>(<span class="string">&quot;string: &#123;&#125;&quot;</span>, s); &#125;</span><br><span class="line">    &#125;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string">String</h3>
<p><code>std::string</code> encapsulates character sequences</p>
<ul>
<li>manages its own memory (RAII)</li>
<li>guaranteed contiguous memory storage</li>
<li>since C++20, it has constexpr constructors</li>
</ul>
<p>alias for <code>std::basic_string&lt;char&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s&#123;<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; s.<span class="built_in">at</span>(<span class="number">4</span>) &lt;&lt; s[<span class="number">6</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints &quot;oW&quot;</span></span><br></pre></td></tr></table></figure>
<p>at() is bounds checked, [] is not, both return a reference</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">at</span>(<span class="number">4</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">s[<span class="number">6</span>] = <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints &quot;Hellx Yorld!&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>append()</code> and +=: appends another string or
character</li>
<li><code>+</code> concatenates strings</li>
<li><code>find</code> returns offset of the first occurrence of the
substring, or the constant <code>std::string::npos</code> if not
found</li>
</ul>
<h4 id="string-view">string view</h4>
<p>provides a read-only view on already existing strings</p>
<ul>
<li><code>substr()</code> creates another string view in <span
class="math inline">\(O(1)\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::string s&#123;<span class="string">&quot;garbage garbage garbage interesting garbage&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::string sub = s.<span class="built_in">substr</span>(<span class="number">24</span>, <span class="number">11</span>); <span class="comment">// with string: O(n)</span></span><br><span class="line"></span><br><span class="line">std::string_view s_view&#123;s&#125;; <span class="comment">// with string_view: O(1)</span></span><br><span class="line">std::string_view sub_view = s_view.<span class="built_in">substr</span>(<span class="number">24</span>, <span class="number">11</span>); <span class="comment">// O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in place operations:</span></span><br><span class="line">s_view.<span class="built_in">remove_prefix</span>(<span class="number">24</span>); <span class="comment">// O(1)</span></span><br><span class="line">s_view.<span class="built_in">remove_suffix</span>(s_view.<span class="built_in">size</span>() - <span class="number">11</span>); <span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
<p>in fuction</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useful for function calls</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqNaive</span><span class="params">(std::string a, std::string b)</span> </span>&#123; <span class="keyword">return</span> a == b; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqWithViews</span><span class="params">(std::string_view a, std::string_view b)</span> </span>&#123; <span class="keyword">return</span> a == b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">isEqNaive</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>); <span class="comment">// 2 allocations at runtime</span></span><br><span class="line"><span class="built_in">isEqWithViews</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>); <span class="comment">// no allocation at runtime</span></span><br></pre></td></tr></table></figure>
<h3 id="container">Container</h3>
<h4 id="vector">Vector</h4>
<p>emplace bace</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpensiveToCopy</span> &#123;</span><br><span class="line">    <span class="built_in">ExpensiveToCopy</span>(<span class="type">int</span> id, std::string comment)</span><br><span class="line">        : id_&#123;id&#125;, comment_&#123;comment&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> id_;</span><br><span class="line">    std::string comment_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;ExpensiveToCopy&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expensive</span></span><br><span class="line"><span class="function">ExpensiveToCopy <span class="title">e1</span><span class="params">(, <span class="string">&quot;my comment 1&quot;</span>)</span></span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(e1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// beter</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(e1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">2</span>, <span class="string">&quot;my comment 2&quot;</span>);</span><br><span class="line"><span class="comment">// also works at any other position:</span></span><br><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); ++it;</span><br><span class="line">vec.<span class="built_in">emplace</span>(it, <span class="number">3</span>, <span class="string">&quot;my comment 3&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>reserve</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">1000000</span>); <span class="comment">// allocate space for 1000000 elements</span></span><br><span class="line">vec.<span class="built_in">capacity</span>(); <span class="comment">// == 1000000</span></span><br><span class="line">vec.<span class="built_in">size</span>(); <span class="comment">// == 0 (no elements stored yet!)</span></span><br></pre></td></tr></table></figure>
<p>fit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// only needed a capacity of 10, free the space for the rest</span></span><br><span class="line">vec.<span class="built_in">shrink_to_fit</span>();</span><br></pre></td></tr></table></figure>
<h4 id="other">Other</h4>
<ul>
<li><code>std::array</code> for compile-time fixed-size arrays</li>
<li><code>std::deque</code> is a double-ended queue</li>
<li><code>std::list</code> is a doubly-linked list</li>
<li><code>std::forward_list</code> is a singly-linked list</li>
<li><code>std::queue</code> provides the typical queue interface,
wrapping one of the sequence containers with appropriate functions</li>
<li><code>std::stack</code> provides the typical stack interface,
wrapping one of the sequence containers with appropriate functions
(deque, vector, list)</li>
<li><code>std::priority_queue</code> provides a typical priority
interface, wrapping one of the sequence containers with random access
(vector, deque)</li>
</ul>
<h4 id="unordered_map">unordered_map</h4>
<p>unordered maps are associative containers of key-value pairs, keys
are required to be unique</p>
<p>is internally a hash table</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">double</span>&gt; nameToGrade &#123;&#123;<span class="string">&quot;maier&quot;</span>, <span class="number">1.3</span>&#125;, &#123;<span class="string">&quot;huber&quot;</span>, <span class="number">2.7</span>&#125;, &#123;<span class="string">&quot;lasser&quot;</span>, <span class="number">5.0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>search</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> search = nameToGrade.<span class="built_in">find</span>(<span class="string">&quot;maier&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (search != nameToGrade.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// returns an iterator pointing to a pair</span></span><br><span class="line">    search-&gt;first; <span class="comment">// == &quot;maier&quot;</span></span><br><span class="line">    search-&gt;second; <span class="comment">// == 1.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>check exist</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameToGrade.<span class="built_in">count</span>(<span class="string">&quot;blafasel&quot;</span>); <span class="comment">// == 0	</span></span><br><span class="line">nameToGrade.<span class="built_in">contains</span>(<span class="string">&quot;blafasel&quot;</span>); <span class="comment">// == false (since C++20)</span></span><br></pre></td></tr></table></figure>
<p>emplace</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(<span class="string">&quot;mueller&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">nameToGrade.<span class="built_in">insert</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or simpler:</span></span><br><span class="line">nameToGrade.<span class="built_in">insert</span>(&#123;<span class="string">&quot;mustermann&quot;</span>, <span class="number">4.0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or emplace:</span></span><br><span class="line">nameToGrade.<span class="built_in">emplace</span>(<span class="string">&quot;gruber&quot;</span>, <span class="number">1.7</span>);</span><br></pre></td></tr></table></figure>
<p>remove</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> search = nameToGrade.<span class="built_in">find</span>(<span class="string">&quot;lasser&quot;</span>);</span><br><span class="line">nameToGrade.<span class="built_in">erase</span>(search); <span class="comment">// remove pair with &quot;lasser&quot; as key</span></span><br><span class="line"></span><br><span class="line">nameToGrade.<span class="built_in">clear</span>(); <span class="comment">// removes all elements</span></span><br></pre></td></tr></table></figure>
<h4 id="map">map</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; xToY &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">9</span>&#125;, &#123;<span class="number">7</span>, <span class="number">49</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// returns an iterator to first greater element:</span></span><br><span class="line"><span class="keyword">auto</span> gt3 = xToY.<span class="built_in">upper_bound</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (gt3 != xToY.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; gt3-&gt;first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; gt3-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 7-&gt;49</span></span><br><span class="line">    ++gt3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns iterator to first element not lower</span></span><br><span class="line"><span class="keyword">auto</span> geq3 = xToY.<span class="built_in">lower_bound</span>(<span class="number">3</span>); <span class="comment">// 3-&gt;9 , 7-&gt;49</span></span><br></pre></td></tr></table></figure>
<h4 id="unordered-set">unordered set</h4>
<ul>
<li>elements must not be modified! If an element’s hash changes, the
container might become corrupted</li>
</ul>
<h4 id="thread-safety">Thread safety</h4>
<ul>
<li>two different containers do not share state, i.e. all member
functions can be called concurrently by different threads</li>
<li>all const member functions can be called concurrently.</li>
<li>iterator operations that only read (e.g. incrementing or
dereferencing an iterator) can be run concurrently with reads of other
iterators and const member functions</li>
<li>different elements of the same container can be modified
concurrently</li>
</ul>
<p>rule of thumb: simultaneous reads on the same container are always
OK, simultaneous read/writes on different containers are also OK.
Everything else requires synchronization!</p>
<h4 id="iterator">Iterator</h4>
<p>different element access method for each container, i.e. container
types not easily exchangeable in code</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*end; <span class="comment">// undefined behavior!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>range-for loop can also be used to iterate over a container; it
requires the range expression to have a begin() and end() iterator</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec)</span><br><span class="line">	std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="comment">// prints &quot;one,two,three,four,&quot;</span></span><br></pre></td></tr></table></figure>
<p>Dynamic</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        it = vec.<span class="built_in">insert</span>(it, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="comment">// it now points to the newly inserted element</span></span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vec == &#123;&quot;foo&quot;, &quot;one&quot;, &quot;foo&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">// erase returns a new, valid iterator</span></span><br><span class="line">        <span class="comment">// pointing to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vec == &#123;&quot;three&quot;, &quot;four&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InputIterator and OutputIterator are the most basic iterators
<ul>
<li>equality comparison: checks if two iterators point to the same
position</li>
<li>a dereferenced InputIterator can only be read</li>
<li>a dereferenced OutputIterator can only be written to</li>
</ul></li>
<li>ForwardIterator combines InputIterator and OutputIterator</li>
<li>BidirectionalIterator generalizes ForwardIterator</li>
<li>RandomAccessIterator generalizes BidirectionalIterator
<ul>
<li>additionally supports random access with
<code>operator[]</code></li>
</ul></li>
<li>ContiguousIterator guarantees that elements are stored in memory
contiguously
<ul>
<li>extends RandomAccessIterator</li>
</ul></li>
</ul>
<h3 id="ranges">Ranges</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> results = numbers</span><br><span class="line">        | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">        | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: results)</span><br><span class="line">    	std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// outputs: 4 8 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>a range is anything that can be iterated over</li>
<li>i.e. it has to provide a begin() iterator and an end() sentinel</li>
<li>a view is something that you apply to a range and which performs
some operation
<ul>
<li>a view does not own data</li>
<li>time complexity to copy/move/assign is constant</li>
<li>can be composed using the pipe symbol <code>|</code></li>
<li>views are lazily evaluated</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="comment">// not very efficient, but simple!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j*j &lt;= i; ++j) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (i % j == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;20 prime numbers starting with 1&#x27;000&#x27;000:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : std::views::<span class="built_in">iota</span>(<span class="number">1&#x27;000&#x27;000</span>)</span><br><span class="line">                | std::views::<span class="built_in">filter</span>(isPrime)</span><br><span class="line">                | std::views::<span class="built_in">take</span>(<span class="number">20</span>) ) &#123;</span><br><span class="line">    	std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="algorithm">Algorithm</h3>
<ul>
<li>sort</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span>&gt; v &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">unsigned</span> lhs, <span class="type">unsigned</span> rhs) &#123;</span><br><span class="line">    	<span class="keyword">return</span> lhs &gt; rhs;</span><br><span class="line">    &#125;); <span class="comment">// 4, 3, 2, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::stable_sort</code></li>
<li>partially sorting a range: <code>std::partial_sort</code></li>
<li>check if a range is sorted: <code>std::is_sorted</code>,
<code>std::is_sorted_until</code></li>
</ul>
<h4 id="searching">Searching</h4>
<h5 id="unsorted">unsorted:</h5>
<p>find the first elements satisfying some criteria:</p>
<ul>
<li><code>std::find</code></li>
<li><code>std::find_if</code></li>
<li><code>std::find_if_not</code></li>
</ul>
<p>search for a range</p>
<ul>
<li><code>std::search</code></li>
</ul>
<p>count match</p>
<ul>
<li><code>std::count</code></li>
<li><code>std::count_if</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res1 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line">    <span class="type">int</span> a = std::<span class="built_in">distance</span>(vec.<span class="built_in">begin</span>(), res1); <span class="comment">// == 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res2 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">assert</span>(res2 == vec.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="sorted">sorted</h5>
<ul>
<li><p><code>std::binary_search</code></p>
<p>lookup an element in sorted range [first, last), only checks for
containment, therefore return type is bool</p></li>
<li><p><code>std::lower_bound</code></p>
<p>returns iterator pointing to the first element &gt;= the search
value</p></li>
<li><p><code>std::upper_bound</code></p>
<p>returns iterator pointing to first element &gt; the search
value</p></li>
<li><p><code>std::equal_range</code></p>
<p>returns pair of iterators (begin and end of range)</p></li>
</ul>
<h4 id="permutation">Permutation</h4>
<p>initialize a dense range of elements:</p>
<ul>
<li><code>std::iota</code></li>
</ul>
<p>iterate over permutations in lexicographical order</p>
<ul>
<li><code>std::next_permutation</code></li>
<li><code>std::prev_permutation</code></li>
</ul>
<p>iota fills the range [first, last) with increasing values, starting
at value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> heapArray = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>);</span><br><span class="line">    std::<span class="built_in">iota</span>(heapArray.<span class="built_in">get</span>(), heapArray.<span class="built_in">get</span>() + <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heapArray is now &#123;2, 3, 4, 5, 6&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="more-feature">More feature</h4>
<ul>
<li><code>std::min</code> and <code>std::max</code> over a range instead
of two elements</li>
<li><code>std::merge</code> and<code>std::in_place_merge</code> for
merging of sorted ranges</li>
<li>multiple set operations (intersection, union, difference, …)</li>
<li>heap functionality using <code>std::make_heap</code>,
<code>std::push_heap</code>, <code>std::pop_heap</code></li>
<li>sampling of elements using <code>std::sample</code></li>
<li>swapping elements using <code>std::swap</code></li>
<li>range modifications:
<ul>
<li><code>std::copy</code> to copy elements to a new location</li>
<li><code>std::rotate</code> to rotate a range</li>
<li><code>std::shuffle</code> to randomly reorder elements</li>
</ul></li>
</ul>
<h3 id="stream-and-io">Stream and IO</h3>
<p><code>std::istream</code> is the base class for input operations,
alias for <code>std::basic_istream&lt;char&gt;</code></p>
<p><code>std::ostream</code> is the base class for output
operations,</p>
<ul>
<li><p><code>good(), fail(), bad()</code>: checks if the stream is in a
specific error state</p></li>
<li><p><code>eof()</code>: checks if the stream has reached
end-of-file</p></li>
<li><p>operator bool(): returns true if stream has no errors</p></li>
</ul>
<h4 id="input-stream">input stream</h4>
<p><code>get()</code>: reads single or multiple characters until a
delimiter is found</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defined by the standard library:</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp;, <span class="type">int</span>&amp;);</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">std::cin &gt;&gt; value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read (up to) 1024 chars from cin:</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line">std::cin.<span class="built_in">read</span>(buffer.<span class="built_in">data</span>(), <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<h4 id="output-stream">output stream</h4>
<p><code>put()</code>: writes a single character</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defined by the standard library:</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp;, <span class="type">int</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write 1024 characters to cout:</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line">std::cout.<span class="built_in">write</span>(buffer.<span class="built_in">data</span>(), <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<h4 id="stringstream">stringstream</h4>
<p><code>std::stringstream</code> can be used when input and output
should be read and written from a std::string</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::stringstream <span class="title">stream</span><span class="params">(<span class="string">&quot;1 2 3&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">stream &gt;&gt; value; <span class="comment">// value == 1</span></span><br><span class="line"></span><br><span class="line">stream.<span class="built_in">str</span>(<span class="string">&quot;4&quot;</span>); <span class="comment">// set stream contents to &quot;4&quot;</span></span><br><span class="line">stream &gt;&gt; value; <span class="comment">// value == 4</span></span><br><span class="line"></span><br><span class="line">stream &lt;&lt; <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">stream &lt;&lt; <span class="number">123</span>;</span><br><span class="line">stream.<span class="built_in">str</span>(); <span class="comment">// == &quot;foo123&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="filestream">filestream</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;input_file&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!input)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;couldn&#x27;t open input_file\n&quot;</span>;</span><br><span class="line"><span class="function">std::ofstream <span class="title">output</span><span class="params">(<span class="string">&quot;output_file&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!output)</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;couldn&#x27;t open output_file\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read an int from input_file and write it to output_file</span></span><br><span class="line"><span class="type">int</span> value&#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (!(input &gt;&gt; value))</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;couldn&#x27;t read from file\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!(output &lt;&lt; value))</span><br><span class="line">	std::cout &lt;&lt; couldn<span class="string">&#x27;t write to file\n&quot;;</span></span><br></pre></td></tr></table></figure>
<h4 id="caveats-of-streams">Caveats of streams</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;&#125; &#123;&#125;: &#123;&#125;!\n&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="number">2023</span>);</span><br></pre></td></tr></table></figure>
<p>since c++23</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;: &#123;&#125;!&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="number">2023</span>);</span><br></pre></td></tr></table></figure>
<h2 id="object-oriented-programming">Object-oriented Programming</h2>
<p>class_keyword is either class or struct</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v; <span class="comment">// not initialized</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> magicValue; <span class="comment">// static member variable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Member function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// non-static member function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cfoo</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// const-qualified non-static member fct.</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>; <span class="comment">// static member function</span></span><br><span class="line">    <span class="built_in">Foo</span>(); <span class="comment">// constructor</span></span><br><span class="line">    ~<span class="built_in">Foo</span>(); <span class="comment">// destructor</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Foo&amp; f); <span class="comment">// overloaded operator==</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>out line</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// inline definition</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fooConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fooStatic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// out-of-line definitions:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo::foo2</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo::fooConst</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo::fooStatic</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="access">Access</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;i; <span class="comment">// explicit member access, &#x27;this&#x27; is of type C*</span></span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// implicit member access (preferred)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;i; <span class="comment">// &#x27;this&#x27; is of type const C*</span></span><br><span class="line">        <span class="comment">// preferred would be: return i;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>the nested type has full access to the parent (friend, see later)</p>
<h3 id="class">class</h3>
<ul>
<li>class have default access private</li>
<li>struct have default access public</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">	<span class="type">int</span> a; <span class="comment">// a is private by default</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// everything after this is public</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// everything after this is protected</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// everything after this is public</span></span><br><span class="line">    <span class="type">int</span> ml&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="friend">Friend</h3>
<ul>
<li>you can put friend declarations in the class body, granting the
friend access to private and protected members of the class</li>
<li><code>friend function_declaration ;</code> declaring a non-member
function as friend of the class (with an implementation elsewhere)</li>
<li><code>friend function_definition ;</code> defines a non-member (!)
function and declares it as friend of the class</li>
<li><code>friend class_specifier ;</code> declares another class as
friend of the class</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// class B is friend of A</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(A&amp;)</span></span>; <span class="comment">// non-member function foo is friend of A</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">bar</span><span class="params">(A&amp; a)</span> </span>&#123; a.a = <span class="number">42</span>; &#125;</span><br><span class="line">    <span class="comment">// OK, non-member function bar is friend of A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>; <span class="comment">// class C is friend of B</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(A&amp; a)</span> </span>&#123; a.a = <span class="number">42</span>; &#125; <span class="comment">// OK, B is friend of A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(A&amp; a)</span> </span>&#123; a.a = <span class="number">42</span>; &#125; <span class="comment">// ERROR, C is not friend of A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(A&amp; a)</span> </span>&#123; a.a = <span class="number">42</span>; &#125; <span class="comment">// OK, foo is friend of A</span></span><br></pre></td></tr></table></figure>
<p>classes can be forward declared:
<code>class_keyword name ;</code></p>
<p>this declares an incomplete type that will be defined later in the
scope</p>
<h3 id="const-correctness">const correctness</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> i; &#125; <span class="comment">// const getter</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> j)</span> </span>&#123; i = j; &#125; <span class="comment">// non-const setter</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(A&amp; nonConstA, <span class="type">const</span> A&amp; constA)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = nonConstA.<span class="built_in">get</span>(); <span class="comment">// OK</span></span><br><span class="line">    <span class="type">int</span> b = constA.<span class="built_in">get</span>(); <span class="comment">// OK</span></span><br><span class="line">    nonConstA.<span class="built_in">set</span>(<span class="number">11</span>);<span class="comment">// OK, non-const</span></span><br><span class="line">	constA.<span class="built_in">set</span> (<span class="number">12</span>); <span class="comment">// ERROR: non-const method on const object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>overload</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getA</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo&amp; foo = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="type">const</span> Foo&amp; cfoo = <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cfoo.getA() == 2, cfoo.getB() == 2</code>, while
<code>cfoo.getC()</code>gives an error</li>
</ul>
<h3 id="ref-qualifier">Ref qualifier</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="built_in">Bar</span>(std::string t = <span class="string">&quot;anonymous&quot;</span>) : s&#123;t&#125; &#123;&#125; <span class="comment">// constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> &amp; </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125; normal instance&quot;</span>, s); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> &amp;&amp; </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125; temporary instance&quot;</span>, s); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar b&#123;<span class="string">&quot;Fredbob&quot;</span>&#125;;</span><br><span class="line">b.<span class="built_in">foo</span>(); <span class="comment">// prints &quot;Fredbob normal instance&quot;</span></span><br><span class="line">Bar&#123;&#125;.<span class="built_in">foo</span>(); <span class="comment">// prints &quot;anonymous temporary instance&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>if you use ref-qualifiers for a member function, all of its
overloads need to have ref-qualifiers (cannot be mixed with normal
overloads)</li>
</ul>
<h3 id="static-class-member">Static class member</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="type">int</span> d, m, y;</span><br><span class="line">    <span class="type">static</span> Date defaultDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDate</span><span class="params">(<span class="type">int</span> dd = <span class="number">0</span>, <span class="type">int</span> mm = <span class="number">0</span>, <span class="type">int</span> yy = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        d = dd ? dd : defaultDate.d;</span><br><span class="line">        m = mm ? mm : defaultDate.m;</span><br><span class="line">        y = yy ? yy : defaultDate.y; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setDefault</span><span class="params">(<span class="type">int</span> dd, <span class="type">int</span> mm, <span class="type">int</span> yy)</span> </span>&#123;</span><br><span class="line">    	defaultDate = &#123;dd, mm, yy&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date Date::defaultDate&#123;<span class="number">16</span>, <span class="number">12</span>, <span class="number">1770</span>&#125;; <span class="comment">// definition of defaultDate</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    d.<span class="built_in">setDate</span>(); <span class="comment">// set to 16, 12, 1770</span></span><br><span class="line">    Date::<span class="built_in">setDefault</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1900</span>);</span><br><span class="line">    d.<span class="built_in">setDate</span>(); <span class="comment">// set to 1, 1, 1900</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="constroctor-and-deconstructor">Constroctor and
deconstructor</h3>
<p>constructors consist of two parts:</p>
<ul>
<li>an initializer list (which is executed first)</li>
<li>a regular function body (executed second)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>; &#125; <span class="comment">// default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="comment">// default constructor implicitly defined by compiler</span></span><br><span class="line">    <span class="comment">// does nothing for a, calls default constructor for b</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">123</span>&#125;; <span class="type">float</span> b; <span class="type">const</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor with initializer list for b, c</span></span><br><span class="line">    <span class="built_in">Foo</span>() : b&#123;<span class="number">2.5</span>&#125;, c&#123;<span class="number">7</span>&#125; &#123;&#125; <span class="comment">// a has default initializer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// initializes a, b, c to the given values</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> av, <span class="type">float</span> bv, <span class="type">char</span> cv) : a&#123;av&#125;, b&#123;bv&#125;, c&#123;cv&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate default constructor, then execute function body</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">float</span> f) : <span class="built_in">Foo</span>() &#123; b *= f; &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>constructors with exactly one argument are special: they are used
for implicit and explicit conversions</li>
<li>if you do not want implicit conversion, mark the constructor as
explicit</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Bar</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFoo</span><span class="params">(Foo f)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBar</span><span class="params">(Bar b)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printFoo</span>(<span class="number">123</span>); <span class="comment">// implicit conversion, calls Foo::Foo(int)</span></span><br><span class="line"><span class="built_in">printBar</span>(<span class="number">123</span>); <span class="comment">// ERROR: no implicit conversion</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;Foo&gt;(<span class="number">123</span>); <span class="comment">// explicit conversion, calls Foo::Foo(int)</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;Bar&gt;(<span class="number">123</span>); <span class="comment">// OK explicit conversion, calls Bar::Bar(int)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="copy-constructorr">Copy constructorr</h4>
<p>constructors of a class C that have a single argument of type
<code>C&amp;</code> or <code>const C&amp;</code> (preferred) are called
copy constructors</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; other) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// copy constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doStuff</span><span class="params">(Foo f)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    <span class="function">Foo <span class="title">g</span><span class="params">(f)</span></span>; <span class="comment">// call copy constructor explicitly</span></span><br><span class="line">    <span class="built_in">doStuff</span>(g); <span class="comment">// call copy constructor implicitly</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deconstructor">deconstructor</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo a;</span><br><span class="line">    &#123;</span><br><span class="line">    	Bar b;</span><br><span class="line">    	<span class="comment">// b.~Bar() is called</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a.~Foo() is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="operator-overloading">Operator overloading</h3>
<p><code>return_type operator op (arguments)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Int <span class="keyword">operator</span>+() <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    Int <span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> Int&#123;-i&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Int a&#123;<span class="number">123</span>&#125;;</span><br><span class="line">+a; <span class="comment">// equivalent to: a.operator+();</span></span><br><span class="line">-a; <span class="comment">// equivalent to: a.operator-();</span></span><br></pre></td></tr></table></figure>
<p>binary</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Int <span class="keyword">operator</span>+(<span class="type">const</span> Int&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> Int&#123;i + other.i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Int&amp;a, <span class="type">const</span> Int&amp; b) &#123; <span class="keyword">return</span> a.i == b.i; &#125;</span><br><span class="line"></span><br><span class="line">Int a&#123;<span class="number">123</span>&#125;; Int b&#123;<span class="number">456</span>&#125;;</span><br><span class="line"></span><br><span class="line">a + b; <span class="comment">// equivalent to: a.operator+(b);</span></span><br><span class="line">a == b; <span class="comment">// equivalent to: operator==(a, b);</span></span><br></pre></td></tr></table></figure>
<p>Increment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Int&amp; <span class="keyword">operator</span>++() &#123; ++i; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    Int <span class="keyword">operator</span>--(<span class="type">int</span>) &#123; Int copy&#123;*<span class="keyword">this</span>&#125;; --i; <span class="keyword">return</span> copy; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Int a&#123;<span class="number">123</span>&#125;;</span><br><span class="line">++a; <span class="comment">// a.i is now 124</span></span><br><span class="line">a++; <span class="comment">// ERROR: post-increment not overloaded</span></span><br><span class="line">Int b = a--; <span class="comment">// b.i is 124, a.i is 123</span></span><br><span class="line">--b; <span class="comment">// ERROR: pre-decrement not overloaded</span></span><br></pre></td></tr></table></figure>
<p>assignment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Int&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Int&amp; other) &#123; i = other.i; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    Int&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Int&amp; other) &#123; i += other.i; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Int a&#123;<span class="number">123</span>&#125;;</span><br><span class="line">a = Int&#123;<span class="number">456</span>&#125;; <span class="comment">// a.i is now 456</span></span><br><span class="line">a += Int&#123;<span class="number">1</span>&#125;; <span class="comment">// a.i is now 457</span></span><br></pre></td></tr></table></figure>
<h4 id="conversions">conversions</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Int a&#123;<span class="number">123</span>&#125;;</span><br><span class="line"><span class="type">int</span> x = a; <span class="comment">// OK, x == 123</span></span><br></pre></td></tr></table></figure>
<p>explicit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Float</span> &#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Float b&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"><span class="type">float</span> y = b; <span class="comment">// ERROR, implicit conversion</span></span><br><span class="line"><span class="type">float</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(b); <span class="comment">// OK, explicit conversion</span></span><br></pre></td></tr></table></figure>
<h3 id="argument-dependent-lookup">Argument-dependent lookup</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">X</span> &#123;&#125;;</span><br><span class="line">    X <span class="keyword">operator</span>+(<span class="type">const</span> X&amp;, <span class="type">const</span> X&amp;) &#123; <span class="keyword">return</span> X&#123;&#125;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::X x, y;</span><br><span class="line">    A::<span class="keyword">operator</span>+(x, y);</span><br><span class="line">    <span class="keyword">operator</span>+(x, y); <span class="comment">// ADL uses operator+ from namespace A</span></span><br><span class="line">    x + y; <span class="comment">// ADL finds A::operator+() &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enum-class">Enum class</h3>
<ul>
<li>by default, the underlying type is an int</li>
<li>by default, enumerator values are assigned increasing from 0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">TrafficLightColor</span> &#123;</span><br><span class="line">	red, yellow, green</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="raii---resource-acquisition-is-initialization">RAII - Resource
Acquisition is Initialization</h2>
<p>bind the lifetime of a resource (e.g. memory, sockets, files,
mutexes, database connections) to the lifetime of an object</p>
<p>Implementation:</p>
<ul>
<li>encapsulate each resource into a class whose sole responsibility is
managing the resource</li>
<li>the constructor acquires the resource and establishes all class
invariants</li>
<li>the destructor releases the resource</li>
<li>typically, copy operations should be deleted and custom move
operations need to be implemented (see later)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeMessage</span><span class="params">(std::string message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mutex to protect file access across threads</span></span><br><span class="line">    <span class="type">static</span> std::mutex myMutex;</span><br><span class="line">    <span class="comment">// lock mutex before accessing file</span></span><br><span class="line">    <span class="function">std::lockguard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;message.txt&quot;</span>)</span></span>; <span class="comment">// try to open file</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) <span class="comment">// throw exception in case it failed</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;unable to open file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    file &lt;&lt; message &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no cleanup needed</span></span><br><span class="line">    <span class="comment">// - file will be closed when leaving scope (regardless of</span></span><br><span class="line">    <span class="comment">// exception) by ofstream destructor</span></span><br><span class="line">    <span class="comment">// - mutex will be unlocked when leaving scope (regardless of</span></span><br><span class="line">    <span class="comment">// exception) by lockguard destructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copy-semantics">Copy semantics</h3>
<ul>
<li>construction and assignment of classes employs copy semantics in
most cases
<ul>
<li>by default, a shallow copy is created</li>
</ul></li>
</ul>
<h4 id="copy-constructor">Copy constructor</h4>
<p>the copy constructor is invoked whenever an object is initialized
from an object of the same type, its syntax is</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class_name</span> ( <span class="type">const</span> class_name&amp; )</span><br></pre></td></tr></table></figure>
<p>the copy constructor is invoked for</p>
<ul>
<li>copy initialization: <code>T a = b;</code></li>
<li>direct initialization: <code>T a&#123;b&#125;;</code></li>
<li>function argument passing:
<code>f(a);</code>where<code>void f(T t)</code></li>
<li>function return: <code>return a;</code> inside a function
<code>T f();</code> (if T has no move constructor, see later)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> v)</span> : v&#123;</span>v&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) : v&#123;other.v&#125; &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1&#123;<span class="number">42</span>&#125;; <span class="comment">// calls A(int)</span></span><br><span class="line"></span><br><span class="line">    A a2&#123;a1&#125;; <span class="comment">// calls copy constructor </span></span><br><span class="line">    A a3 = a2;<span class="comment">// calls copy constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the compiler will implicitly declare a copy constructor if no
user-defined copy constructor is provided</p>
<ul>
<li>the implicitly declared copy constructor will be a public member of
the classthe implicitly declared copy constructor will be a public
member of the class</li>
<li>the implicitly declared copy constructor may or may not be
defined!</li>
</ul>
<p>the implicitly declared copy constructor is defined as = delete if
one of the following is true:</p>
<ul>
<li>the class has non-static data members that cannot be
copy-constructed</li>
<li>the class has a base class which cannot be copy-constructed</li>
<li>the class has a base class with a deleted or inaccessible
destructor</li>
<li>the class has a user-defined move constructor or move assignment
operator</li>
</ul>
<h4 id="copy-assignment">Copy assignment</h4>
<p>the compiler will implicitly declare a copy assignment operator if no
user-defined copy assignment operator is provided</p>
<p>the implicitly declared copy assignment operator is defined as =
delete if one of the following is true:</p>
<ul>
<li>the class has non-static data members that cannot be
copy-assigned</li>
<li>the class has a base class which cannot be copy-assigned</li>
<li>the class has a non-static data member of reference type</li>
<li>the class has a user-defined move constructor or move assignment
operator</li>
</ul>
<p>if it is not deleted, the compiler defines the implicitly-declared
copy constructor</p>
<ul>
<li>only if it is actually used</li>
<li>it will perform a full member-wise copy of the object’s bases and
members in their initialization order</li>
<li>uses direct initialization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> v)</span> : v&#123;</span>v&#125; &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    A a2&#123;a1&#125;; <span class="comment">// OK: calls generated copy constructor</span></span><br><span class="line">    a1 = a2; <span class="comment">// ERROR: the implicitly-declared copy assignment</span></span><br><span class="line">	<span class="comment">// operator is deleted (as v is const)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>often, a class should not be copyable anyway if the implicitly
generated versions do not make sense</p>
<p>guidline:</p>
<ul>
<li>you should provide either provide both copy constructor and copy
assignment, or neither of them</li>
<li>the copy assignment operator should usually include a check to
detect self-assignment</li>
<li>if possible, resources should be reused; if resources cannot be
reused, they have to be cleaned up properly</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> capacity;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; memory; <span class="comment">// better would be: std::vector&lt;int&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">unsigned</span> cap)</span> : capacity&#123;</span>cap&#125;,</span><br><span class="line">    memory&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(capacity)&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) : <span class="built_in">A</span>(other.capacity) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.memory.<span class="built_in">get</span>(), other.memory.<span class="built_in">get</span>() + other.capacity, memory.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="comment">// check for self-assignment</span></span><br><span class="line">        	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (capacity != other.capacity) &#123; <span class="comment">// attempt resource reuse</span></span><br><span class="line">            capacity = other.capacity;</span><br><span class="line">            memory = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.memory.<span class="built_in">get</span>(), other.memory.<span class="built_in">get</span>() + other.capacity, memory.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="the-rule-of-three">The Rule of Three</h4>
<p>if a class requires one of the following, it almost certainly
requires all three</p>
<ul>
<li>a user-defined destructor</li>
<li>a user-defined copy constructor</li>
<li>a user-defined copy assignment operator</li>
</ul>
<h3 id="move-semantics">Move Semantics</h3>
<h4 id="move-constructor">move constructor</h4>
<ul>
<li>the move constructor is invoked when an object is initialized from
an rvalue reference of the same type</li>
</ul>
<p><code>class_name ( class_name&amp;&amp; ) noexcept</code></p>
<ul>
<li>the noexcept keyword is optional, but should be added to indicate
that the move constructor never throws an exception</li>
</ul>
<p>the function <code>std::move</code> from <code>#include</code> can be
used to convert an lvalue to an rvalue reference</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other); <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; other) <span class="keyword">noexcept</span>; <span class="comment">// move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(a1)</span></span>; <span class="comment">// calls copy constructor</span></span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(std::move(a1))</span></span>; <span class="comment">// calls move constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>the move constructor for class type T and objects a,b is invoked
for</p>
<ul>
<li>direct initialization: <code>T a&#123;std::move(b)&#125;;</code></li>
<li>copy initialization: <code>T a = std::move(b);</code></li>
<li>passing arguments to a function <code>void f(T t);</code>
via<code>f(std::move(a))</code></li>
<li>returning from a function <code>T f();</code> via return a;</li>
</ul>
<h4 id="move-assignment">Move assignment</h4>
<p>the move assignment is invoked when an object appears on the
left-hand side of an assignment with an rvalue reference on the
right-hand side</p>
<p><code>class_name&amp; operator=( class_name&amp;&amp; ) noexcept</code></p>
<p>the noexcept keyword is optional, but should be added to indicate
that the move assignment never throws an exception</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) <span class="keyword">noexcept</span>; <span class="comment">// move constructor</span></span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;); <span class="comment">// copy assignment </span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp;) <span class="keyword">noexcept</span>; <span class="comment">// move assignment</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2 = a1; <span class="comment">// calls copy constructor</span></span><br><span class="line">    A a3 = std::<span class="built_in">move</span>(a1); <span class="comment">// calls move constructor</span></span><br><span class="line">    a3 = a2; <span class="comment">// calls copy assignment</span></span><br><span class="line">    a2 = std::<span class="built_in">move</span>(a3); <span class="comment">// calls move assignment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the compiler will implicitly declare a public move constructor, if
all of the following conditions hold:</p>
<ul>
<li>there are no user-declared copy constructors</li>
<li>there are no user-declared copy assignment operators</li>
<li>there are no user-declared move assignment operators</li>
<li>there are no user-declared destructors</li>
</ul>
<p>the implicitly declared move constructor is defined as = delete if
one of the following is true:<br />
</p>
<ul>
<li>the class has non-static data members that cannot be moved</li>
<li>the class has a base class which cannot be moved</li>
<li>the class has a base class with a deleted or inaccessible
destructor</li>
</ul>
<p>the compiler will implicitly declare a public move assignment
operator if all of the following conditions hold:</p>
<ul>
<li>there are no user-declared copy constructors</li>
<li>there are no user-declared copy assignment operators</li>
<li>there are no user-declared move constructors</li>
<li>there are no user-declared destructors</li>
</ul>
<p>the implicitly declared copy assignment operator is defined as =
delete if one of the following is true:</p>
<ul>
<li>the class has non-static data members that cannot be moved</li>
<li>the class has non-static data members of reference type</li>
<li>the class has a base class which cannot be moved</li>
<li>the class has a base class with a deleted or inaccessible
destructor</li>
</ul>
<p>if it is not deleted, the compiler defines the implicitly-declared
move constructor</p>
<ul>
<li>only if it is actually used</li>
<li>it will perform a full member-wise move of the object’s bases and
members in their initialization order</li>
<li>uses direct initialization</li>
</ul>
<p>if it is not deleted, the compiler defines the implicitly-declared
move assignment operator</p>
<ul>
<li>only if it is actually used</li>
<li>it will perform a full member-wise move assignment of the object’s
bases and members in their initialization order</li>
<li>uses built-in assignment for scalar types and move assignment for
class types</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> vv)</span> : v&#123;</span>vv&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    A a2&#123;std::<span class="built_in">move</span>(a1)&#125;; <span class="comment">// OK: calls generated move constructor</span></span><br><span class="line">    a1 = std::<span class="built_in">move</span>(a2); <span class="comment">// ERROR: the implicitly-declared move</span></span><br><span class="line">    <span class="comment">// assignment operator is deleted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>custom move constructors/assignment operators are often necessary</p>
<p>guideline:</p>
<ul>
<li>you should either provide both move constructor and move assignment,
or neither of them</li>
<li>the move assignment operator should usually include a check to
detect self-assignment</li>
<li>the move operations typically do not allocate new resources, but
steal the resources from the argument</li>
<li>the move operations should leave the argument in a valid (but
indeterminate) state</li>
<li>any previously held resources must be cleaned up properly!</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> capacity;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; memory; <span class="comment">// better would be: std::vector&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">unsigned</span> cap)</span> : capacity&#123;</span>cap&#125;,</span><br><span class="line">    memory&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(capacity)&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; other) <span class="keyword">noexcept</span> : capacity&#123;other.capacity&#125;,</span><br><span class="line">        memory&#123;std::<span class="built_in">move</span>(other.memory)&#125; &#123;</span><br><span class="line">        other.capacity = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="comment">// check for self-assignment</span></span><br><span class="line">        	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        capacity = other.capacity;</span><br><span class="line">        memory = std::<span class="built_in">move</span>(other.memory);</span><br><span class="line"></span><br><span class="line">        other.capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The Rule of Five</p>
<ul>
<li>if a class wants move semantics, it has to define all five special
member functions</li>
<li>if a class wants only move semantics, it still has to define all
five special member functions, but define the copy operations
as<code>= delete</code></li>
</ul>
<p>The Rule of Zero</p>
<ul>
<li>classes not dealing with ownership (e.g. of resources) should not
have custom destructors, copy/move constructors or copy/move assignment
operators</li>
<li>classes that do deal with ownership should do so exclusively (and
follow the Rule of Five)</li>
</ul>
<h4 id="copy-and-swap">Copy and swap</h4>
<p>if copy assignment cannot benefit from resource reuse, the copy and
swap idiom may be useful:</p>
<ul>
<li>the class only
defines<code>class_name&amp; operator=( class_name )</code>
copy-and-swap assignment operator</li>
</ul>
<p>it acts as both copy and move assignment operator, depending on the
value category of the argument</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> capacity;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; memory; <span class="comment">// better would be: std::vector&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">unsigned</span> cap)</span> : capacity&#123;</span>cap&#125;,</span><br><span class="line">    	memory&#123;std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(capacity)&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) : <span class="built_in">A</span>(other.capacity) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.memory.<span class="built_in">get</span>(),</span><br><span class="line">        other.memory.<span class="built_in">get</span>() + other.capacity, memory.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A other) &#123; <span class="comment">// copy/move constructor will create &#x27;other&#x27;</span></span><br><span class="line">        std::<span class="built_in">swap</span>(capacity, other.capacity);</span><br><span class="line">        std::<span class="built_in">swap</span>(memory, other.memory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="comment">// destructor of &#x27;other&#x27; cleans up resources formerly held by *this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="copy-elisionlvalue-rvalue">Copy elision(lvalue, rvalue)</h3>
<ul>
<li><p>glvalues identify objects</p></li>
<li><p>xvalues identify an object whose resources can be reused</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(x))</span><br></pre></td></tr></table></figure></li>
<li><p>prvalues compute the value of an operand or initialize an
object</p></li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20240220161050243.png"
alt="image-20240220161050243" />
<figcaption aria-hidden="true">image-20240220161050243</figcaption>
</figure>
<p>Compilers have to omit copy/move construction of class objects under
certain circumstances:</p>
<ul>
<li>in a return statement, when the operand is a prvalue of the same
class type as the function return type:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(); <span class="comment">// only one call to default constructor of T</span></span><br><span class="line"></span><br><span class="line">T x = T&#123;T&#123;<span class="built_in">f</span>()&#125;&#125;; <span class="comment">// only one call to default constructor of T</span></span><br></pre></td></tr></table></figure>
<h3 id="ownership-semantics">Ownership semantics</h3>
<p>a resource should be owned (encapsulated) by exactly one object at
all times, ownership can only be transferred explicitly by moving the
respective object</p>
<ul>
<li>always use ownership semantics when managing resources in C++ (such
as memory, file handles, sockets etc.)!</li>
</ul>
<h3 id="smart-pointer">Smart pointer</h3>
<h4 id="unique-pointer">unique pointer</h4>
<ul>
<li><p><code>std::unique_ptr</code> is a smart pointer implementing
ownership semantics for arbitrary pointers</p></li>
<li><p>assumes unique ownership of another object through a
pointer</p></li>
<li><p>automatically disposes of that object when
<code>std::unique_ptr</code> goes out of scope</p></li>
<li><p>a <code>std::unique_ptr</code> can be used (almost) exactly like
a raw pointer, but it can only be moved, not copied</p></li>
<li><p>a <code>std::unique_ptr</code> may be empty</p></li>
</ul>
<p>ALWAYS use <code>std::unique_ptr</code> over raw pointers!</p>
<p>creation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">make_unique</span>&lt;type&gt;(arg0, ..., argN)</span><br></pre></td></tr></table></figure>
<ul>
<li>the <code>get()</code> member function returns the raw pointer</li>
<li><code>release()</code> member function returns the raw pointer and
releases ownership(very rarely required)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> aa, <span class="type">int</span> bb) : a&#123;aa&#125;,b&#123;bb&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::unique_ptr&lt;A&gt; aptr)</span> <span class="comment">// assume ownership</span></span></span><br><span class="line"><span class="function">	<span class="comment">// do sth</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> A&amp; a)</span> </span>&#123; <span class="comment">// does not assume ownership</span></span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> aptr = std::<span class="built_in">make_unique</span>&lt;A&gt;(<span class="number">42</span>,<span class="number">123</span>);</span><br><span class="line">    <span class="type">int</span> a = aptr-&gt;a;</span><br><span class="line">    <span class="built_in">bar</span>(*aptr); <span class="comment">// retain ownership</span></span><br><span class="line">    <span class="built_in">foo</span>(std::<span class="built_in">move</span>(aptr)) <span class="comment">// transfer ownership</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>array example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">foo</span><span class="params">(<span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> buffer = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        buffer[i] = i;</span><br><span class="line">	<span class="keyword">return</span> buffer; <span class="comment">// transfers ownership to caller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> buffer = <span class="built_in">foo</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>Advanced example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for std::is_pointer_v</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) ((int) (x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vector&lt;pair&lt;<span class="type">int</span>,ll&gt;&gt;&gt; Graphl;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125; <span class="comment">// required!</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;A&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;A&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">cloneImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> Base&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloneInherit</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Derived&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Derived&gt;(</span><br><span class="line">    	<span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">cloneImpl</span>()));</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CloneInherit* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> CloneInherit&lt;B, A&gt; &#123;</span><br><span class="line">    <span class="comment">// nothing to be done!</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b1 = <span class="built_in">make_unique</span>&lt;B&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b2 = <span class="built_in">make_unique</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    b2-&gt;a = <span class="number">1</span>; b2-&gt;v = <span class="number">2</span>;</span><br><span class="line">    b1-&gt;a = <span class="number">3</span>; b1-&gt;v = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// from B to A</span></span><br><span class="line">    unique_ptr&lt;A&gt; a1 = std::<span class="built_in">move</span>(b1);</span><br><span class="line">    <span class="keyword">auto</span> a2 = a1-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// from A to B (2 kind)</span></span><br><span class="line">    B* t2 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(a<span class="number">2.</span><span class="built_in">release</span>());</span><br><span class="line">    <span class="function">unique_ptr&lt;B&gt; <span class="title">ut</span><span class="params">(<span class="keyword">dynamic_cast</span>&lt;B*&gt;(a<span class="number">1.</span>release()))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; t2-&gt;a _ t2-&gt;v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> t2; <span class="comment">// delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shared-pointer">shared pointer</h4>
<p><code>std::shared_ptr</code> is a smart pointer implementing shared
ownership</p>
<ul>
<li>a resource can be simultaneously shared with several owners</li>
<li>the resource will only be released once the last owner releases
it</li>
<li>multiple <code>std::shared_ptr</code> objects can own the same raw
pointer, implemented through reference counting</li>
<li>a <code>std::shared_ptr</code> can be copied and moved</li>
</ul>
<p>use <code>std::make_shared</code> for creation</p>
<p>to break cycles, you can use <code>std::weak_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(std::shared_ptr&lt;Node&gt; child)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChild</span><span class="params">(<span class="type">unsigned</span> index)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node root;</span><br><span class="line">    root.<span class="built_in">addChild</span>(std::<span class="built_in">make_shared</span>&lt;Node&gt;());</span><br><span class="line">    root.<span class="built_in">addChild</span>(std::<span class="built_in">make_shared</span>&lt;Node&gt;());</span><br><span class="line">    root.children[<span class="number">0</span>]-&gt;<span class="built_in">addChild</span>(root.children[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    root.<span class="built_in">removeChild</span>(<span class="number">1</span>); <span class="comment">// does not free memory yet</span></span><br><span class="line">    root.<span class="built_in">removeChild</span>(<span class="number">0</span>); <span class="comment">// frees memory of both children</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>guidline:</p>
<ul>
<li><code>std::unique_ptr</code> should almost always be passed by
value</li>
<li>raw pointers represent resourcesraw pointers represent
resources</li>
<li>references grant temporary access to an object without assuming
ownership</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reads a without assuming ownership</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readA</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;</span><br><span class="line"><span class="comment">// may read and modify a but does not assume ownership</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readWriteA</span><span class="params">(A&amp; a)</span></span>;</span><br><span class="line"><span class="comment">// works on a copy of A</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workOnCopyOfA</span><span class="params">(A a)</span></span>;</span><br><span class="line"><span class="comment">// assumes ownership of A</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumeA</span><span class="params">(A&amp;&amp; a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readA</span>(a);</span><br><span class="line">    <span class="built_in">readWrite</span>(a);</span><br><span class="line">    <span class="built_in">workOnCopyOfA</span>(a);</span><br><span class="line">    <span class="built_in">consumeA</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// cannot call without std::move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DO NOT DO:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* i;</span><br><span class="line">*i = <span class="number">5</span>; <span class="comment">// OUCH: writing to random memory location</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* i = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// ... use i ...</span></span><br><span class="line">&#125; <span class="comment">// OUCH: memory of i not freed, memory leak!</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* i = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// ... use i ...</span></span><br><span class="line"><span class="keyword">delete</span> i;</span><br><span class="line"><span class="keyword">delete</span> i; <span class="comment">// OUCH: freeing already freed pointer, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>* i)</span> </span>&#123;</span><br><span class="line">	*i = <span class="number">5</span>; <span class="comment">// OUCH: i might be nullptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// OUCH: this might crash or worse..</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *i = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *j = i; <span class="comment">// i and j now point to same location</span></span><br><span class="line"></span><br><span class="line">*j = <span class="number">10</span>; <span class="comment">// ok, i[0] is now 10</span></span><br><span class="line">*j++ = <span class="number">11</span>; <span class="comment">// ok, i[0] is now 11, j points to i[1]</span></span><br><span class="line">*(++j) = <span class="number">12</span>; <span class="comment">// ok, i[2] is now 12, j points to i[2]</span></span><br><span class="line">*(j + <span class="number">10</span>) = <span class="number">13</span>; <span class="comment">// OUCH: overwriting something unrelated to i/j</span></span><br></pre></td></tr></table></figure>
<h2 id="oop2">OOP2</h2>
<h3 id="derived-class">Derived Class</h3>
<p>any class type (struct or class) can be derived from one or several
base classes</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> : base_specifier_list &#123;</span><br><span class="line">	member_specification</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>base specifier list</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_specifier virtual_specifier base_class_name</span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived0</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple inheritance: avoid if possible</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Base, <span class="keyword">private</span> Derived1 &#123;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="constructor">constructor</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>() : a&#123;<span class="number">42</span>&#125; &#123; std::cout &lt;&lt; <span class="string">&quot;Base::Base()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Base</span><span class="params">(<span class="type">int</span> av)</span> : a&#123;</span>av&#125; &#123;</span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;Base::Base(int)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>() : b&#123;<span class="number">42</span>&#125; &#123; std::cout &lt;&lt; <span class="string">&quot;Derived::Derived()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> av, <span class="type">int</span> bv) : <span class="built_in">Base</span>(av), b&#123;bv&#125; &#123;</span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;Derived::Derived(int, int)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived0;</span><br><span class="line">    <span class="function">Derived <span class="title">derived1</span><span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// Base::Base()</span></span><br><span class="line"><span class="comment">// Derived::Derived()</span></span><br><span class="line"><span class="comment">// Base::Base(int)</span></span><br><span class="line"><span class="comment">// Derived::Derived(int, int)</span></span><br></pre></td></tr></table></figure>
<h4 id="deconstructor-1">deconstructor</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base0</span> &#123;</span><br><span class="line">	~<span class="built_in">Base0</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base0::~Base0()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line">	~<span class="built_in">Base1</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base1::~Base1()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base0, Base1 &#123;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived::~Derived()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// Derived::~Derived()</span></span><br><span class="line"><span class="comment">// Base1::~Base1()</span></span><br><span class="line"><span class="comment">// Base0::~Base0()</span></span><br></pre></td></tr></table></figure>
<h4 id="qualified-look-up">qualified look up</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main &#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">a</span>(); <span class="comment">// calls B::a()</span></span><br><span class="line">    b.A::<span class="built_in">a</span>(); <span class="comment">// calls A::a()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inheritance-mode">inheritance mode</h4>
<ul>
<li>public means the public base class members are public, and the
protected members are protected</li>
<li>protected means the public and protected base class members are only
accessible for class members / friends of the derived class and its
derived classes</li>
<li>private means the public and protected base class members are only
accessible for class members / friends of the derived class</li>
</ul>
<h3 id="virtual-function-and-polymorphy">Virtual function and
polymorphy</h3>
<p>inheritance in C++ is by default non-polymorphic, the type of the
object determines which member is referred to</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; b = d; <span class="comment">// works, Derived IS-A Base</span></span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">foo</span>(); <span class="comment">// prints Derived::foo()</span></span><br><span class="line">    b.<span class="built_in">foo</span>(); <span class="comment">// prints Base::foo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="virtual-function">virtual function</h4>
<p>non-static member functions can be marked virtual, a class with at
least one virtual function is polymorphic</p>
<ul>
<li>only the function in the base class needs to be marked virtual, the
overriding functions in derived classes do not need to be (and should
not be) marked<code>virtual</code></li>
<li>instead they are marked <code>override</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; br = b;</span><br><span class="line">    Base&amp; dr = d;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">foo</span>(); <span class="comment">// prints Derived::foo()</span></span><br><span class="line">    dr.<span class="built_in">foo</span>(); <span class="comment">// prints Derived::foo()</span></span><br><span class="line">    d.Base::<span class="built_in">foo</span>(); <span class="comment">// prints Base::foo()</span></span><br><span class="line">    dr.Base::<span class="built_in">foo</span>(); <span class="comment">// prints Base::foo()</span></span><br><span class="line"></span><br><span class="line">    br.<span class="built_in">foo</span>(); <span class="comment">// prints Base::foo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>with override</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span> i)</span> <span class="keyword">override</span></span>; <span class="comment">// ERROR: does not override foo(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// ERROR: does not override bar()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>to prevent overriding a function it can be marked as final:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// ERROR: overriding final function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123; <span class="comment">// ERROR: deriving final class</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="virtual-deconstructor">Virtual deconstructor</h4>
<ul>
<li>derived objects can be deleted through a pointer to the base class,
this leads to undefined behavior unless the destructor in the base class
is virtual</li>
<li>hence, the destructor in a base class should either be protected and
non-virtual or public and virtual (this should be the default)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> b; <span class="comment">// OK thanks to virtual destructor</span></span><br><span class="line">    <span class="comment">// but in general: don&#x27;t use naked pointers/new/delete!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="slicing">Slicing</h4>
<p>inheritance hierarchies need to be handled via references (or
pointers)!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    B b;</span><br><span class="line">    A a = b; <span class="comment">// a will only contain x, y is lost</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>another example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    B b2;</span><br><span class="line"></span><br><span class="line">    A&amp; ar = b2;</span><br><span class="line">    ar = b1; <span class="comment">// b2 now contains a mixture of b1 and b2!!!, x changed, y not change</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in most of the cases you should then = delete all copy/move
operations to prevent slicing</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseOfFive</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseOfFive</span>() = <span class="keyword">default</span>; <span class="comment">// = &#123;&#125;</span></span><br><span class="line">    <span class="built_in">BaseOfFive</span>(<span class="type">const</span> BaseOfFive&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">BaseOfFive</span>(BaseOfFive&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    BaseOfFive&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BaseOfFive&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    BaseOfFive&amp; <span class="keyword">operator</span>=(BaseOfFive&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>to enable copying of polymorphic objects, you can define a factory
method</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125; <span class="comment">// default constructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() = <span class="keyword">default</span>; <span class="comment">// base class with virtual destructor</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>; <span class="comment">// prevent slicing</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;A&gt; <span class="title">clone</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="comment">/* A object */</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">	<span class="function">std::unique_ptr&lt;A&gt; <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="comment">/* B object */</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = std::<span class="built_in">make_unique</span>&lt;B&gt;();</span><br><span class="line"><span class="keyword">auto</span> a = b-&gt;<span class="built_in">clone</span>(); <span class="comment">// cloned copy of b</span></span><br></pre></td></tr></table></figure>
<h4 id="convert">convert</h4>
<p>to convert references (or pointers) in an inheritance hierarchy in a
safe manner, you can use</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> 	<span class="keyword">virtual</span> ~<span class="built_in">A</span>() = <span class="number">0</span>; <span class="comment">// make class abstract</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : A&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">baz</span><span class="params">(<span class="type">const</span> A* aptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> bptr = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> B*&gt;(aptr)) &#123;</span><br><span class="line">        bptr-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> cptr = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> C*&gt;(aptr)) &#123;</span><br><span class="line">        cptr-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>polymorphism does not come for free, it has overhead!
Implementation:vtable</li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20240220205406785.png"
alt="image-20240220205406785" />
<figcaption aria-hidden="true">image-20240220205406785</figcaption>
</figure>
<ul>
<li>run-time cost,each virtual function call has to: follow the pointer
to the vtable, follow the pointer to the actual function</li>
<li>memory cost,polymorphic objects have larger size, as they have to
store a pointer to the vtable</li>
</ul>
<h3 id="pure-virtual-function">Pure virtual function</h3>
<p>a virtual function can be marked as a pure virtual function by
adding<code>= 0</code>at the end of the declarator/specifiers</p>
<p>abstract classes are special:</p>
<ul>
<li><p>they cannot be instantiated</p></li>
<li><p>but they can be used as a base class (defining an
interface)</p></li>
<li><p>references (and pointers) to abstract classes can be
declared</p></li>
<li><p>caution: calling a pure virtual function in the constructor or
destructor of an abstract class is undefined behavior!</p></li>
</ul>
<p>The destructor can be marked as pure virtual</p>
<ul>
<li>useful when class needs to be abstract, but has no suitable
functions that could be declared pure virtual</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base::~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Base b; <span class="comment">// ERROR: Base is abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shared-from-this">shared from this</h3>
<p>when you want to create std::shared_ptr of the class you are
currently in, i.e. from this, you need to be careful</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> : std::enable_shared_from_this&lt;S&gt; &#123;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;S&gt; <span class="title">notDangerous</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">shared_from_this</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;S&gt; sp1&#123;std::<span class="built_in">make_shared</span>&lt;S&gt;()&#125;;</span><br><span class="line">    std::shared_ptr&lt;S&gt; sp2 = sp1-&gt;<span class="built_in">notDangerous</span>();</span><br><span class="line">    <span class="comment">// all is good now!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>caveat: this only works correctly if shared_from_this is called on an
object that is already owned by a std::shared_ptr!</p>
<h2 id="concept-of-generic-programming">Concept of generic
programming</h2>
<p>template declaration syntax:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; parameter_list &gt; declaration</span><br></pre></td></tr></table></figure>
<p>parameter_list is a comma-separated list of template parameters</p>
<ul>
<li>type template parameters</li>
<li>non-type template parameters</li>
<li>template template parameters</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">	T storage[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> i) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(i &lt; N);</span><br><span class="line">        <span class="keyword">return</span> storage[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>template of template</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="type">unsigned</span>&gt; <span class="keyword">class</span> <span class="title class_">ArrayType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">	ArrayType&lt;<span class="type">int</span>, <span class="number">42</span>&gt; someArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>template parameters with default values cannot be followed by
template parameters without default values</p>
<p>template arguments for template template arguments must name a class
template or template alias</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> <span class="type">long</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="keyword">class</span> <span class="title class_">Array</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">42</span>&gt; bar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;MyArray&gt; foo1;</span><br><span class="line">    Foo&lt;std::array&gt; foo2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>alias template</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> something::extremely::nested &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Handle</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end namespace something::extremely::nested</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Handle = something::extremely::nested::Handle&lt;T, <span class="type">void</span>*&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Handle&lt;<span class="type">int</span>&gt; handle1;</span><br><span class="line">    Handle&lt;<span class="type">double</span>&gt; handle2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="template-instantiation">template instantiation</h3>
<p>explicitly force instantiation of a template specialization</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">template_name</span> &lt; argument_list &gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">template_name</span> &lt; argument_list &gt;;</span><br><span class="line"><span class="keyword">template</span> ret_type name &lt; argument_list &gt; (param_list); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">foo</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> value + <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">baz</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// explicit instantiation of A&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">A</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// explicit instantiation of baz&lt;float&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">float</span> <span class="built_in">baz</span>&lt;<span class="type">float</span>&gt;(<span class="type">float</span>, <span class="type">float</span>);</span><br></pre></td></tr></table></figure>
<p>Implicit template instantiation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">foo</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> value + <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a; <span class="comment">// instantiates only A&lt;int&gt;</span></span><br><span class="line">    <span class="type">int</span> x = a.<span class="built_in">foo</span>(<span class="number">32</span>); <span class="comment">// instantiates A&lt;int&gt;::foo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: no error, even though A::bar is never defined</span></span><br><span class="line"></span><br><span class="line">    A&lt;<span class="type">float</span>&gt;* aptr; <span class="comment">// does not instantiate A&lt;float&gt;!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="out-of-line-definition">Out of line definition</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(T v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line">    <span class="function">R <span class="title">convert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// out-of-line definition</span></span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T v) : value&#123;v&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt; <span class="comment">// out-of-line definition</span></span><br><span class="line">R A&lt;T&gt;::<span class="built_in">convert</span>() &#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;R&gt;(value); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="disambiguator">Disambiguator</h3>
<p>if such a name should be considered as a type, the typename
disambiguator has to be used</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">using</span> MemberTypeAlias = <span class="type">float</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="keyword">using</span> AnotherMemberTypeAlias = <span class="keyword">typename</span> T::MemberTypeAlias;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B&lt;A&gt;::AnotherMemberTypeAlias value = <span class="number">42.0f</span>; <span class="comment">// value is type float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if such a name should be considered as a template name, the template
disambiguator has to be used</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line">    <span class="function">R <span class="title">convert</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;R&gt;(<span class="number">42</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="keyword">template</span> <span class="built_in">convert</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reference-collapsing">reference collapsing</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">	<span class="keyword">using</span> Trref = T&amp;&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Foo&lt;<span class="type">int</span>&amp;&amp;&gt;::Trref x; <span class="comment">// what is the type of x?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>rvalue reference to rvalue reference collapses to rvalue
reference</li>
<li>any other combination forms an lvalue reference</li>
</ul>
<h3 id="template-specialization">Template specialization</h3>
<p>general</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; declaration</span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="comment">/* generic implementation */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>&lt;<span class="type">long</span>&gt; &#123;</span><br><span class="line"><span class="comment">/* specific implementation for long */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyContainer&lt;<span class="type">float</span>&gt; a; <span class="comment">// uses generic implementation</span></span><br><span class="line">    MyContainer&lt;<span class="type">long</span>&gt; b; <span class="comment">// uses specific implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="partial-specialization">Partial specialization</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SearchAlgorithm</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">const</span> C&amp; container, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do linear search */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SearchAlgorithm</span>&lt;std::vector&lt;T&gt;, T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; container, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do binary search */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="template-argument-deduction">Template argument deduction</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(a, b); <span class="comment">// T is deduced to be int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sometimes ambigouus</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">long</span> b&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">max</span>(a, b); <span class="comment">// ERROR: ambiguous deduction of T</span></span><br><span class="line">    <span class="built_in">max</span>(a, a); <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(a, b); <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">max</span>&lt;<span class="type">long</span>&gt;(a, b); <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class deduction</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector v1&#123;<span class="number">42</span>&#125;; <span class="comment">// vector&lt;int&gt; with one element</span></span><br><span class="line">    std::vector v2&#123;v1&#125;; <span class="comment">// v2 is also vector&lt;int&gt;</span></span><br><span class="line">    <span class="comment">// and not vector&lt;vector&lt;int&gt;&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>deduction guide</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">MyPair</span>(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y) : first&#123;x&#125;, second&#123;y&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deduction guide for the constructor:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="built_in">MyPair</span>(T1, T2) -&gt; MyPair&lt;T1, T2&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyPair p1&#123;<span class="string">&quot;hi&quot;</span>s, <span class="string">&quot;world&quot;</span>s&#125;; <span class="comment">// pair of std::string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let std::vector&lt;&gt; deduce element type from initializing iterators:</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">    <span class="built_in">vector</span>(Iterator, Iterator)</span><br><span class="line">    	-&gt; vector&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this allows, for example:</span></span><br><span class="line">std::set&lt;<span class="type">float</span>&gt; s;</span><br><span class="line"><span class="comment">// ... fill s ...</span></span><br><span class="line"><span class="function">std::vector <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>; <span class="comment">// OK, std::vector&lt;float&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="auto-1">auto</h4>
<p>auto does not require any modifiers to work, however, it can make
code hard to understand and error prone, so all known modifiers should
always be added to auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// using raw pointers for illustrative purposes only</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BAD:</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">foo</span>(); <span class="comment">// auto is const int*</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> f2 = <span class="built_in">foo</span>(); <span class="comment">// auto is int*</span></span><br><span class="line">    <span class="keyword">auto</span>* f3 = <span class="built_in">foo</span>(); <span class="comment">// auto is const int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GOOD:</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>* f4 = <span class="built_in">foo</span>(); <span class="comment">// auto is int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>auto is not deduced to a reference type,</p>
<p>this might incur unwanted copies, so always add all known modifiers
to auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">const</span> A&amp; <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">auto</span> a1 = a.<span class="built_in">foo</span>(); <span class="comment">// BAD: auto is const A, copy</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; a2 = a.<span class="built_in">foo</span>(); <span class="comment">// GOOD: auto is A, no copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="template-lambda">template lambda</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generic lambda:</span></span><br><span class="line"><span class="keyword">auto</span> sumGen = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// templated lambda:</span></span><br><span class="line"><span class="keyword">auto</span> sumTem = []&lt;<span class="keyword">typename</span> T&gt;(T x, T y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<p>in fact, since C++20, also ordinary functions can take auto
parameters as well:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">auto</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>this automatically translates into a function template with an
invented template parameter for each auto parameter</p>
<h3 id="parameter-pack">Parameter pack</h3>
<p>parameter packs are template parameters that accept zero or more
arguments</p>
<ul>
<li>non-type: <code>type ... Args</code></li>
<li>type: <code>typename|class ... Args</code></li>
<li>template:
<code>template &lt; param_list &gt; typename|class ... Args</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a variadic class template with one parameter pack</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a variadic function template, expanding the pack in its argument</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTuple</span><span class="params">(<span class="type">const</span> Tuple&lt;T...&gt;&amp; tuple)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a variadic function template with a function parameter pack</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(<span class="type">const</span> T&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">float</span>&gt; tuple;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printTuple</span>(tuple);</span><br><span class="line">    <span class="built_in">printElements</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">()</span> </span>&#123; std::<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(<span class="type">const</span> Head&amp; head, <span class="type">const</span> Tail&amp;... tail)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, head);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(tail) &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    	<span class="title">std::print</span><span class="params">(<span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printElements</span>(tail...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printElements</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>, <span class="number">3.14</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="fold-expression">fold expression</h4>
<p>fold expressions can be used to reduce a parameter pack over a binary
operator<code>op</code></p>
<ul>
<li>variant 1 (unary left): ( … op pack )</li>
<li>variant 2 (unary right): ( pack op … )</li>
<li>variant 3 (binary left): ( init op … op pack )</li>
<li>variant 4 (binary right): ( pack op … op init )</li>
<li>pack must be an expression containing an unexpanded parameter
pack</li>
<li>init must be an expression not containing a parameter pack</li>
</ul>
<p>semantics:</p>
<ul>
<li><span class="math inline">\((\ldots \circ E)\)</span> becomes <span
class="math inline">\(\left(\left(E_1 \circ E_2\right) \circ
\ldots\right) \circ E_n\)</span></li>
<li><span class="math inline">\((E \circ \ldots)\)</span> becomes <span
class="math inline">\(E_1 \circ\left(\ldots\left(E_{n-1} \circ
E_n\right)\right)\)</span></li>
<li><span class="math inline">\((I \circ \ldots \circ E)\)</span>
becomes <span class="math inline">\(\left(\left(\left(I \circ E_1\right)
\circ E_2\right) \circ \ldots\right) \circ E_n\)</span></li>
<li><span class="math inline">\((E \circ \ldots \circ I)\)</span>
becomes <span class="math inline">\(E_1 \circ\left(\ldots\left(E_{n-1}
\circ\left(E_n \circ I\right)\right)\right)\)</span></li>
</ul>
<p>unary fold:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">R <span class="title">reduceSum</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">reduceSum</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// returns 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>binary fold:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp;... args)</span> </span>&#123;</span><br><span class="line">	(std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(); <span class="comment">// prints nothing</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// prints &quot;1\n&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// prints &quot;123\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>previous print</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(<span class="type">const</span> Head&amp; head, <span class="type">const</span> Tail&amp;... tail)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generic lambda</span></span><br><span class="line">    <span class="keyword">auto</span> outWithComma = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; arg) &#123; std::<span class="built_in">print</span>(<span class="string">&quot;, &#123;&#125;&quot;</span>, arg); &#125;;</span><br><span class="line"></span><br><span class="line">    (..., <span class="built_in">outWithComma</span>(tail) ); <span class="comment">// unary fold expression with comma operator</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printElements</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>, <span class="number">3.14</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="compile-time-programming">Compile-time programming</h2>
<ul>
<li>const: do not modify this object in this scope (variables, member
functions)</li>
<li>constexpr: something that can be evaluated at compile-time</li>
</ul>
<p>the keyword <code>constexpr</code> declares a variable or function to
be able to be evaluated at compile-time</p>
<p>constexpr variables must be</p>
<ul>
<li>of literal type (e.g. scalar, reference, or user-defined type with
constexpr constructor/destructor)</li>
<li>immediately initialized with a constant expression</li>
</ul>
<p>constexpr functions must</p>
<ul>
<li>have literal return types and arguments</li>
<li>not contain things like goto or variable definitions of non-literal
types or static/thread storage duration</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x&#123;<span class="number">7</span>&#125;; <span class="comment">// constant expression</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y = <span class="built_in">f</span>(x); <span class="comment">// not a constant expression!</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> z = <span class="built_in">g</span>(x); <span class="comment">// constant expression</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> xx&#123;x&#125;; <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> yy&#123;y&#125;; <span class="comment">// ERROR: f(x) not constant expression</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> zz&#123;z&#125;; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="function-1">function</h3>
<p>constexpr functions are like regular functions, except they cannot
have side effects</p>
<ul>
<li>since C++20, exceptions and exception handling may be used</li>
</ul>
<p>to make your user-defined type (class) a literal type, it needs</p>
<ul>
<li>a constexpr destructor (or trivial before C++20)</li>
<li>to have at least one constexpr constructor (that is not copy/move),
or it could be an aggregate type</li>
</ul>
<p>if you want the member function to be const, you have to additionally
declare it as such</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">myFunc</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>functions can still be called at run-time</p>
<p>if you want guaranteed execution at compile-time, C++20 introduced
the consteval keyword to enable immediate functions</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">sqr</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqrRunTime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">sqrCompileTime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sqrRunOrCompileTime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> p1 = <span class="built_in">sqrRunTime</span>(<span class="number">100</span>); <span class="comment">// ERROR: not constexpr</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> p2 = <span class="built_in">sqrCompileTime</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> p3 = <span class="built_in">sqrRunOrCompileTime</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> p4 = <span class="built_in">sqrRunTime</span>(x);</span><br><span class="line">    <span class="type">int</span> p5 = <span class="built_in">sqrCompileTime</span>(x); <span class="comment">// ERROR: x not constant expression</span></span><br><span class="line">    <span class="type">int</span> p6 = <span class="built_in">sqrRunOrCompileTime</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p7 = <span class="built_in">sqrCompileTime</span>(<span class="number">100</span>); <span class="comment">// compile-time</span></span><br><span class="line">    <span class="type">int</span> p8 = <span class="built_in">sqrRunOrCompileTime</span>(<span class="number">100</span>); <span class="comment">// run-time or compile-time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if">if</h4>
<p>with if constexpr we can evaluate conditions at compile-time</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for std::is_pointer_v</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getValue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer_v&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">return</span> *t</span>; <span class="comment">// deduces return type to int for T = int*</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> t; <span class="comment">// deduces return type to int for T = int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i&#123;<span class="number">9</span>&#125;; </span><br><span class="line">    <span class="keyword">auto</span> j = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getValue</span>(i) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// output &quot;9&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getValue</span>(j.<span class="built_in">get</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// output &quot;9&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for return</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::forward</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for std::is_same and std::invoke_result</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">call</span><span class="params">(Callable op, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_void_v&lt;std::<span class="type">invoke_result_t</span>&lt;Callable, Args...&gt;&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return type is void:</span></span><br><span class="line">        <span class="built_in">op</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">// do something before we return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// return type is not void:</span></span><br><span class="line">        <span class="keyword">auto</span> retValue&#123;<span class="built_in">op</span>(std::forward&lt;Args&gt;(args)...)&#125;;</span><br><span class="line">        <span class="comment">// do something with retValue before we return</span></span><br><span class="line">        <span class="keyword">return</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>C++23 introduced another if statement: if consteval</p>
<p>syntax:<code>if consteval &#123; /* A */ &#125; else &#123; /* B */ &#125;</code></p>
<ul>
<li>no condition</li>
<li>mandatory braces</li>
<li>else branch is optional</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">consteval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(i) + <span class="number">1</span>; <span class="comment">// const-evaluated context</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">f</span>(i) + <span class="number">1</span>; <span class="comment">// const-evaluated context due to consteval</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>by default, lambdas are implicitly constexpr if possible</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared = [] (<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x * x; &#125; ;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, squared(5)&gt; a; <span class="comment">// ok, std::array&lt;int, 25&gt;,</span></span><br><span class="line"> <span class="comment">// as squared(5) is constexpr</span></span><br></pre></td></tr></table></figure>
<p>to ensure that a lambda is constexpr, you can declare it as constexpr
after the argument list, before the optional trailing return type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared2 = [] (<span class="keyword">auto</span> x) <span class="keyword">constexpr</span> &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="keyword">auto</span> squared3 = [] (<span class="type">int</span> x) <span class="keyword">constexpr</span> -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x * x; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="template-meta-programming3">Template meta programming3</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Factorial&lt;<span class="number">5</span>&gt;::value; <span class="comment">// computes 5! at compile-time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>&lt;N<span class="number">-1</span>&gt;() + <span class="built_in">fibonacci</span>&lt;N<span class="number">-2</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="built_in">fibonacci</span>&lt;<span class="number">1</span>&gt;() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="built_in">fibonacci</span>&lt;<span class="number">0</span>&gt;() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>&lt;<span class="number">10</span>&gt;() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// computes compile-time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using if constexpr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(N &gt;= <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> fibonacci&lt;N-1&gt;<span class="params">()</span> + fibonacci&lt;N-2&gt;<span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="static-assert">static assert</h4>
<p>checks assertions at compile-time</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span> ( bool_constexpr, message )</span><br><span class="line"><span class="built_in">static_assert</span> ( bool_constexpr )</span><br></pre></td></tr></table></figure>
<h3 id="type-traits">Type traits</h3>
<p>make your own type traits</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsUnsigned</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsUnsigned</span> &lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* add further specializations for all other unsigned types... */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make sure template argument is unsigned </span></span><br><span class="line">    <span class="built_in">static_assert</span>(IsUnsigned&lt;T&gt;::value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>from std:</p>
<ul>
<li><code>std::is_integral, std::is_function, is_lvalue_reference</code></li>
<li><code>is_polymorphic, is_signed, is_aggregate</code></li>
<li><code>is_move_constructible, has_virtual_destructor</code></li>
<li><code>is_same, is_base_of, is_invocable</code></li>
<li><code>remove_const, make_signed, common_type</code></li>
</ul>
<h4 id="enable-if">enable if</h4>
<p>check if T is calcable</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_arithmetic_v&lt;T&gt;,</span><br><span class="line">    <span class="type">bool</span>&gt;::type = <span class="literal">true</span>&gt;</span><br><span class="line">T <span class="built_in">f</span>(T t) &#123; <span class="keyword">return</span> <span class="number">2</span>*t; &#125;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;&gt;&gt;</span><br><span class="line">T <span class="built_in">f</span>(T t) &#123; <span class="keyword">return</span> <span class="number">2</span>*t; &#125;</span><br></pre></td></tr></table></figure>
<p>check if all same type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if passed types are homogeneous</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... TN&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsHomogeneous</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (std::is_same_v&lt;T1,TN&gt; &amp;&amp; ...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if passed parameters have same type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... TN&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">isHomogeneous</span><span class="params">(T1, TN...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::is_same_v&lt;T1,TN&gt; &amp;&amp; ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; IsHomogeneous&lt;<span class="type">int</span>, std::<span class="type">size_t</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// outputs &quot;0\n&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isHomogeneous</span>(<span class="number">43</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// outputs &quot;1\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>using c++20 concept</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">gcd1</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd1</span>(b, a%b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">gcd2</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd2</span>(b, a%b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">gcd3</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd3</span>(b, a%b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::integral <span class="keyword">auto</span> <span class="title">gcd4</span><span class="params">(std::integral <span class="keyword">auto</span> a, std::integral <span class="keyword">auto</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd4</span>(b, a%b); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="expression-template">Expression template</h3>
<ul>
<li>instead of evaluating each intermediate step into a temporary, build
an expression tree</li>
<li>only when assigning the result, perform the actual computation by
traversing the expression tree</li>
<li>also known as lazy evaluation</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> add = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">using</span> mul = <span class="comment">/* ... */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> op, <span class="keyword">typename</span>... operands&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expr</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Expr&lt;add, vector, vector&gt;</span><br><span class="line"><span class="keyword">operator</span>+(<span class="type">const</span> vector&amp; lhs, <span class="type">const</span> vector&amp; rhs);</span><br><span class="line"></span><br><span class="line">Expr&lt;mul, <span class="type">double</span>, vector&gt;</span><br><span class="line"><span class="keyword">operator</span>*(<span class="type">double</span> lhs, <span class="type">const</span> vector&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>then</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all temporaries in one step:</span></span><br><span class="line">Expr&lt;add,</span><br><span class="line">Expr&lt;mul, <span class="type">double</span>, vector&gt;,</span><br><span class="line">Expr&lt;mul, <span class="type">double</span>, vector&gt;&gt; z3 = c1 * x + c2 * y;</span><br><span class="line"><span class="comment">// auto z3 = ...; would be more concise (but hide the expression tree)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all computations done in assignment:</span></span><br><span class="line">vector z = z3;</span><br></pre></td></tr></table></figure>
<p>implementation</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> op, <span class="keyword">typename</span>... operands&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    op callable_;</span><br><span class="line">    std::tuple&lt;<span class="type">const</span> operands&amp;...&gt; args_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Expr</span>(op callable, <span class="type">const</span> operands&amp;... args)</span><br><span class="line">    	: callable_&#123;callable&#125;, args_&#123;args...&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>operator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>*(<span class="type">const</span> LHS&amp; lhs, <span class="type">const</span> RHS&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Expr&#123;</span><br><span class="line">        [] (<span class="keyword">auto</span> <span class="type">const</span>&amp; l, <span class="keyword">auto</span> <span class="type">const</span>&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l * r; &#125;,</span><br><span class="line">        lhs, rhs</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>assginment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> srctype&gt;</span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> srctype&amp; src) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; v_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            v_[i] = src[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>subscript</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> operand&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">subscript</span><span class="params">(<span class="type">const</span> operand&amp; v, <span class="type">unsigned</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_vector_or_expression&lt;operand&gt;)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> op, <span class="keyword">typename</span>... operands&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    op callable_;</span><br><span class="line">    std::tuple&lt;<span class="type">const</span> operands&amp;...&gt; args_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">unsigned</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> call_at_index = </span><br><span class="line">            [<span class="keyword">this</span>, i](<span class="type">const</span> operands&amp;... a) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="built_in">callable_</span>(<span class="built_in">subscript</span>(a,i)...);</span><br><span class="line">        	&#125;;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(call_at_index, args_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>type trais</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_vector</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_vector</span>&lt;vector&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_expression</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> op, <span class="keyword">typename</span>... operands&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_expression</span>&lt;Expr&lt;op, operands...&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_vector_or_expression</span><br><span class="line">	= <span class="built_in">is_vector</span>&lt;T&gt;() || <span class="built_in">is_expression</span>&lt;T&gt;();</span><br></pre></td></tr></table></figure>
<p>more careful</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line">	<span class="built_in">requires</span>(is_binary_op_ok&lt;LHS, RHS&gt;)</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>*(<span class="type">const</span> LHS&amp; lhs, <span class="type">const</span> RHS&amp; rhs) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_arithmetic = std::is_arithmetic_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_binary_op_ok =</span><br><span class="line">	(is_vector_or_expression&lt;LHS&gt; &amp;&amp; is_vector_or_expression&lt;RHS&gt;)</span><br><span class="line">    || (is_vector_or_expression&lt;LHS&gt; &amp;&amp; is_arithmetic&lt;RHS&gt;)</span><br><span class="line">    || (is_arithmetic&lt;LHS&gt; &amp;&amp; is_vector_or_expression&lt;RHS&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="curiously-recurring-template-pattern-crtp">Curiously Recurring
Template Pattern (CRTP)</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>do something</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T&amp; derived = <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// use derived somehow</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>while CRTP works, it is tricky to use and can lead to insidious
errors</p>
<ul>
<li>for example: since there are no virtual functions, there is no
overriding</li>
<li>instead, methods of the same name in the derived class will simply
hide base class methods!</li>
</ul>
<p>anothor example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Constant42</span> : <span class="keyword">public</span> Amount&lt;Constant42&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>in cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> HasValue = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">	&#123; t.<span class="built_in">getValue</span>() &#125; -&gt; std::convertible_to&lt;<span class="type">double</span>&gt;;</span><br><span class="line">&#125;; <span class="comment">// see later for details on concepts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;HasValue T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Amount</span> : <span class="keyword">public</span> T &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="polymorphic-cloneing">polymorphic cloneing</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Cloneable</span>() &#123;&#125; <span class="comment">// required!</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Cloneable&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Cloneable&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">cloneImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cloneable* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> Base&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloneInherit</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Derived&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Derived&gt;(</span><br><span class="line">    	<span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">cloneImpl</span>()));</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CloneInherit* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete</span> : <span class="keyword">public</span> CloneInherit&lt;Concrete, Cloneable&gt; &#123;</span><br><span class="line">    <span class="comment">// nothing to be done!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> c = std::<span class="built_in">make_unique</span>&lt;Concrete&gt;();</span><br><span class="line">    <span class="keyword">auto</span> cc = c-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cc is a &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(cc).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="concept-of-parallel">Concept of parallel</h2>
<p>unsynchronized accesses (data races), deadlocks, and other potential
issues when using threads are undefined behavior!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start a thread that calls foo(123, 456)</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(foo, <span class="number">123</span>, <span class="number">456</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// also works with lambdas</span></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([] &#123; foo(<span class="number">123</span>, <span class="number">456</span>); &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// creates an object that does not refer to an actual thread</span></span><br><span class="line">std::thread t3;</span><br></pre></td></tr></table></figure>
<p>the member function join() is used to wait for a thread to finish</p>
<ul>
<li><p>join() must be called exactly once for each thread!</p></li>
<li><p>if a thread was not joined and the std::thread destructor is
called, the program is terminated</p></li>
</ul>
<p>alternatively, you can call detach() to have the thread execute
independently from its creator</p>
<p>C++20 adds std::jthread, a joining thread</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::jthread <span class="title">t1</span><span class="params">([] &#123; std::cout &lt;&lt; <span class="string">&quot;Hi!\n&quot;</span>; &#125;)</span></span>;</span><br><span class="line"><span class="comment">// automatically joins when going out of scope</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t2</span><span class="params">([] &#123;&#125;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7</span> <span class="comment">// OK, t2 joined when going out of scope</span></span><br></pre></td></tr></table></figure>
<p>additionally it supports interruption signaling via
std::stop_token</p>
<p>std::thread and std::jthread are not copyable, but they can be
moved</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([] &#123; std::cout &lt;&lt; <span class="string">&quot;Hi!\n&quot;</span>; &#125;)</span></span>;</span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">// t1 now empty</span></span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>(); <span class="comment">// OK, joining the thread that started in t1 originally</span></span><br></pre></td></tr></table></figure>
<p>can be used in container</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::thread&gt; threadPool;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	threadPool.<span class="built_in">emplace_back</span>([i] &#123; <span class="built_in">safe_print</span>(i); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threadPool)</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::this_thread::sleep_for()</code> stop the current thread
for a given amount of time</li>
<li><code>std::this_thread::sleep_until()</code> stop the current thread
until a given point in time</li>
<li><code>std::this_thread::yield()</code> let the operating system
schedule another thread</li>
<li><code>std::this_thread::get_id()</code> get the (operating system
specific) id of the current thread</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">interruptible</span><span class="params">([] (std::stop_token stoken) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> counter&#123;<span class="number">0</span>&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// infinite loop</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(<span class="number">0.2</span>s);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (stoken.stop_requested()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;interruptible: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            ++counter;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">    interruptible.<span class="built_in">request_stop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread interrupted the jthread.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mutex">Mutex</h3>
<ul>
<li><code>std::mutex</code> for mutual exclusion</li>
<li><code>std::recursive_mutex</code> for recursive mutual
exclusion</li>
<li><code>std::shared_mutex</code> for mutual exclusion with shared
locks</li>
</ul>
<p>locking</p>
<ul>
<li><code>std::unique_lock</code> for<code>std::mutex</code></li>
<li><code>std::shared_lock</code> for
<code>std::shared_mutex</code></li>
<li><code>std::scoped_loc</code>k for deadlock free locking of several
mutexes</li>
</ul>
<p><code>std::mutex</code> is an exclusive synchronization primitive</p>
<ul>
<li><code>lock()</code> locks the mutex, blocking all other threads</li>
<li><code>unlock()</code>will unlock the mutex</li>
<li><code>try_lock()</code> tries to lock the mutex and returns true if
successful</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::mutex printMutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    printMutex.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    printMutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive mutexes are regular mutexes that additionally allow a
thread that currently holds the mutex to lock it again</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo\n&quot;</span>;</span><br><span class="line">    m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bar\n&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// this will not deadlock!</span></span><br><span class="line">    m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shared mutex</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::shared_mutex m;</span><br><span class="line">std::vector&lt;std::jthread&gt; threadPool;</span><br><span class="line"><span class="comment">// add readers </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    threadPool.<span class="built_in">emplace_back</span>([&amp;]&#123;</span><br><span class="line">       	m.<span class="built_in">lock_shared</span>();</span><br><span class="line">        <span class="built_in">safe_print</span>(value);</span><br><span class="line">        m.<span class="built_in">unlock_shared</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add writers</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    threadPool.<span class="built_in">emplace_back</span>([&amp;]&#123;</span><br><span class="line">       	m.<span class="built_in">lock</span>();</span><br><span class="line">        ++value;</span><br><span class="line">        m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::unique_lock</code> wraps mutexes using RAII</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line"><span class="type">int</span> i&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::jthread t&#123;[&amp;] &#123;</span><br><span class="line">    std::unique_lock l&#123;m&#125;; <span class="comment">// m.lock() is called</span></span><br><span class="line">    ++i;</span><br><span class="line">    <span class="comment">// m.unlock() is called</span></span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>when using multiple mutexes, deadlocks can occur</p>
<p>consistent ordering avoids this</p>
<p>use <code>std::scoped_lock</code> when locking multiple mutexes in
consistent order, to guarantee no deadlocks</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m1, m2, m3;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::scoped_lock l&#123;m1, m2, m3&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::scoped_lock l&#123;m3, m2, m1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="condition">Condition</h3>
<p>condition variables can be used to synchronize threads by waiting
until an (arbitrary) condition becomes true</p>
<ul>
<li><code>wait()</code> : takes a reference to a std::unique_lock that
must be locked by the caller as an argument, unlocks the mutex and waits
for the condition variable</li>
<li><code>notify_one()</code>: notify a single waiting thread, mutex
does not need to be held by the caller</li>
<li><code>notify_all()</code> : notify all waiting threads, mutex does
not need to be held by the caller</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; taskQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushWork</span><span class="params">(<span class="type">int</span> task)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock lck&#123;m&#125;;</span><br><span class="line">        taskQueue.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_lock lck&#123;m&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!taskQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> task = taskQueue.<span class="built_in">back</span>();</span><br><span class="line">            taskQueue.<span class="built_in">pop_back</span>();</span><br><span class="line">            lck.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// ... do actual task here</span></span><br><span class="line">            lck.<span class="built_in">lock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lck,</span><br><span class="line">    		[]&#123; <span class="keyword">return</span> !taskQueue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="atomic">atomic</h3>
<p>threads can also be synchronized with atomic operations that are
usually more efficient than mutexes</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadA</span><span class="params">()</span> </span>&#123; <span class="built_in">atomic_add</span>(a, <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadB</span><span class="params">()</span> </span>&#123; <span class="built_in">atomic_add</span>(a, <span class="number">2</span>); &#125;</span><br></pre></td></tr></table></figure>
<p><code>std::atomic&lt;T&gt;</code> is a class that represents an
atomic version of the type T</p>
<ul>
<li>T load(): loads the value</li>
<li>void store(T desired): stores desired in the object</li>
<li>T exchange(T desired): stores desired in the object and returns the
old value</li>
</ul>
<p>if T is an integral type, the following operations also exist:</p>
<ul>
<li><code>T fetch_add(T arg)</code>: adds arg to the value and returns
the old value</li>
<li><code>T operator+=(T arg)</code>: add arg to the value and returns
the new value</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; i&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i += <span class="number">1</span>; <span class="comment">// (A)</span></span><br><span class="line">    i -= <span class="number">1</span>; <span class="comment">// (B)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> iLocal = i.<span class="built_in">load</span>();</span><br><span class="line">    <span class="built_in">assert</span>(iLocal == <span class="number">0</span> || iLocal == <span class="number">1</span>); <span class="comment">// always true!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy and ref</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>&amp; ref = val;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">notReallyRef</span><span class="params">(ref)</span></span>;</span><br><span class="line"><span class="function">std::atomic_ref&lt;<span class="type">int</span>&gt; <span class="title">atomicRef</span><span class="params">(ref)</span></span>;</span><br><span class="line">++notReallyRef; <span class="comment">// will increment only the internal copy of ref</span></span><br><span class="line">++atomicRef; <span class="comment">// will actually increment the referenced variable</span></span><br><span class="line">++atomicRef;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ref: &quot;</span> &lt;&lt; ref &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;notReallyRef: &quot;</span> &lt;&lt; notReallyRef.<span class="built_in">load</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;atomicRef: &quot;</span> &lt;&lt; atomicRef.<span class="built_in">load</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>std::atomic_flag provides an atomic boolean with a special
interface,it is guaranteed to be lock-free</p>
<ul>
<li>true by calling<code>test_and_set()</code></li>
<li>false by calling <code>clear()</code></li>
</ul>
<p><code>test()</code> returns the current value</p>
<h3 id="stl-algo">STL algo</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// standard sequential sort</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequential execution</span></span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::seq, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// permitting parallel execution</span></span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::par, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// permitting parallel execution and vectorized execution</span></span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::unseq, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>C++20 introduced many more parallel programming features</p>
<ul>
<li>coroutines，counting semaphores for shared resources，latches and
barriers to coordinate threads</li>
</ul>
<h2 id="c20-concept">C++20 concept</h2>
<p>concepts allow</p>
<ul>
<li>specifying requirements for template parameters</li>
<li>overloading of functions</li>
<li>specialization of class templates</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gcd1</span><span class="params">(T a, T b)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>with a trailing requires clause:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gcd2</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>using a constrained template parameter:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gcd3</span><span class="params">(T a, T b)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>using an abbreviated function template:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gcd4</span><span class="params">(std::integral <span class="keyword">auto</span> a, std::integral <span class="keyword">auto</span> b)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>basically anywhere you can put auto, you can put
<code>&lt;concept&gt;auto</code> instead</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Val&gt;</span><br><span class="line"> 	<span class="keyword">requires</span> std::input_iterator&lt;Iter&gt;</span><br><span class="line">		  &amp;&amp; std::equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;</span><br><span class="line"><span class="function">Iter <span class="title">find</span><span class="params">(Iter b, Iter e, Val v)</span></span>;</span><br></pre></td></tr></table></figure>
<p>predefined concept</p>
<ul>
<li>same_as, derived_from, convertible_to, assignable_from,
swappable</li>
<li>integral, signed_integral, unsigned_integral, floating_point</li>
<li>destructible, constructible_from, default_constructible,
move_constructible, copy_constructible</li>
<li>equality_comparable, totally_ordered</li>
<li>movable, copyable, semi_regular, regular</li>
</ul>
<h3 id="own-concept">own concept</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>-parameter-list&gt;</span><br><span class="line"><span class="keyword">concept</span> <span class="keyword">concept</span>-name = constraint-expression;</span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> SignedIntegral = Integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;</span><br></pre></td></tr></table></figure>
<p>requirer expression</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span> (T a, T b) &#123;</span><br><span class="line">	a + b; <span class="comment">// two objects of type T can be added</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>type requirement</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> TypeRequirement = <span class="keyword">requires</span> &#123;</span><br><span class="line">    <span class="keyword">typename</span> T::value_type; <span class="comment">// T has nested member value_type</span></span><br><span class="line">    <span class="keyword">typename</span> Other&lt;T&gt;; <span class="comment">// Other can be instantiated with T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>compound req</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Equal = <span class="built_in">requires</span> (T a, T b) &#123;</span><br><span class="line">    &#123; a == b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">    &#123; a != b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>use if</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">First</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">2020</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Second</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">2021</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumberOfElements</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">requires</span>(T t) &#123; &#123; t.count() &#125; -&gt; std::convertible_to&lt;<span class="type">int</span>&gt;; &#125;)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">return</span> t.<span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">requires</span>(T t) &#123; &#123; t.size() &#125; -&gt; std::convertible_to&lt;<span class="type">int</span>&gt;; &#125;)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">return</span> t.<span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="short-exercise">Short Exercise</h2>
<ol type="1">
<li><p>write a function translate parameters to a vector, or
set</p></li>
<li><p>use functional programming get primes less than
<code>200</code></p></li>
<li><p>how to init Vector with
<code>Vector&lt;double&gt; v1&#123;1,3,4,5&#125;;</code></p></li>
<li><p>use variant to model a mixture of plus lambda and multiply
lambda. evaluate arithmetic expression</p></li>
<li><p>use varidic template implement addition of arbitary
vector</p></li>
</ol>
<h3 id="oop">OOP</h3>
<ol type="1">
<li>implement Polymorphic cloning demo</li>
<li>Use shared pointer implement segment tree</li>
<li>implement difference array and copy, extend normal array</li>
<li>implement Graph, Tree, structure. find depth in complie time,given
tree</li>
<li>use CRPT , implment polymorhpy</li>
</ol>
<h3 id="concept">Concept</h3>
<ol type="1">
<li>A gcd function, require the arguments to be equal and integral, 2
methods,Type traits</li>
</ol>
<h3 id="parallel-programming">Parallel programming</h3>
<ol type="1">
<li>compute matrix multiplication, use worker and await</li>
<li>A txt file contains a password <code>&lt;10000</code> use a thread
to set a passswd randomly and use multithread clients to crack the
password</li>
</ol>
<h3 id="compile-time">Compile time</h3>
<ol type="1">
<li>use expression template to implement vector and scalar
multiplication</li>
</ol>
<h1 id="现代c-volum2">现代C++ Volum2</h1>
<h2 id="solid-principles">SOLID principles</h2>
<table>
<thead>
<tr class="header">
<th>缩写</th>
<th>原则名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S</td>
<td><strong>Single Responsibility Principle (SRP)</strong></td>
<td>单一职责原则</td>
</tr>
<tr class="even">
<td>O</td>
<td><strong>Open/Closed Principle (OCP)</strong></td>
<td>开闭原则</td>
</tr>
<tr class="odd">
<td>L</td>
<td><strong>Liskov Substitution Principle (LSP)</strong></td>
<td>里氏替换原则</td>
</tr>
<tr class="even">
<td>I</td>
<td><strong>Interface Segregation Principle (ISP)</strong></td>
<td>接口隔离原则</td>
</tr>
<tr class="odd">
<td>D</td>
<td><strong>Dependency Inversion Principle (DIP)</strong></td>
<td>依赖倒置原则</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="single-responsibility-principle-单一职责原则">1. Single
Responsibility Principle （<strong>单一职责原则</strong>）</h3>
<blockquote>
<p>一个类应该只有一个引起它变化的原因。</p>
</blockquote>
<ul>
<li>每个类、模块只负责一个功能。</li>
<li>避免“上帝类” —— 什么都做，什么都知道。</li>
<li><strong>好处</strong>：高内聚，易于修改和测试。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑// ✅ 正确做法</span><br><span class="line">class ReportGenerator &#123; void generate() &#123;...&#125; &#125;</span><br><span class="line">class ReportPrinter &#123; void print() &#123;...&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑// ❌ 错误做法：职责混杂</span><br><span class="line">class ReportManager &#123;</span><br><span class="line">    void generate() &#123;...&#125;</span><br><span class="line">    void print() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="openclosed-principle-开闭原则">2. Open/Closed Principle
（<strong>开闭原则</strong>）</h3>
<blockquote>
<p>软件实体应对扩展开放，对修改关闭。</p>
</blockquote>
<ul>
<li>意味着你应该<strong>通过扩展功能而非修改已有代码来改变行为</strong>。</li>
<li>通常通过 <strong>抽象类或接口 + 多态</strong> 实现。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑interface Shape &#123; double area(); &#125;</span><br><span class="line"></span><br><span class="line">class Circle implements Shape &#123; ... &#125;</span><br><span class="line">class Rectangle implements Shape &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// ✅ 添加新形状无需修改旧代码，只需新增类。</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="liskov-substitution-principle-里氏替换原则">3. Liskov
Substitution Principle （<strong>里氏替换原则</strong>）</h3>
<blockquote>
<p>子类必须能够替换其父类，并确保行为一致。</p>
</blockquote>
<ul>
<li>子类不应破坏父类原有的功能。</li>
<li>若用子类替代父类导致程序错误，那就违反了该原则。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑class Bird &#123; void fly(); &#125;</span><br><span class="line">class Ostrich extends Bird &#123; void fly() &#123; throw new Exception(); &#125; &#125; // ❌ 不应该</span><br><span class="line"></span><br><span class="line">// ✅ 解决方法：重新设计层次结构，分出能飞和不能飞的鸟</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="interface-segregation-principle-接口隔离原则">4. Interface
Segregation Principle （<strong>接口隔离原则</strong>）</h3>
<blockquote>
<p>不应该强迫用户依赖它们不使用的方法。</p>
</blockquote>
<ul>
<li><strong>将大接口拆分成更小、更专一的接口</strong>，让类只实现自己需要的功能。</li>
<li>避免“胖接口”（God Interface）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑interface Printer &#123; void print(); &#125;</span><br><span class="line">interface Scanner &#123; void scan(); &#125;</span><br><span class="line"></span><br><span class="line">class SimplePrinter implements Printer &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="dependency-inversion-principle-依赖倒置原则">5. Dependency
Inversion Principle （<strong>依赖倒置原则</strong>）</h3>
<blockquote>
<p>高层模块不应该依赖低层模块，二者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。</p>
</blockquote>
<ul>
<li>通过依赖接口（抽象），而不是依赖具体实现。</li>
<li>使用 <strong>依赖注入（Dependency Injection）</strong>
是该原则的体现。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑// ✅ 高层模块依赖接口，而不是具体类</span><br><span class="line">interface MessageSender &#123; void send(); &#125;</span><br><span class="line"></span><br><span class="line">class EmailSender implements MessageSender &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">class Notification &#123;</span><br><span class="line">    private MessageSender sender;</span><br><span class="line">    public Notification(MessageSender sender) &#123; this.sender = sender; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://fyind.de">Fyind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://fyind.de/2023/10/19/%E7%8E%B0%E4%BB%A3C/">http://fyind.de/2023/10/19/%E7%8E%B0%E4%BB%A3C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/pic1.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/02/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%89%E5%85%A8/" title="嵌入式系统和安全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">嵌入式系统和安全</div></div><div class="info-2"><div class="info-item-1">嵌入式系统和安全 Introduction Four requirements for embedded system  Efficiency, function,dependability, security  Relationship between Dependability and security Difference between security and safety Goal of lecture   Being able to design secure embedded systems Assess and choose appropriate measures to secure an embedded system Implement given tasks on an embedded system (done) Use toolchains for cross-platform development Discuss memory organization Classify different types of on-chip memory Reca...</div></div></div></a><a class="pagination-related" href="/2023/06/23/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/" title="二项式反演"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">二项式反演</div></div><div class="info-2"><div class="info-item-1">二项式反演 对于某些问题，比较容易计算  钦定 \(k\) 个位置的可能性  而比较难计算  有 \(k\) 个位置的可能性  这个时候可以用二项式反演对问题进行转化 形式2 一共有 \(n\) 个元素，设 \(f(k)\) 是钦定 \(k\) 个元素的方法数，\(g(k)\) 是恰好选 \(k\) 个元素的方法数，那么有如下关系 \[ f(k) =\sum_{i=k}^n\left(\begin{array}{l}i \\k\end{array}\right) g(i) \Leftrightarrow g(k) = \sum_{i=k}^n (-1)^{i-k}\left(\begin{array}{l}i \\k\end{array}\right) f(i) \] 每个 \(g(i)\) 有 \(\left(\begin{array}{l}i \\k\end{array}\right)\) 种钦定方法 例子 \((a,b,c,d)\) 中求 \(f(2)\) 和 \(g(2)\) 钦定 \((a,b)\) , \((a,c)\), \((a,d)\) , \((b,c)\) ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fyind</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fyind"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Fyind" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tarjan0025@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=d0kMY0nN" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来逛逛我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3c%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">现代c++编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">1.0.1.</span> <span class="toc-text">编译和运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.2.</span> <span class="toc-text">头文件和源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#odr"><span class="toc-number">1.0.3.</span> <span class="toc-text">ODR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#head-guards"><span class="toc-number">1.0.4.</span> <span class="toc-text">Head guards</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#modules-doesnt-work-yet"><span class="toc-number">1.0.5.</span> <span class="toc-text">modules (doesn’t work yet)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmake"><span class="toc-number">1.0.6.</span> <span class="toc-text">CMake</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-basic"><span class="toc-number">1.1.</span> <span class="toc-text">C++ Basic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#types-and-built-in-types"><span class="toc-number">1.1.1.</span> <span class="toc-text">Types and built-in types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initialization"><span class="toc-number">1.1.2.</span> <span class="toc-text">Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type-alias"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Type Alias</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scope"><span class="toc-number">1.1.3.</span> <span class="toc-text">Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lifetime"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Lifetime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">1.1.4.</span> <span class="toc-text">Auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-and-vector"><span class="toc-number">1.1.5.</span> <span class="toc-text">Array and Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop"><span class="toc-number">1.1.6.</span> <span class="toc-text">Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lvalue-and-rvalue"><span class="toc-number">1.1.7.</span> <span class="toc-text">lvalue and rvalue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lvalue"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">lvalue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rvalue"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">rvalue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#increment"><span class="toc-number">1.1.8.</span> <span class="toc-text">Increment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#precedence"><span class="toc-number">1.1.9.</span> <span class="toc-text">Precedence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-switch"><span class="toc-number">1.1.10.</span> <span class="toc-text">if, switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reference"><span class="toc-number">1.1.11.</span> <span class="toc-text">Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dangling-references"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">Dangling references</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#converting"><span class="toc-number">1.1.12.</span> <span class="toc-text">Converting</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function"><span class="toc-number">1.2.</span> <span class="toc-text">Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#structured-binding"><span class="toc-number">1.2.1.</span> <span class="toc-text">Structured Binding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parameter-passing"><span class="toc-number">1.2.2.</span> <span class="toc-text">Parameter passing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overloading"><span class="toc-number">1.2.3.</span> <span class="toc-text">Overloading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#criteria"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Criteria</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#functors"><span class="toc-number">1.2.4.</span> <span class="toc-text">Functors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda"><span class="toc-number">1.2.5.</span> <span class="toc-text">Lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#storing-lambda"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">Storing lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capture"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">Capture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exception"><span class="toc-number">1.2.6.</span> <span class="toc-text">Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#no-except"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">No except</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expected"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">expected</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl"><span class="toc-number">1.3.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#optional"><span class="toc-number">1.3.1.</span> <span class="toc-text">optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monadic-operations"><span class="toc-number">1.3.2.</span> <span class="toc-text">monadic operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pair"><span class="toc-number">1.3.3.</span> <span class="toc-text">Pair</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#structure-binding"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">structure binding</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#variant"><span class="toc-number">1.3.4.</span> <span class="toc-text">variant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.3.5.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string-view"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">string view</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#container"><span class="toc-number">1.3.6.</span> <span class="toc-text">Container</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#other"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">Other</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered_map"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">unordered_map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-set"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">unordered set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-safety"><span class="toc-number">1.3.6.6.</span> <span class="toc-text">Thread safety</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iterator"><span class="toc-number">1.3.6.7.</span> <span class="toc-text">Iterator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ranges"><span class="toc-number">1.3.7.</span> <span class="toc-text">Ranges</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#algorithm"><span class="toc-number">1.3.8.</span> <span class="toc-text">Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#searching"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">Searching</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unsorted"><span class="toc-number">1.3.8.1.1.</span> <span class="toc-text">unsorted:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sorted"><span class="toc-number">1.3.8.1.2.</span> <span class="toc-text">sorted</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permutation"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">Permutation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more-feature"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">More feature</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream-and-io"><span class="toc-number">1.3.9.</span> <span class="toc-text">Stream and IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#input-stream"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">input stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#output-stream"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">output stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringstream"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">stringstream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filestream"><span class="toc-number">1.3.9.4.</span> <span class="toc-text">filestream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#caveats-of-streams"><span class="toc-number">1.3.9.5.</span> <span class="toc-text">Caveats of streams</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-oriented-programming"><span class="toc-number">1.4.</span> <span class="toc-text">Object-oriented Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#access"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">Access</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class"><span class="toc-number">1.4.1.</span> <span class="toc-text">class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#friend"><span class="toc-number">1.4.2.</span> <span class="toc-text">Friend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-correctness"><span class="toc-number">1.4.3.</span> <span class="toc-text">const correctness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-qualifier"><span class="toc-number">1.4.4.</span> <span class="toc-text">Ref qualifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-class-member"><span class="toc-number">1.4.5.</span> <span class="toc-text">Static class member</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constroctor-and-deconstructor"><span class="toc-number">1.4.6.</span> <span class="toc-text">Constroctor and
deconstructor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-constructorr"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">Copy constructorr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deconstructor"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">deconstructor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator-overloading"><span class="toc-number">1.4.7.</span> <span class="toc-text">Operator overloading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#conversions"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">conversions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#argument-dependent-lookup"><span class="toc-number">1.4.8.</span> <span class="toc-text">Argument-dependent lookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum-class"><span class="toc-number">1.4.9.</span> <span class="toc-text">Enum class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raii---resource-acquisition-is-initialization"><span class="toc-number">1.5.</span> <span class="toc-text">RAII - Resource
Acquisition is Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-semantics"><span class="toc-number">1.5.1.</span> <span class="toc-text">Copy semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-constructor"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Copy constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-assignment"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Copy assignment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#the-rule-of-three"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">The Rule of Three</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-semantics"><span class="toc-number">1.5.2.</span> <span class="toc-text">Move Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#move-constructor"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">move constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#move-assignment"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">Move assignment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-and-swap"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">Copy and swap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-elisionlvalue-rvalue"><span class="toc-number">1.5.3.</span> <span class="toc-text">Copy elision(lvalue, rvalue)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ownership-semantics"><span class="toc-number">1.5.4.</span> <span class="toc-text">Ownership semantics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smart-pointer"><span class="toc-number">1.5.5.</span> <span class="toc-text">Smart pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-pointer"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">unique pointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-pointer"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">shared pointer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oop2"><span class="toc-number">1.6.</span> <span class="toc-text">OOP2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#derived-class"><span class="toc-number">1.6.1.</span> <span class="toc-text">Derived Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deconstructor-1"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">deconstructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qualified-look-up"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">qualified look up</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inheritance-mode"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">inheritance mode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual-function-and-polymorphy"><span class="toc-number">1.6.2.</span> <span class="toc-text">Virtual function and
polymorphy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual-function"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">virtual function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual-deconstructor"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">Virtual deconstructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slicing"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">Slicing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#convert"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">convert</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pure-virtual-function"><span class="toc-number">1.6.3.</span> <span class="toc-text">Pure virtual function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-from-this"><span class="toc-number">1.6.4.</span> <span class="toc-text">shared from this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concept-of-generic-programming"><span class="toc-number">1.7.</span> <span class="toc-text">Concept of generic
programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#template-instantiation"><span class="toc-number">1.7.1.</span> <span class="toc-text">template instantiation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#out-of-line-definition"><span class="toc-number">1.7.2.</span> <span class="toc-text">Out of line definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#disambiguator"><span class="toc-number">1.7.3.</span> <span class="toc-text">Disambiguator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reference-collapsing"><span class="toc-number">1.7.4.</span> <span class="toc-text">reference collapsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-specialization"><span class="toc-number">1.7.5.</span> <span class="toc-text">Template specialization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#partial-specialization"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">Partial specialization</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-argument-deduction"><span class="toc-number">1.7.6.</span> <span class="toc-text">Template argument deduction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-1"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-lambda"><span class="toc-number">1.7.7.</span> <span class="toc-text">template lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parameter-pack"><span class="toc-number">1.7.8.</span> <span class="toc-text">Parameter pack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fold-expression"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">fold expression</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compile-time-programming"><span class="toc-number">1.8.</span> <span class="toc-text">Compile-time programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#function-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">if</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-meta-programming3"><span class="toc-number">1.8.2.</span> <span class="toc-text">Template meta programming3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-assert"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">static assert</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-traits"><span class="toc-number">1.8.3.</span> <span class="toc-text">Type traits</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enable-if"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">enable if</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expression-template"><span class="toc-number">1.8.4.</span> <span class="toc-text">Expression template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#curiously-recurring-template-pattern-crtp"><span class="toc-number">1.8.5.</span> <span class="toc-text">Curiously Recurring
Template Pattern (CRTP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#polymorphic-cloneing"><span class="toc-number">1.8.6.</span> <span class="toc-text">polymorphic cloneing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concept-of-parallel"><span class="toc-number">1.9.</span> <span class="toc-text">Concept of parallel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex"><span class="toc-number">1.9.1.</span> <span class="toc-text">Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition"><span class="toc-number">1.9.2.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic"><span class="toc-number">1.9.3.</span> <span class="toc-text">atomic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stl-algo"><span class="toc-number">1.9.4.</span> <span class="toc-text">STL algo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c20-concept"><span class="toc-number">1.10.</span> <span class="toc-text">C++20 concept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#own-concept"><span class="toc-number">1.10.1.</span> <span class="toc-text">own concept</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#short-exercise"><span class="toc-number">1.11.</span> <span class="toc-text">Short Exercise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#oop"><span class="toc-number">1.11.1.</span> <span class="toc-text">OOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concept"><span class="toc-number">1.11.2.</span> <span class="toc-text">Concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parallel-programming"><span class="toc-number">1.11.3.</span> <span class="toc-text">Parallel programming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compile-time"><span class="toc-number">1.11.4.</span> <span class="toc-text">Compile time</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3c-volum2"><span class="toc-number">2.</span> <span class="toc-text">现代C++ Volum2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#solid-principles"><span class="toc-number">2.1.</span> <span class="toc-text">SOLID principles</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#single-responsibility-principle-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. Single
Responsibility Principle （单一职责原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#openclosed-principle-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. Open&#x2F;Closed Principle
（开闭原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#liskov-substitution-principle-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. Liskov
Substitution Principle （里氏替换原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-segregation-principle-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. Interface
Segregation Principle （接口隔离原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dependency-inversion-principle-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. Dependency
Inversion Principle （依赖倒置原则）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程">C++高性能编程</a><time datetime="2025-07-17T19:47:19.000Z" title="Created 2025-07-17 19:47:19">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="操作系统概念">操作系统概念</a><time datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置">Kubuntu配置</a><time datetime="2025-07-15T05:25:37.000Z" title="Created 2025-07-15 05:25:37">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E6%88%91%E4%BB%AC%E5%9C%A8AI%E6%97%B6%E4%BB%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/" title="我们在AI时代该如何学习">我们在AI时代该如何学习</a><time datetime="2025-07-12T23:12:19.000Z" title="Created 2025-07-12 23:12:19">2025-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CA-Top-Down-Approach/" title="计算机网络A Top Down Approach">计算机网络A Top Down Approach</a><time datetime="2025-07-12T22:02:58.000Z" title="Created 2025-07-12 22:02:58">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fyind</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>