<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高效算法II | Fyind's Blog</title><meta name="author" content="Fyind"><meta name="copyright" content="Fyind"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高效算法II 线性规划(LP) Standard Form input: number \(a_{ij},c_j,b_j\) output: numbers \(x_j\) \(n &#x3D; \#decision variables, m&#x3D;\#conatrains\) \(\begin{aligned} &amp; \max \sum_{j&#x3D;1}^n c_j x_j \\ &amp; \text { s">
<meta property="og:type" content="article">
<meta property="og:title" content="高效算法II">
<meta property="og:url" content="http://fyind.de/2023/04/19/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95II/index.html">
<meta property="og:site_name" content="Fyind&#39;s Blog">
<meta property="og:description" content="高效算法II 线性规划(LP) Standard Form input: number \(a_{ij},c_j,b_j\) output: numbers \(x_j\) \(n &#x3D; \#decision variables, m&#x3D;\#conatrains\) \(\begin{aligned} &amp; \max \sum_{j&#x3D;1}^n c_j x_j \\ &amp; \text { s">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://fyind.de/img/pic1.PNG">
<meta property="article:published_time" content="2023-04-19T21:01:51.000Z">
<meta property="article:modified_time" content="2025-07-18T10:49:53.884Z">
<meta property="article:author" content="Fyind">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="线性规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyind.de/img/pic1.PNG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "高效算法II",
  "url": "http://fyind.de/2023/04/19/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95II/",
  "image": "http://fyind.de/img/pic1.PNG",
  "datePublished": "2023-04-19T21:01:51.000Z",
  "dateModified": "2025-07-18T10:49:53.884Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fyind",
      "url": "http://fyind.de"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pic1.PNG"><link rel="canonical" href="http://fyind.de/2023/04/19/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95II/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高效算法II',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://fyindex.work/PicGo/liuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yae.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Fyind's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">高效算法II</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">高效算法II</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-19T21:01:51.000Z" title="Created 2023-04-19 21:01:51">2023-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-18T10:49:53.884Z" title="Updated 2025-07-18 10:49:53">2025-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TUM%E7%AC%94%E8%AE%B0/">TUM笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="高效算法ii">高效算法II</h1>
<h2 id="线性规划lp">线性规划(LP)</h2>
<h3 id="standard-form">Standard Form</h3>
<p>input: number <span class="math inline">\(a_{ij},c_j,b_j\)</span></p>
<p>output: numbers <span class="math inline">\(x_j\)</span></p>
<p><span class="math inline">\(n = \#decision variables,
m=\#conatrains\)</span></p>
<p><span class="math inline">\(\begin{aligned} &amp; \max \sum_{j=1}^n
c_j x_j \\ &amp; \text { s.t. } \sum_{j=1}^n a_{i j} x_j=b_i \quad 1
\leq i \leq m \\ &amp; x_j \geq 0 \quad 1 \leq j \leq n \\ &amp;
\end{aligned}\)</span></p>
<p>也可以用矩阵的写法</p>
<p><span class="math inline">\(\begin{array}{rr}\max &amp; c^T x \\
\text { s.t. } \quad A x=b \\ &amp; x \geq 0\end{array}\)</span></p>
<h4 id="转换成standard-form">转换成Standard Form</h4>
<ul>
<li><p>小于等于</p>
<p><span class="math inline">\(a-3b+5c\le 12\)</span> 变成 <span
class="math inline">\(a-3b+5c+s=12,s \ge 0\)</span></p></li>
<li><p>大于等于</p>
<p><span class="math inline">\(a-3b+5c\ge 12\)</span> 变成 <span
class="math inline">\(a-3b+5c-s=12,s \ge 0\)</span></p></li>
<li><p>min to max:</p>
<p><span class="math inline">\(\min a-3b+5c\)</span> 变成 <span
class="math inline">\(\max -a+4b-5c\)</span></p></li>
</ul>
<p>我们也可以从 Standard Form 变成小于等于或者大于等于</p>
<p><span class="math inline">\(a-3b+5c=12\)</span> 变成</p>
<ul>
<li><span class="math inline">\(a-3b+5c\le 12\)</span></li>
<li><span class="math inline">\(-a+3b-5c\le12\)</span></li>
</ul>
<p>如果 <span class="math inline">\(x\)</span> 要求无限制</p>
<ul>
<li><span class="math inline">\(x=x^+-x^-,x^+\ge0,x^-\ge0\)</span></li>
</ul>
<h3 id="定义1-线性规划lp">定义1 线性规划(LP)</h3>
<blockquote>
<p>设 <span class="math inline">\(A \in \mathbb{Q}^{m \times n}, b \in
\mathbb{Q}^m, c \in \mathbb{Q}^n, \alpha \in \mathbb{Q}\)</span> ,
是否存在 <span class="math inline">\(x \in \mathbb{Q}^n\)</span> 使得
<span class="math inline">\(A x=b, x \geq 0, c^T x \geq
\alpha\)</span></p>
</blockquote>
<p>插入一段复习：</p>
<blockquote>
<p>NP问题和co-NP问题:</p>
<p>Given a solution to an NP problem, the “yes” solution can be verified
in polynomial time.</p>
<p>A problem is in co-NP if its “no” instances can be verified in
polynomial time.</p>
<p>一般问题要么是P要么是NP-complete,
而NP和co-NP的交集是包含P不包含NP-complete的</p>
</blockquote>
<p>有下列问题</p>
<ul>
<li><p>Is LP in NP?</p>
<details>
<summary>
<p>answer</p>
</summary>
<p>Yes. 因为给定 <span class="math inline">\(B\)</span> 我们可以计算
associated basic solution <span class="math inline">\(A_B^{-1}
b\)</span> 在多项式复杂度. 答案肯定是有理数，不是无理数.</p>
</details></li>
<li><p>Is LP in co-NP?</p>
<details>
<summary>
<p>answer</p>
</summary>
<p>Yes. 因为反例也可以快速代入验证</p>
</details></li>
<li><p>Is LP in P?</p>
<details>
<summary>
<p>answer</p>
</summary>
<p>Yes.</p>
</details></li>
</ul>
<h3 id="一些基本定义">一些基本定义</h3>
<p>对于一个Standard Form 的 LP: <span class="math inline">\(P=\{x \mid A
x=b, x \geq 0\}\)</span></p>
<ul>
<li><span class="math inline">\(P\)</span> 是 feasible region</li>
<li>A point <span class="math inline">\(x\in P\)</span> is feasible
point</li>
<li>若 <span class="math inline">\(P\ne \emptyset\)</span> 那么 LP 是
feasible的，否则就 infeasible</li>
<li>LP 是 bounded 若它是feasible且答案不会到无穷大</li>
</ul>
<h4 id="定义2-linear-combination">定义2 linear combination</h4>
<p>对于vector <span class="math inline">\(x_1, \ldots, x_k \in
\mathbb{R}^n, \sum \lambda_i x_i\)</span> 是</p>
<ul>
<li>linear combination, 若 <span class="math inline">\(\lambda_i \in
\mathbb{R}\)</span></li>
<li>affine combination, 若 <span class="math inline">\(\lambda_i \in
\mathbb{R}, \sum_i \lambda_i = 1\)</span>，是直线</li>
<li>convex combination, 若 <span class="math inline">\(\lambda_i \in
\mathbb{R}, \sum_i \lambda_i = 1, \lambda_i \ge 0\)</span>， 是线段</li>
<li>conic combination, 若 <span class="math inline">\(\lambda_i \in
\mathbb{R}, \lambda_i \ge 0\)</span>, 是一个cone</li>
</ul>
<p>可以画图理解它们</p>
<h4 id="定义3-linear-space">定义3 Linear space</h4>
<p>集合 $X ^n $</p>
<ul>
<li>linear space 若 closed under linear combination</li>
<li>affine space 若 closed under affine combination</li>
<li>convex 若 closed under convex combination</li>
<li>convex cone 若 closed under conic combination</li>
</ul>
<p>注意，affine space 不是 vector space</p>
<h4 id="定义4-span">定义4 span</h4>
<p>对于 <span class="math inline">\(X \in \mathbb{R}^n\)</span></p>
<ul>
<li><span class="math inline">\(span(X)\)</span> 是 <span
class="math inline">\(X\)</span> 中 linear combination 的集合 (linear
hull)</li>
<li><span class="math inline">\(aff(X)\)</span>是 <span
class="math inline">\(X\)</span> 中 affine combination 的集合 (affine
hull)</li>
<li><span class="math inline">\(conv(X)\)</span>是 <span
class="math inline">\(X\)</span> 中 convex combination 的集合 (convex
hull)</li>
<li><span class="math inline">\(cone(X)\)</span>是 <span
class="math inline">\(X\)</span> 中 conic combination 的集合 (coinc
hull)</li>
</ul>
<h4 id="定义-5-convex-function">定义 5 convex function</h4>
<p>一个函数 <span class="math inline">\(f: \mathbb{R}^n \rightarrow
\mathbb{R}\)</span> 是 convex 若对于 <span class="math inline">\(x,y\in
\mathbb{R}^n\)</span> 和 <span class="math inline">\(\lambda \in
[0,1]\)</span> 有</p>
<p><span class="math display">\[
f(\lambda x+(1-\lambda) y) \leq \lambda f(x)+(1-\lambda) f(y)
\]</span></p>
<h4 id="lemma-6-convex-p">Lemma 6 convex P</h4>
<p>若 <span class="math inline">\(P\subseteq \mathbb{R}^n\)</span> 且
<span class="math inline">\(f: \mathbb{R}^n \rightarrow
\mathbb{R}\)</span> 是convex，那么下面也是</p>
<p><span class="math display">\[
Q=\{x \in P \mid f(x) \leq t\}
\]</span></p>
<blockquote>
<p>?</p>
</blockquote>
<h4 id="定义-7-affine-subspace">定义 7 affine subspace</h4>
<p>affine subspace <span class="math inline">\(A\)</span> 的 <span
class="math inline">\(\dim(A)\)</span> 是 vector space <span
class="math inline">\(\{x-a|x\in A\}\)</span> 的维度</p>
<h4 id="定义-8-convex-set">定义 8 convex set</h4>
<p>convex set <span class="math inline">\(X\)</span> 的 <span
class="math inline">\(\dim(X)\)</span> 是它的 affine hull <span
class="math inline">\(aff(X)\)</span> 的维度</p>
<h4 id="定义-9-hyperplane">定义 9 hyperplane</h4>
<p>集合 <span class="math inline">\(H\subseteq \mathbb{R}^n\)</span> 是
hyperplane 若 <span class="math inline">\(H=\left\{x \mid a^T
x=b\right\}\)</span>, for <span class="math inline">\(a \neq
0\)</span>.</p>
<h4 id="定义-10-halfspace">定义 10 halfspace</h4>
<p>集合 <span class="math inline">\(H&#39;\subseteq
\mathbb{R}^n\)</span> 是 (closed) halfspace 若 if <span
class="math inline">\(H=\left\{x \mid a^T x \leq b\right\}\)</span>, for
<span class="math inline">\(a\ne 0\)</span>.</p>
<h4 id="定义-11-polytop">定义 11 polytop</h4>
<p>Polytop <span class="math inline">\(P\subseteq \mathbb{R}^n\)</span>
是 有限点的 convex hull 的集合 <span class="math inline">\(P =
conv(X)\)</span></p>
<h4 id="定义-12-polyhedron">定义 12 Polyhedron</h4>
<p>Polyhedron是 有限 half-spaces 的交集 <span
class="math inline">\(\left\{H\left(a_1, b_1\right), \ldots, H\left(a_m,
b_m\right)\right\}\)</span> 其中，</p>
<p><span class="math display">\[
H\left(a_i, b_i\right)=\left\{x \in \mathbb{R}^n \mid a_i x \leq
b_i\right\}
\]</span></p>
<h4 id="定义-13-bounded-polyhedron">定义 13 Bounded Polyhedron</h4>
<p>一个 Polyhedron 是 bounded 若存在 <span
class="math inline">\(B\)</span> 使得 <span
class="math inline">\(\forall x\in P. \|x\|_2 \leq B\)</span></p>
<h4 id="定理-14-polytop-and-polyhedron">定理 14 polytop and
polyhedron</h4>
<p><span class="math inline">\(P\)</span> is a bounded polyhedron iff
<span class="math inline">\(P\)</span> is a Polytop.</p>
<blockquote>
<p>?</p>
</blockquote>
<h4 id="定义-15-supporting-hyperplane">定义 15 supporting
hyperplane</h4>
<p>设 <span class="math inline">\(P\subseteq \mathbb{R}^n,a\in
\mathbb{R}^n,b\in \mathbb{R}\)</span> 那么 hyperplane</p>
<p><span class="math display">\[
H(a, b)=\left\{x \in \mathbb{R}^n \mid a^T x=b\right\}
\]</span></p>
<p>是 <span class="math inline">\(P\)</span> 的 supporting hyperplane 若
<span class="math inline">\(\max \left\{a^T x \mid x \in
P\right\}=b\)</span></p>
<blockquote>
<p>如果不是的话, <span class="math inline">\(\max{a^Tx}\)</span>
要么小于 <span class="math inline">\(b\)</span> 要么大于 <span
class="math inline">\(b\)</span> 不会等于 <span
class="math inline">\(b\)</span></p>
</blockquote>
<h4 id="定义-16-face">定义 16 Face</h4>
<p>设 <span class="math inline">\(P\subseteq \mathbb{R}^n\)</span> <span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(P\)</span> 的 face 若 $F=P $ 或者 <span
class="math inline">\(F = P\cap H\)</span> 对于某些 hyperplane <span
class="math inline">\(H\)</span></p>
<blockquote>
<p>边界上的一部分</p>
</blockquote>
<h4 id="定义-17-edge-and-facet">定义 17 edge and facet</h4>
<p>设 <span class="math inline">\(P\subseteq \mathbb{R}^n\)</span></p>
<ul>
<li>a face <span class="math inline">\(v\)</span> is vertex 若 <span
class="math inline">\(\{v\}\)</span> 是 <span
class="math inline">\(P\)</span> 的 face</li>
<li>a face <span class="math inline">\(e\)</span> is an edge 若 <span
class="math inline">\(e\)</span> is face and <span
class="math inline">\(\dim(e)=1\)</span></li>
<li>a face <span class="math inline">\(F\)</span> is a facet 若 <span
class="math inline">\(F\)</span> is face and <span
class="math inline">\(\dim(F)=\dim(P)-1\)</span></li>
</ul>
<h4 id="定义-18-等价定义-vertex">定义 18 等价定义 vertex</h4>
<p>给定 polyhedron <span class="math inline">\(P\)</span>. 点 <span
class="math inline">\(x\in P\)</span> 是 vetex 若存在 <span
class="math inline">\(c\in \mathbb{R}^n\)</span> 使得对于 <span
class="math inline">\(\forall y\in P,y\ne x\)</span> 有 <span
class="math inline">\(c^T y&lt;c^T x\)</span></p>
<blockquote>
<p>c 是 hyperplane</p>
</blockquote>
<h4 id="定义-19-extreme-point">定义 19 extreme point</h4>
<p>给定 polyhedron <span class="math inline">\(P\)</span>. 点 <span
class="math inline">\(x\in P\)</span> 是 extreme point 若 <span
class="math inline">\(\nexists a, b \neq x, a, b \in P\)</span>, with
<span class="math inline">\(\lambda a+(1-\lambda) b=x\)</span> for <span
class="math inline">\(\lambda \in[0,1]\)</span>.</p>
<blockquote>
<p>不存在 a,b 把 x 夹在中间</p>
</blockquote>
<h4 id="lemma-20-vertex-and-extreme-point">Lemma 20 vertex and extreme
point</h4>
<p>A vertex is also an extreme point</p>
<h4 id="observation">Observation</h4>
<p>The feasible region of an LP is a Polyhedron.</p>
<h3 id="convex-set">Convex Set</h3>
<h4 id="定理-21-答案在端点">定理 21 答案在端点</h4>
<p>若存在LP的最优解，那么存在一个最优解是extreme point.</p>
<blockquote>
<p>不存在最优解的情况是 infeasible 或者 答案无穷大</p>
</blockquote>
<details>
<summary>
证明
</summary>
<p>假设 <span class="math inline">\(x\)</span> 是最优解但不是extreme
point,那么存在一个方向 <span class="math inline">\(d\)</span> 使得 <span
class="math inline">\(x \pm d \in P\)</span> (Definition 19)
然后由于<span class="math inline">\(A(x \pm d)=b\)</span> (feasible
满足LP定义) 通过两个方程加减得到 <span
class="math inline">\(Ad=0\)</span>. 不妨假设 <span
class="math inline">\(c^T d \geq 0\)</span> (如果是负数就换一个方向)</p>
<ul>
<li><p>Case 1 $ j.$ s.t. <span class="math inline">\(d_j&lt;0\)</span>
存在某一列是小于0的</p>
<p>增加 <span class="math inline">\(\lambda\)</span> 到 <span
class="math inline">\(\lambda &#39;\)</span> 使得第一个 <span
class="math inline">\(x+\lambda d\)</span> 的某一项到0. 因为<span
class="math inline">\(x+\lambda&#39; d\)</span> 是 feasible 所以<span
class="math inline">\(A\left(x+\lambda^{\prime} d\right)=b,
x+\lambda^{\prime} d \ge 0\)</span> 所以 <span class="math inline">\(c^T
x^{\prime}=c^T\left(x+\lambda^{\prime} d\right)=c^T x+\lambda^{\prime}
c^T d \geq c^T x\)</span> 其中 <span class="math inline">\(\lambda
&#39;&gt;0\)</span> 是移动的步长, <span class="math inline">\(c^Td\ge
0\)</span> 根据假设.</p></li>
<li><p>Case 2. <span class="math inline">\(d_j \ge 0\)</span> 且 <span
class="math inline">\(c^Td&gt;0\)</span></p>
<p>因为如果 <span class="math inline">\(c^Td=0\)</span>
那么我们可以换一个 <span class="math inline">\(d\)</span>
的方向，这样可以归到Case1里面. 然后 <span
class="math inline">\(x+\lambda d\)</span> 是 feasible 的 因为 <span
class="math inline">\(A(x+\lambda d)=Ax+\lambda Ad=Ax=b\)</span>
所以只要<span class="math inline">\(x+\lambda d \ge 0\)</span> 就能
feasible.</p>
<p>所以我们可以把 <span class="math inline">\(\lambda\)</span>
变成无穷大, 因为<span class="math inline">\(c^T d&gt;0\)</span> 所以
<span class="math inline">\(c^T(x+\lambda d) \rightarrow \infty\)</span>
答案就变成无穷大了.</p></li>
</ul>
</details>
<h4 id="记号-submatrix">记号 Submatrix</h4>
<p>设 <span class="math inline">\(B \subseteq\{1 \ldots n\}\)</span>
是列的下标集合，那么定义 <span class="math inline">\(A_B\)</span> 是
<span class="math inline">\(A\)</span> 的所有 <span
class="math inline">\(B\)</span> 中列的子集矩阵.</p>
<h4 id="定理-22-extreme-point">定理 22 extreme point</h4>
<p>设 <span class="math inline">\(P=\{x \mid A x=b, x \geq 0\}\)</span>
对于 <span class="math inline">\(x\in P\)</span> 设 <span
class="math inline">\(B=\left\{j \mid x_j&gt;0\right\}\)</span> 那么
<span class="math inline">\(x\)</span> 是 extreme point iff <span
class="math inline">\(A_B\)</span> 有 linearly independent columns.</p>
<blockquote>
<p>Recap1: 测试 independent vectors <span
class="math inline">\(v_1,v_2...\)</span> 就是把他们列在一起，解方程
<span class="math inline">\(v_1x_1+v_2x_2..=0\)</span> 的解是否是 <span
class="math inline">\(x_i=0\)</span> 是就是 independent. 也即是 <span
class="math inline">\(Ax=0\)</span> 的解是否是 <span
class="math inline">\(x=0\)</span>, 其中 <span
class="math inline">\(A\)</span> 是这些向量的列组成的矩阵</p>
<p>Recap2: <span class="math inline">\(Ax = v_1 x_1+v_2x_2+...\)</span>
其中 <span class="math inline">\(v_i\)</span> 是列</p>
</blockquote>
<details>
<summary>
证明
</summary>
<p>(<span class="math inline">\(\Leftarrow\)</span>)</p>
<p>设 <span class="math inline">\(x\)</span> 不是extreme point.
那么存在方向 <span class="math inline">\(d\)</span> 使得 <span
class="math inline">\(x \pm d \in P\)</span> 于是 <span
class="math inline">\(Ad=0\)</span> 然后我们定义 <span
class="math inline">\(B^{\prime}=\left\{j \mid d_j \neq
0\right\}\)</span> 那么 <span class="math inline">\(A_{B&#39;}\)</span>
有 linearly dependent column 因为 <span
class="math inline">\(Ad=0\)</span> . 因为 <span
class="math inline">\(d_j=0\)</span> 的列不影响 <span
class="math inline">\(Ad\)</span> 的计算结果. 如果 <span
class="math inline">\(x_j=0\)</span>那么有<span
class="math inline">\(d_j=0\)</span>，因为如果<span
class="math inline">\(d_j\ne 0\)</span> 那么可以改变方向使得 <span
class="math inline">\(x_j\)</span> infeasible而我们假设存在这个方向
<span class="math inline">\(d\)</span> 是feasible的. 由于 <span
class="math inline">\(B&#39; \subseteq B\)</span> 所有 <span
class="math inline">\(A_B\)</span> 是dependent的</p>
<p>(<span class="math inline">\(\mathbb{R}ightarrow\)</span>)</p>
<p>若 <span class="math inline">\(A_B\)</span> 有dependent column那么
<span class="math inline">\(\exists d\ne 0. A_Bd=0\)</span> 于是扩展
<span class="math inline">\(d\)</span> 到 <span
class="math inline">\(\mathbb{R}^n\)</span> 当 <span
class="math inline">\(x_j=0\)</span> 的时候 <span
class="math inline">\(d_j=0\)</span> 那么对于足够小的 <span
class="math inline">\(\lambda\)</span> 我们有 <span
class="math inline">\(x \pm \lambda d \in P\)</span> 所以 <span
class="math inline">\(x\)</span> 不是 extreme point.</p>
</details>
<h4 id="定理-23-vertex">定理 23 vertex</h4>
<p>设 <span class="math inline">\(P=\{x \mid A x=b, x \geq 0\}\)</span>
设点 <span class="math inline">\(x \in P\)</span> 设 <span
class="math inline">\(B=\left\{j \mid x_j&gt;0\right\}\)</span> $A_B $
有 independent column (extreme point) 那么 <span
class="math inline">\(x\)</span> 是 vertex.</p>
<details>
<summary>
证明
</summary>
构造一个hyperplane <span class="math inline">\(c_j= \begin{cases}0 &amp;
j \in B \\ -1 &amp; j \notin B\end{cases}\)</span> 所以 <span
class="math inline">\(c^T x=0\)</span> 对于 <span
class="math inline">\(x\)</span> , 那么对于 <span
class="math inline">\(y\in P, y\ne x\)</span> <span
class="math inline">\(c^T y \leq 0\)</span> 接下来证明唯一性，假设 <span
class="math inline">\(c^Ty=0\)</span> 那么 对于所有 <span
class="math inline">\(j \notin B\)</span> 有 <span
class="math inline">\(y_j=0\)</span> 然后 <span
class="math inline">\(b=A y=A_B y_B=A x=A_B x_B\)</span> 然后变形<span
class="math inline">\(A_B\left(x_B-y_B\right)=0\)</span> 以为 <span
class="math inline">\(A_B\)</span> 有 independent column 所以 <span
class="math inline">\(x_B -y_B = 0\)</span> 所以 <span
class="math inline">\(x_B=y_B\)</span> 所以 <span
class="math inline">\(x=y\)</span>
</details>
<h4 id="observation-1">Observation</h4>
<p>对于一个 LP 我们可以不妨假设 <span
class="math inline">\(\operatorname{rank}(A)=m\)</span> , 也就是满秩</p>
<details>
<summary>
解释
</summary>
<p>假设 <span class="math inline">\(\operatorname{rank}(A)&lt;m\)</span>
那么可以不妨假设 <span class="math inline">\(A_1=\sum_{i=2}^m \lambda_i
\cdot A_i\)</span> 也就是 <span class="math inline">\(A_1\)</span>
可以表示为其他行的线性组合</p>
<ul>
<li><span class="math inline">\(b_1=\sum_{i=2}^m \lambda_i \cdot
b_i\)</span> 那么 <span class="math inline">\(A_1\)</span>
就没用了，就把第一行去掉</li>
<li><span class="math inline">\(b_1 \neq \sum_{i=2}^m \lambda_i \cdot
b_i\)</span> 这种情况LP是infeasible的</li>
</ul>
</details>
<h4 id="定理-24-basis">定理 24 Basis</h4>
<p>给定 LP <span class="math inline">\(P=\{x \mid A x=b, x \geq
0\}\)</span> 且 <span class="math inline">\(x\)</span> 是 extreme point
等价于 存在 <span class="math inline">\(B \subseteq\{1, \ldots,
n\}\)</span> with <span class="math inline">\(|B|=m\)</span> 我们叫
<span class="math inline">\(B\)</span> 是一个 Basis</p>
<ul>
<li><span class="math inline">\(A_B\)</span> is non-singular</li>
<li><span class="math inline">\(x_B=A_B^{-1} b \geq 0\)</span></li>
<li><span class="math inline">\(x_N=0\)</span></li>
</ul>
<p>其中 <span class="math inline">\(N=\{1, \ldots, n\} \backslash
B\)</span></p>
<blockquote>
<p>对于任意矩阵, 行秩等于列秩</p>
</blockquote>
<details>
<summary>
证明
</summary>
<p>(<span class="math inline">\(\Leftarrow\)</span>)</p>
<p>有 <span class="math inline">\(A_B\)</span> non-singular 就是有
linearly independent columns, 那么把 <span
class="math inline">\(x_j=0\)</span> 的列踢掉，也是independent的,
所以是extreme point.</p>
<p>(<span class="math inline">\(\mathbb{R}ightarrow\)</span>)</p>
首先extreme point 可以推出 设 <span class="math inline">\(B=\left\{j
\mid x_j&gt;0\right\}\)</span> 那么 <span
class="math inline">\(x\)</span> 是 extreme point iff <span
class="math inline">\(A_B\)</span> 有 linearly independent columns.
首先因为行秩是 <span class="math inline">\(m\)</span> , 列秩也是 <span
class="math inline">\(m\)</span>. 所以如果 <span
class="math inline">\(|B|&lt; m\)</span> , 加一些可以加列进去之后仍然是
linearly independent 把 <span class="math inline">\(m\)</span>
列补齐，构造出满足条件 1 的 <span class="math inline">\(B\)</span> .
所以 <span class="math inline">\(A_Bx_B=b\)</span> 推出 <span
class="math inline">\(x_B=A_B^{-1} b \geq 0\)</span> 然后条件3显然满足.
</details>
<h4 id="定义-basic-feasible-solutions">定义 Basic Feasible
Solutions</h4>
<p><span class="math inline">\(\mathcal{x} \in \mathbb{R}^n\)</span> 是
basic solution 若 <span class="math inline">\(Ax=b\)</span> 且 <span
class="math inline">\(\operatorname{rank}\left(A_J\right)=|J|\)</span>
where <span class="math inline">\(J=\left\{j \mid x_j \neq
0\right\}\)</span></p>
<p><span class="math inline">\(x\)</span> 是 basic feasible solution
(BFS) 若还 <span class="math inline">\(x\ge 0\)</span></p>
<p><span class="math inline">\(x\)</span> 是 basic solution associated
to basis <span class="math inline">\(B\)</span>, 若 <span
class="math inline">\(A_B x_B=b\)</span> and <span
class="math inline">\(x_j=0\)</span> 对于所有 <span
class="math inline">\(j \notin B\)</span></p>
<h4 id="定义-25-basic-feasible-solution">定义 25 basic feasible
solution</h4>
<p>对于 general LP <span class="math inline">\(\max \left\{c^T x \mid A
x \leq b\right\}\)</span> 若 <span class="math inline">\(x\)</span>
是BFS 若 <span class="math inline">\(x\)</span> 是 feasible 且存在 <span
class="math inline">\(n\)</span> 个linearly independent constraints is
tight. (以等于号满足)</p>
<p>解释</p>
<p>一个BFS 满足 <span class="math inline">\(m\)</span> 个equality
constraint 就是 <span class="math inline">\(A\)</span> 的所有行,
此外至少 <span class="math inline">\(n-m\)</span> 个 <span
class="math inline">\(x_i\)</span> 是<span
class="math inline">\(0\)</span> 满足 $x $ 是以等于号成立.</p>
<p>所以至少 <span class="math inline">\(n\)</span> 个 constraint
是以等于号满足的</p>
<p>然后可以回答之前的问题: Is LP in NP?</p>
<p>对于 LP 我们可以便利所有 bases 然后计算，如果 LP 是unbounded
我们可以把 <span class="math inline">\(c^T x \le \alpha\)</span>
加入constraint, 这样一定是bounded了.</p>
<h3 id="simplex-algorithm">Simplex Algorithm</h3>
<p>BFS 移动到相邻的 BFS 来计算最优解.</p>
<ul>
<li>选择一个 coefficient 大于零的作为进入的variable</li>
<li>增大 <span class="math inline">\(b\)</span> 并且使得constraint
满足</li>
<li><span class="math inline">\(\theta=\min \{480 / 15,160 / 4,1190 /
20\}\)</span> 选自最小的步长</li>
<li>变成 <span class="math inline">\(0\)</span> 的出来.</li>
</ul>
<p>知道没有可以换的时候结束</p>
<p><span class="math display">\[
\begin{array}{rlrl}\max 13 a+23 b &amp; &amp; \\ \text { s.t. } \quad 5
a+15 b+s_c &amp; =480 \\ 4 a+4 b+s_h &amp; =160 \\ 35 a+20 b+s_m &amp;
=1190 \\ a, b, s_c, s_h, s_m &amp; \geq 0\end{array}
\]</span></p>
<p>最后是</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20230430113252418.png"
alt="image-20230430113252418" />
<figcaption aria-hidden="true">image-20230430113252418</figcaption>
</figure>
<p>这样子 <span class="math inline">\(Z=800-s_C-2 s_h, s_C \geq 0, s_h
\geq 0\)</span></p>
<h4 id="矩阵表示法">矩阵表示法</h4>
<p><span class="math display">\[
\begin{array}{rlrl}
c_B^T x_B+c_N^T x_N &amp; =Z \\
A_B x_B+A_N x_N &amp; =b \\
x_B,  x_N  \geq 0
\end{array}
\]</span></p>
<p>simplex tableaux是</p>
<p><span class="math display">\[
\begin{aligned}
I\left(c_N^T-c_B^T A_B^{-1} A_N\right) x_N &amp; =Z-c_B^T A_B^{-1} b \\
I x_B+A_B^{-1} A_N x_N &amp; =A_B^{-1} b \\
x_B, &amp; \geq 0
\end{aligned}
\]</span></p>
<p>就是看这是怎么用矩阵算出来的</p>
<h4 id="algebraic-definition-of-pivoting">Algebraic Definition of
Pivoting</h4>
<p>给定Basis <span class="math inline">\(B\)</span> with BFS <span
class="math inline">\(x^*\)</span> 选择 <span class="math inline">\(j
\notin B\)</span> 使得 increase <span
class="math inline">\(x_j^*\)</span> from 0 to <span
class="math inline">\(\theta&gt;0\)</span></p>
<p>Go from <span class="math inline">\(x^*\)</span> to <span
class="math inline">\(x^*+\theta \cdot d\)</span></p>
<p>然后需要满足</p>
<ul>
<li><span class="math inline">\(d_j=1\)</span> normalization</li>
<li><span class="math inline">\(d_{\ell}=0, \ell \notin B, \ell \neq
j\)</span></li>
<li><span class="math inline">\(A\left(x^*+\theta d\right)=b\)</span>
must hold. Hence <span class="math inline">\(A d=0\)</span>.</li>
<li><span class="math inline">\(A_B d_B+A_{* j}=A d=0\)</span> 所以
<span class="math inline">\(d_B=-A_B^{-1} A_{* j}\)</span></li>
</ul>
<h4 id="定义-26-j-th-basic-direction">定义 26 j-th basic direction</h4>
<p>其中的 <span class="math inline">\(d_B=-A_B^{-1} A_{* j}\)</span> 是
j-th basic direction, 然后从 <span class="math inline">\(x^*\)</span>
走到 <span class="math inline">\(x^*+\theta \cdot d\)</span> ,
目标函数会增加</p>
<p><span class="math display">\[
\theta \cdot c^T d=\theta\left(c_j-c_B^T A_B^{-1} A_{* j}\right)
\]</span></p>
<h4 id="定义-27-reduced-cost">定义 27 Reduced Cost</h4>
<p>对于 <span class="math inline">\(B\)</span></p>
<p><span class="math display">\[
\tilde{c}_j=c_j-c_B^T A_B^{-1} A_{* j}
\]</span></p>
<p>是对于 <span class="math inline">\(x_j\)</span> 的reduced cost,
其实是增加的cost</p>
<p>其实是 <span class="math inline">\(c_N^T-c_B^T A_B^{-1} A_N\)</span>
的第 <span class="math inline">\(j\)</span> 项</p>
<h4 id="min-ratio-test">Min Ratio Test</h4>
<p>如果所有 <span class="math inline">\(\theta\)</span>
是负的，那么是unbounded</p>
<h4 id="定义-28-degeneracy">定义 28 Degeneracy</h4>
<p>如果 <span class="math inline">\(x_l=0, l\in B\)</span>
那么目标函数可能不会增大. 多点重合的情况.</p>
<p>BFS <span class="math inline">\(x^*\)</span> 是 degenerate 若 <span
class="math inline">\(J=\left\{j \mid x_j^*&gt;0\right\}\)</span> 是
<span class="math inline">\(|J| &lt; m\)</span></p>
<p>所以这种情况，算法可能会无限循环.</p>
<h4 id="two-phase-algorithm得出初始可行解">Two Phase
Algorithm得出初始可行解</h4>
<p>如果 <span class="math inline">\(A x \leq b, x \geq 0\)</span>, and
<span class="math inline">\(\boldsymbol{b} \geq \mathbf{0}\)</span>.
那么我们可以令 <span class="math inline">\(x=0\)</span></p>
<p>令slack variable 等于右边</p>
<p>如果没有的话就要用 TWO PHASE ALGORITHM</p>
<ul>
<li><p>令 <span class="math inline">\(b_i&lt;0\)</span> 的行乘 <span
class="math inline">\(-1\)</span></p></li>
<li><p>maximize <span class="math inline">\(-\sum_i v_i\)</span> 使得
<span class="math inline">\(A x+I v=b, x \geq 0, v \geq 0\)</span> using
Simplex</p>
<p>我们要尽可能不使用 <span class="math inline">\(v\)</span>, 也就是令
<span class="math inline">\(v=0\)</span></p></li>
<li><p>如果 <span class="math inline">\(\sum_i v_i&gt;0\)</span>
那么就是infeasible</p>
<p>否则你就有一个初始的可行解</p></li>
</ul>
<h4 id="lemma-29-最优解判定条件">Lemma 29 最优解判定条件</h4>
<p>Let <span class="math inline">\(B\)</span> be a basis and <span
class="math inline">\(x^*\)</span> a BFS corresponding to basis <span
class="math inline">\(B . \tilde{c} \leq 0\)</span> implies that <span
class="math inline">\(x^*\)</span> is an optimum solution to the LP.</p>
<h4 id="怎样得到解的上界">怎样得到解的上界</h4>
<p><span class="math display">\[
\begin{aligned}
\max 13 a+23 b &amp; \\
\text { s.t. } 5 a+15 b &amp;\leq 480 \\
4 a+4 b &amp;\leq 160 \\
35 a+20 b &amp;\leq 1190 \\
a, b &amp;\geq 0 \\
\end{aligned}
\]</span></p>
<p>可以构造一个不等式的 conic combination 比如1行乘以2再加2行</p>
<h3 id="duality">Duality</h3>
<h4 id="定义-30-dual-problem">定义 30 Dual problem</h4>
<p>对于LP <span class="math inline">\(z=\max \left\{c^T x \mid A x \leq
b, x \geq 0\right\}\)</span> 的dual problem就是构造最小的上界</p>
<p><span class="math display">\[
w=\min \left\{b^T y \mid A^T y \geq c, y \geq 0\right\}
\]</span></p>
<h4 id="lemma-31">Lemma 31</h4>
<p>The dual problem of the dual problem is the primal problem</p>
<details>
<summary>
证明
</summary>
<p><span class="math inline">\(w=\min \left\{b^T y \mid A^T y \geq c, y
\geq 0\right\}\)</span> 对于这个再dual一次，都乘个符号变成max</p>
<span class="math inline">\(w=-\max \left\{-b^T y \mid-A^T y \leq-c, y
\geq 0\right\}\)</span> 然后再dual 就变成 <span
class="math inline">\(z=-\min \left\{-c^T x \mid-A x \geq-b, x \geq
0\right\}\)</span> 再转成min就是 <span class="math inline">\(z=\max
\left\{c^T x \mid A x \leq b, x \geq 0\right\}\)</span>
</details>
<h4 id="weak-duality">Weak duality</h4>
<p>Let <span class="math inline">\(\hat{x}\)</span> be primal feasible
就是再primal problem 里面是feasible的, <span
class="math inline">\(\hat{y}\)</span> be dual feasible. Then</p>
<p><span class="math display">\[
c^T \hat{x} \leq z \leq w \leq b^T \hat{y}
\]</span></p>
<p>证明</p>
<p><span class="math inline">\(A^T \hat{y} \geq c \mathbb{R}ightarrow
\hat{x}^T A^T \hat{y} \geq \hat{x}^T c (\hat{x}\ge 0)\)</span> 左右乘个
<span class="math inline">\(\hat{x}^T\)</span> <span
class="math inline">\(A \hat{x} \leq b \mathbb{R}ightarrow y^T A \hat{x}
\leq \hat{y}^T b(\hat{y} \geq 0)\)</span> ,
然后呢因为scalar来说转置不改变结果，所以</p>
<p><span class="math display">\[
c^T \hat{x} \leq \hat{y}^T A \hat{x} \leq b^T \hat{y}
\]</span></p>
<p>因为他们是feasible的，所以存在 <span class="math inline">\(c^T
\hat{x}=z\)</span> 使得他们两个分别可以达到最优解所以 <span
class="math inline">\(z \leq w\)</span></p>
<h4 id="simplex-的dual-form">Simplex 的dual form</h4>
<span class="math display">\[
\begin{aligned}
z &amp; =\max \left\{c^T x \mid A x=b, x \geq 0\right\} \\
w &amp; =\min \left\{b^T y \mid A^T y \geq c\right\}
\end{aligned}
\]</span>
<details>
<summary>
证明
</summary>
<p><span class="math display">\[
\begin{aligned}
\max &amp; \left\{c^T x \mid A x=b, x \geq 0\right\} \\
&amp; =\max \left\{c^T x \mid A x \leq b,-A x \leq-b, x \geq 0\right\}
\\
&amp; =\max \left\{c^T x \mid\left[\begin{array}{c}
A \\
-A
\end{array}\right] x \leq\left[\begin{array}{c}
b \\
-b
\end{array}\right], x \geq 0\right\}
\end{aligned}
\]</span></p>
<p>把等于号拆成2个小于等于，然后写成矩阵，然后求dual</p>
<p><span class="math display">\[
\begin{aligned}
\min &amp; \left\{\left[b^T-b^T\right] y \mid\left[A^T-A^T\right] y \geq
c, y \geq 0\right\} \\
&amp; =\min \left\{\left[b^T-b^T\right] \cdot\left[\begin{array}{c}
y^{+} \\
y^{-}
\end{array}\right] \mid\left[A^T-A^T\right] \cdot\left[\begin{array}{c}
y^{+} \\
y^{-}
\end{array}\right] \geq c, y^{-} \geq 0, y^{+} \geq 0\right\} \\
&amp; =\min \left\{b^T \cdot\left(y^{+}-y^{-}\right) \mid A^T
\cdot\left(y^{+}-y^{-}\right) \geq c, y^{-} \geq 0, y^{+} \geq 0\right\}
\\
&amp; =\min \left\{b^T y^{\prime} \mid A^T y^{\prime} \geq c\right\}
\end{aligned}
\]</span></p>
</details>
<h4 id="proof-of-optimality-criterion-for-simplex">Proof of Optimality
Criterion for Simplex</h4>
<p>首先由 reduced cost <span class="math inline">\(\tilde{c}=c^T-c_B^T
A_B^{-1} A \leq 0\)</span> 然后求个转置</p>
<p><span class="math display">\[
A^T\left(A_B^{-1}\right)^T c_B \geq c
\]</span></p>
<p>所以 <span
class="math inline">\(\mathcal{Y}^*=\left(A_B^{-1}\right)^T c_B\)</span>
是一个是dual problem的解，然后代入dual定义</p>
<p><span class="math display">\[
\begin{aligned}
b^T y^* &amp; =\left(A x^*\right)^T y^*=\left(A_B x_B^*\right)^T y^* \\
&amp; =\left(A_B x_B^*\right)^T\left(A_B^{-1}\right)^T
c_B=\left(x_B^*\right)^T A_B^T\left(A_B^{-1}\right)^T c_B \\
&amp; =c^T x^*
\end{aligned}
\]</span></p>
<p><span class="math inline">\(x^*\)</span> 是你当前求出来的最优解</p>
<h4 id="strong-duality">Strong Duality</h4>
<p>首先如果我们有min的LP，我们也可以写Dual 也就是 <span
class="math display">\[
D=\min \left\{\bar{b}^T y \mid \bar{A}^T y=c, y \geq 0\right\}
\]</span> 和下面这个是一组 <span class="math display">\[
\bar{P}=\max \left\{c^T x \mid \bar{A} x \leq \bar{b}\right\}
\]</span></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://fyind.de">Fyind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://fyind.de/2023/04/19/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95II/">http://fyind.de/2023/04/19/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95II/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/">线性规划</a></div><div class="post-share"><div class="social-share" data-image="/img/pic1.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/04/22/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="密码学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">密码学</div></div><div class="info-2"><div class="info-item-1">密码学 理论基础 Alice 给 Bob 发消息，保护消息的 confidentiality. 传输途径可以是任意的，Internet, USB stick… 在过程中被动的监听者Eve 有可能会监听或者解释信息. 在过去，军事加密依赖于信息的混乱程度 obfuscation of message contents. 现代密码学依赖于 Kerckhoff’s Principle, 除了key所有信息都是已知的.  A crypto system should be secure, even if everything about the system, except the key, is public knowledge.  信息加密是通过 encryption schemes 使用一个key和lock concept来实现的. 只有key的持有者可以加密解密信息. Alice会把key \(k\) 分享给Bob, 我们现在还不关系这个怎样实现.  Alice 加密信息 \(m\), \(c := E(k,m)\) Bob 解密信息 \(m:=D(k,c)\)  香农密码 Sh...</div></div></div></a><a class="pagination-related" href="/2023/04/19/%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98%E8%AE%BE%E8%AE%A1/" title="客制化键盘设计"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">客制化键盘设计</div></div><div class="info-2"><div class="info-item-1">客制化键盘设计 设计布局 这个网站 可以在线设计布局，设计完成之后可以复制 Raw Data 来进行下一步。   image-20230419164533764  123456[&quot;Esc&quot;,&#123;x:1&#125;,&quot;F1&quot;,&quot;F2&quot;,&quot;F3&quot;,&quot;F4&quot;,&#123;x:0.5&#125;,&quot;F5&quot;,&quot;F6&quot;,&quot;F7&quot;,&quot;F8&quot;,&#123;x:0.5&#125;,&quot;F9&quot;,&quot;F10&quot;,&quot;F11&quot;,&quot;F12&quot;,&#123;x:0.25&#125;,&quot;PrtSc&quot;,&quot;Scroll Lock&quot;,&quot;Pause\nBreak&quot;],[&#123;y:0.5&#125;,&quot;~\n`&quot;,&quot;!\n1&quot;,&quot;@\n2&quot;,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/08/10/AtCoder%E9%A2%98%E8%A7%A3/" title="AtCoder题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="info-item-2">AtCoder题解</div></div><div class="info-2"><div class="info-item-1">AtCoder Grand Contest 047 AtCoder Grand Contest 047 A. Integer Product 给定 \(n\) 个浮点数，计算有多少个 \((i, j)\) 使得 \(A_{i} \cdot A_{j}\) 是整数 \(2\leq N \leq 200 \  000\) , $ 0 &lt; A_{i} ^{4}$ , \(A_{i}\) 最多 \(9\) 为小数. 思路  通过题设条件缩小范围， 枚举  由于数据比较大，不能直接暴力做。判断是整数这个条件不太好集体维护。所以要找出题目中的特性，看看有没有机会让范围缩小。最好是可以 先考虑 \(A_{i} \cdot A_{j}\) 什么情况下是整数。发现，对于任意有限小数 \(x\), 可以在乘上 \(10^{n}\) 后肯定会变成整数。所以每个数必然是 \(k\cdot 2^{m}\cdot 5^{n}\) 的形式, 通过乘 \(10^{n}\) 把分母上的 \(2^{m}\cdot 5^{n}\) 约去. 而之前的 \(k\) 不影响答案。所以我们只要考虑 \(2^{m}\cd...</div></div></div></a><a class="pagination-related" href="/2020/07/29/CodeForces%E9%A2%98%E8%A7%A3/" title="CodeForces题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-29</div><div class="info-item-2">CodeForces题解</div></div><div class="info-2"><div class="info-item-1">Educational Codeforces Round 92 (Rated for Div. 2) link A. LCM Problem  构造  给定区间 \([l,r]\) 求 \(2\) 个在里面的数，使得它们的最小公倍数也在区间内，否则输出-1 -1 . 可以知道 \(l, l*2\) 是2个最小的可能组合，只要判断 \(l*2 &gt; r\) 即可. B. Array Walk  贪心  由于可以折返的步数比较少。我们可以枚举折返的步数。当折返的步数固定为 \(j\) 的时候。有2种情况，  \(j\) 步都是折返后又回来。这种情况最远走到了 \([1,k-2j]\) \(j-1\) 步是折返后又回来，最后一步是折返后不回来。这种情况的区间是 \([1,k-2(j-1)-1]\)  可以证明：若折返，则必定是在当前区间的最大两个相邻元素间折返。 那么我们用前缀和的方式求出 \([1,i]\) 的和还有最大相邻元素的位置。那么分情况讨论这两种情况的最大值。最后取个更优的解即可 \(O(n)\) 123456789101112131415161718192021222...</div></div></div></a><a class="pagination-related" href="/2020/05/26/Python%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/" title="三行写完高斯消元，这就是Python!!!"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-26</div><div class="info-item-2">三行写完高斯消元，这就是Python!!!</div></div><div class="info-2"><div class="info-item-1">三行写完高斯消元，这就是Python!!! 洛谷评测链接 先给大家看一眼核心代码 核心代码 123for i in range(len(a)):    row = [j for j in range(len(a)) if a[j][i] != 0 and sum(a[j][:i]) &lt; 1e-8][0]    a[:] = [r + a[row]*(-r[i]/a[row][i]) if j != row else r/a[row][i] for (j,r) in enumerate(a)] 没错，就只有三行，完成了高斯消元最核心的操作，把矩阵消元成主对角线为1，其余除了常数项全是0的形式。我只用了Python中的切片操作，列表解析式，还有numpy中array的性质。 为了方便大家理解，我先来介绍一些这些python中的语法 python语法介绍 切片 语法格式是 [开始:结束] 可以取出列表中的一段区间,如果不填写就是默认开始位置是0，结束位置是列表最后一个元素位置。注意这里的区间是左闭右开区间。并且支持倒着数，也就是使用负号 比如： 12345l = [0,2,3,4...</div></div></div></a><a class="pagination-related" href="/2020/08/10/Trie/" title="Trie"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="info-item-2">Trie</div></div><div class="info-2"><div class="info-item-1">Trie Trie 是一个用树来存储字符串的结构。 基本操作  插入一个字符串 查找一个字符串是否在树中 维护对应字符串的附加信息(如个数之类的)  模板  P2580 于是他错误的点名开始了  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int maxnode = maxn * 50;const int sigma_size = 26;#define c ((ch)-&#x27;a&#x27;)int child[maxnode][sigma_size], val[maxnode];int sz, n;void insert(string s) &#123;    int u = 0; // 从根节点 u = 0 开始插入    for (char ch : s) &#123;        i...</div></div></div></a><a class="pagination-related" href="/2020/08/14/%E5%81%9A%E9%A2%98%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%95%99%E8%AE%AD/" title="做题经验与教训"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-14</div><div class="info-item-2">做题经验与教训</div></div><div class="info-2"><div class="info-item-1">思维CheatSheet 思路 多角度思维 这个题有多少种思路，目前选择一条路。每个思路都要想一点。如果是dp，有多种方程，那每个都要考虑一下。 推导Observation  眼看出来的 基本公式，基于基本公式的Ob  卡住了 你想的题根本不是原问题  中间推导错了 题目读错了  换角度理解问题 转换问题的表示方法。换一种理解方式 常规推导  考虑答案由什么组成(拆分出可以维护的情况) 考虑最简单的几种情况(best case) 考虑状态的转移 什么会产生贡献，哪些会对答案产生贡献 考虑答案的单调性，时空转移  分类讨论  问题可以分为几种情况  贪心  什么构成答案最好（构造一个最好的答案）  计算操作的最大值最小值： 以某种贪心的策略一定可以达到最优，模拟这种策略的步骤  分析最大值  二分/枚举  如给定某个参数，是不是会好做一定  动态规划、递推  考虑问题的子结构 考虑状态是什么，如何转移 换一种更好的状态 简化子结构（去除冗余状态） 通过贪心优化转移，减少转移的数量 用数据结构维护一维度  整理思维 筛选合理的推断和考虑不确定的推断  题目的位置与代码量和思路深度对应...</div></div></div></a><a class="pagination-related" href="/2020/11/10/%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/" title="几何习题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-10</div><div class="info-item-2">几何习题</div></div><div class="info-2"><div class="info-item-1">几何习题 二分 ABC181F Silver Woods 题意 有 \(n \le 100\) 个木桩在 \(-100\le y \le100\) 的范围里。你有一个圆，圆的半径你可以选择的。求可以把圆从最左边移动到最右边的最大半径。 思路 首先题目具有单调性：如果一个半径可以移动，那么更小的也可以。如果一个半径不能移动，那么更大的肯定不行。所以我们考虑二分。那给定一个 \(r\) 怎么检查呢。对于两个点\(x,y\)，如果 \(r\) 不能从他们之间通过，那么我们就将这两个点连起来。对于上下界\((y=\pm 100)\) 如果不能这个线和这个点之间穿过去，那么我们就连上他们。我们枚举把所有的点都连线完。如果存在一条由上界连向下界的边，那么这个半径就被 “拦住了”不能通过。如果没有就一定存在一条路径可以通过。所以我们用并查集连接就好了，最后检查一下上下界有没有连起来即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fyind</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fyind"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Fyind" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tarjan0025@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=d0kMY0nN" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来逛逛我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95ii"><span class="toc-number">1.</span> <span class="toc-text">高效算法II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92lp"><span class="toc-number">1.1.</span> <span class="toc-text">线性规划(LP)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#standard-form"><span class="toc-number">1.1.1.</span> <span class="toc-text">Standard Form</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90standard-form"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">转换成Standard Form</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%891-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92lp"><span class="toc-number">1.1.2.</span> <span class="toc-text">定义1 线性规划(LP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">一些基本定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%892-linear-combination"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">定义2 linear combination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%893-linear-space"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">定义3 Linear space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%894-span"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">定义4 span</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5-convex-function"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">定义 5 convex function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lemma-6-convex-p"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">Lemma 6 convex P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-7-affine-subspace"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">定义 7 affine subspace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-8-convex-set"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">定义 8 convex set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-9-hyperplane"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">定义 9 hyperplane</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-10-halfspace"><span class="toc-number">1.1.3.9.</span> <span class="toc-text">定义 10 halfspace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-11-polytop"><span class="toc-number">1.1.3.10.</span> <span class="toc-text">定义 11 polytop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-12-polyhedron"><span class="toc-number">1.1.3.11.</span> <span class="toc-text">定义 12 Polyhedron</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-13-bounded-polyhedron"><span class="toc-number">1.1.3.12.</span> <span class="toc-text">定义 13 Bounded Polyhedron</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-14-polytop-and-polyhedron"><span class="toc-number">1.1.3.13.</span> <span class="toc-text">定理 14 polytop and
polyhedron</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-15-supporting-hyperplane"><span class="toc-number">1.1.3.14.</span> <span class="toc-text">定义 15 supporting
hyperplane</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-16-face"><span class="toc-number">1.1.3.15.</span> <span class="toc-text">定义 16 Face</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-17-edge-and-facet"><span class="toc-number">1.1.3.16.</span> <span class="toc-text">定义 17 edge and facet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-18-%E7%AD%89%E4%BB%B7%E5%AE%9A%E4%B9%89-vertex"><span class="toc-number">1.1.3.17.</span> <span class="toc-text">定义 18 等价定义 vertex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-19-extreme-point"><span class="toc-number">1.1.3.18.</span> <span class="toc-text">定义 19 extreme point</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lemma-20-vertex-and-extreme-point"><span class="toc-number">1.1.3.19.</span> <span class="toc-text">Lemma 20 vertex and extreme
point</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#observation"><span class="toc-number">1.1.3.20.</span> <span class="toc-text">Observation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#convex-set"><span class="toc-number">1.1.4.</span> <span class="toc-text">Convex Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-21-%E7%AD%94%E6%A1%88%E5%9C%A8%E7%AB%AF%E7%82%B9"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">定理 21 答案在端点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7-submatrix"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">记号 Submatrix</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-22-extreme-point"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">定理 22 extreme point</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-23-vertex"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">定理 23 vertex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#observation-1"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">Observation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-24-basis"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">定理 24 Basis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-basic-feasible-solutions"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">定义 Basic Feasible
Solutions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-25-basic-feasible-solution"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">定义 25 basic feasible
solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#simplex-algorithm"><span class="toc-number">1.1.5.</span> <span class="toc-text">Simplex Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">矩阵表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#algebraic-definition-of-pivoting"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">Algebraic Definition of
Pivoting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-26-j-th-basic-direction"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">定义 26 j-th basic direction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-27-reduced-cost"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">定义 27 Reduced Cost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#min-ratio-test"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">Min Ratio Test</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-28-degeneracy"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">定义 28 Degeneracy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#two-phase-algorithm%E5%BE%97%E5%87%BA%E5%88%9D%E5%A7%8B%E5%8F%AF%E8%A1%8C%E8%A7%A3"><span class="toc-number">1.1.5.7.</span> <span class="toc-text">Two Phase
Algorithm得出初始可行解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lemma-29-%E6%9C%80%E4%BC%98%E8%A7%A3%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.5.8.</span> <span class="toc-text">Lemma 29 最优解判定条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%BE%97%E5%88%B0%E8%A7%A3%E7%9A%84%E4%B8%8A%E7%95%8C"><span class="toc-number">1.1.5.9.</span> <span class="toc-text">怎样得到解的上界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duality"><span class="toc-number">1.1.6.</span> <span class="toc-text">Duality</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-30-dual-problem"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">定义 30 Dual problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lemma-31"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">Lemma 31</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-duality"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">Weak duality</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#simplex-%E7%9A%84dual-form"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">Simplex 的dual form</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proof-of-optimality-criterion-for-simplex"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">Proof of Optimality
Criterion for Simplex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strong-duality"><span class="toc-number">1.1.6.6.</span> <span class="toc-text">Strong Duality</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程">C++高性能编程</a><time datetime="2025-07-17T19:47:19.000Z" title="Created 2025-07-17 19:47:19">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="操作系统概念">操作系统概念</a><time datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置">Kubuntu配置</a><time datetime="2025-07-15T05:25:37.000Z" title="Created 2025-07-15 05:25:37">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E6%88%91%E4%BB%AC%E5%9C%A8AI%E6%97%B6%E4%BB%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/" title="我们在AI时代该如何学习">我们在AI时代该如何学习</a><time datetime="2025-07-12T23:12:19.000Z" title="Created 2025-07-12 23:12:19">2025-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CA-Top-Down-Approach/" title="计算机网络A Top Down Approach">计算机网络A Top Down Approach</a><time datetime="2025-07-12T22:02:58.000Z" title="Created 2025-07-12 22:02:58">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fyind</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>