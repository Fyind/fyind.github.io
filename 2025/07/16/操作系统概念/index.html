<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统概念 | Fyind's Blog</title><meta name="author" content="Fyind"><meta name="copyright" content="Fyind"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 引言 1.1 操作系统的作用  用户视图：操作系统的界面因设备而异，如PC、移动设备和嵌入式系统。 系统视图：操作系统作为资源分配器和控制程序，管理CPU、内存、I&#x2F;O设备等资源。 定义操作系统：操作系统没有统一定义，但通常指核心内核、中间件框架及系统程序。  1.2 计算机系统组织 1.2.1 中断  中断机制用于处理异步事件，通过中断服务例程响应硬件请求。 中断优先级机制允许区分高&#x2F;低">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统概念">
<meta property="og:url" content="http://fyind.de/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="Fyind&#39;s Blog">
<meta property="og:description" content="第一章 引言 1.1 操作系统的作用  用户视图：操作系统的界面因设备而异，如PC、移动设备和嵌入式系统。 系统视图：操作系统作为资源分配器和控制程序，管理CPU、内存、I&#x2F;O设备等资源。 定义操作系统：操作系统没有统一定义，但通常指核心内核、中间件框架及系统程序。  1.2 计算机系统组织 1.2.1 中断  中断机制用于处理异步事件，通过中断服务例程响应硬件请求。 中断优先级机制允许区分高&#x2F;低">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://fyind.de/img/pic1.PNG">
<meta property="article:published_time" content="2025-07-16T20:55:14.000Z">
<meta property="article:modified_time" content="2025-07-18T10:49:53.878Z">
<meta property="article:author" content="Fyind">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyind.de/img/pic1.PNG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统概念",
  "url": "http://fyind.de/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/",
  "image": "http://fyind.de/img/pic1.PNG",
  "datePublished": "2025-07-16T20:55:14.000Z",
  "dateModified": "2025-07-18T10:49:53.878Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fyind",
      "url": "http://fyind.de"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pic1.PNG"><link rel="canonical" href="http://fyind.de/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统概念',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://fyindex.work/PicGo/liuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yae.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Fyind's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统概念</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统概念</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-18T10:49:53.878Z" title="Updated 2025-07-18 10:49:53">2025-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="第一章-引言">第一章 引言</h3>
<h4 id="操作系统的作用">1.1 操作系统的作用</h4>
<ul>
<li>用户视图：操作系统的界面因设备而异，如PC、移动设备和嵌入式系统。</li>
<li>系统视图：操作系统作为资源分配器和控制程序，管理CPU、内存、I/O设备等资源。</li>
<li>定义操作系统：操作系统没有统一定义，但通常指核心内核、中间件框架及系统程序。</li>
</ul>
<h4 id="计算机系统组织">1.2 计算机系统组织</h4>
<h5 id="中断">1.2.1 中断</h5>
<ul>
<li>中断机制用于处理异步事件，通过中断服务例程响应硬件请求。</li>
<li>中断优先级机制允许区分高/低优先级中断，确保紧急任务优先处理。</li>
<li>中断向量表通过唯一编号索引中断服务例程地址。</li>
</ul>
<h5 id="存储结构">1.2.2 存储结构</h5>
<ul>
<li>主要存储单元包括寄存器、高速缓存、主存（RAM）、非易失性存储（NVM）和二级存储（硬盘）。</li>
<li>存储层次结构按容量与访问时间排序，速度越快的存储越接近CPU。</li>
<li>非易失性存储用于保存引导程序和静态数据。</li>
</ul>
<h5 id="io结构">1.2.3 I/O结构</h5>
<ul>
<li>I/O由设备控制器和驱动程序管理，采用中断或DMA方式减少CPU开销。</li>
<li>DMA允许设备直接读写内存，仅在传输完成后触发一次中断。</li>
<li>高端系统使用交换架构替代总线架构以提高并发性能。</li>
</ul>
<h4 id="计算机系统架构">1.3 计算机系统架构</h4>
<h5 id="单处理器系统">1.3.1 单处理器系统</h5>
<ul>
<li>一个通用CPU加上多个专用处理器（如磁盘控制器）组成。</li>
<li>专用处理器运行有限指令集，协助主CPU完成特定任务。</li>
</ul>
<h5 id="多处理器系统">1.3.2 多处理器系统</h5>
<ul>
<li>对称多处理（SMP）系统中每个CPU执行所有任务，共享内存。</li>
<li>多核系统将多个计算核心集成在一个芯片上，提升效率并降低功耗。</li>
<li>NUMA架构为每个CPU提供本地内存，避免总线竞争瓶颈。</li>
</ul>
<h5 id="集群系统">1.3.3 集群系统</h5>
<ul>
<li>由多个节点组成的松耦合系统，通过局域网或InfiniBand互联。</li>
<li>提供高可用性服务，支持故障转移与负载均衡。</li>
<li>并行集群允许多个主机访问共享存储，需特殊软件支持。</li>
</ul>
<h4 id="操作系统操作">1.4 操作系统操作</h4>
<h5 id="多道程序设计与多任务处理">1.4.1 多道程序设计与多任务处理</h5>
<ul>
<li>多道程序设计提高CPU利用率，通过进程切换保持CPU忙碌。</li>
<li>多任务系统频繁切换进程，提供快速用户响应。</li>
<li>虚拟内存技术使程序可大于物理内存，分离逻辑与物理地址空间。</li>
</ul>
<h5 id="双模式与多模式操作">1.4.2 双模式与多模式操作</h5>
<ul>
<li>用户模式与内核模式通过模式位区分，防止非法指令执行。</li>
<li>特权指令仅能在内核模式下执行，如I/O控制、定时器管理。</li>
<li>支持更多保护级别的架构（如Intel四环模型、ARM七种模式）。</li>
</ul>
<h5 id="定时器">1.4.3 定时器</h5>
<ul>
<li>定时器用于防止用户程序无限循环，强制中断返回控制权给操作系统。</li>
<li>Linux中的HZ参数决定定时中断频率，jiffies记录启动以来的中断次数。####
1.5 资源管理</li>
<li>操作系统是资源管理者，负责管理CPU、内存空间、文件存储空间和I/O设备等资源。</li>
</ul>
<h5 id="进程管理">1.5.1 进程管理</h5>
<ul>
<li>程序在执行时被称为进程。</li>
<li>进程需要CPU时间、内存、文件和I/O设备等资源来完成任务。</li>
<li>单线程进程只有一个程序计数器，多线程进程有多个程序计数器。</li>
<li>进程是系统中的工作单元，分为操作系统进程（执行系统代码）和用户进程（执行用户代码）。</li>
<li>操作系统负责创建和删除进程、调度进程和线程、挂起和恢复进程、提供进程同步和通信机制。</li>
</ul>
<h5 id="内存管理">1.5.2 内存管理</h5>
<ul>
<li>主存是计算机系统操作的核心，必须将程序映射到绝对地址并加载到内存中才能执行。</li>
<li>多道程序设计要求系统保持多个程序在内存中，以提高CPU利用率和响应速度。</li>
<li>操作系统负责跟踪内存使用情况、分配和释放内存空间、决定哪些进程和数据应调入或调出内存。</li>
</ul>
<h5 id="文件系统管理">1.5.3 文件系统管理</h5>
<ul>
<li>操作系统提供统一的逻辑视图，将文件抽象为逻辑存储单元。</li>
<li>文件可以代表程序和数据，组织成目录结构便于管理。</li>
<li>操作系统负责创建和删除文件与目录、支持文件操作原语、将文件映射到物理存储介质，并进行备份。</li>
</ul>
<h5 id="存储设备管理">1.5.4 存储设备管理</h5>
<ul>
<li>操作系统需有效管理二级存储（如硬盘）和三级存储（如磁带）。</li>
<li>管理功能包括挂载与卸载、空闲空间管理、存储分配、磁盘调度、分区和保护。</li>
<li>三级存储用于长期备份和不常用数据存储，由操作系统或应用程序管理。</li>
</ul>
<h5 id="缓存管理">1.5.5 缓存管理</h5>
<ul>
<li>缓存通过复制信息到更快的存储系统中提升性能。</li>
<li>寄存器、高速缓存、主存、固态硬盘和磁盘构成存储层次结构。</li>
<li>缓存大小和替换策略影响性能，操作系统控制数据在不同层级之间的移动。</li>
<li>在多任务和多处理器环境中，需确保缓存一致性。</li>
</ul>
<h5 id="io系统管理">1.5.6 I/O系统管理</h5>
<ul>
<li>操作系统隐藏硬件设备细节，通过I/O子系统管理缓冲、缓存、假脱机。</li>
<li>设备驱动程序负责特定硬件的操作。</li>
<li>操作系统处理中断、设备控制寄存器访问和I/O完成检测。</li>
</ul>
<h4 id="安全与保护">1.6 安全与保护</h4>
<ul>
<li>多用户和多进程环境下需调节对数据的访问。</li>
<li>保护机制防止未经授权的进程操作资源，如内存地址限制、定时器防止无限循环。</li>
<li>安全机制防御外部和内部攻击，如病毒、拒绝服务攻击、身份盗用。</li>
<li>用户身份识别通过用户名和用户ID实现，支持用户组权限管理。</li>
<li>特权升级机制允许临时获取更高权限，如UNIX的setuid属性。</li>
</ul>
<h4 id="虚拟化">1.7 虚拟化</h4>
<ul>
<li>虚拟化技术将单个计算机硬件抽象为多个执行环境。</li>
<li>支持在同一台机器上运行多个操作系统，如Windows和UNIX。</li>
<li>虚拟机管理器（VMM）负责资源管理和隔离虚拟机。</li>
<li>虚拟化广泛应用于服务器、桌面和数据中心，提高资源利用率和灵活性。</li>
</ul>
<h4 id="分布式系统">1.8 分布式系统</h4>
<ul>
<li>分布式系统是由网络连接的多个独立计算机组成的集合。</li>
<li>提供资源共享、提高计算速度、数据可用性和可靠性。</li>
<li>网络按协议、节点距离和传输介质分类，如局域网（LAN）、广域网（WAN）。</li>
<li>网络操作系统提供文件共享和进程通信功能；分布式操作系统提供单一系统外观。</li>
</ul>
<h4 id="内核数据结构">1.9 内核数据结构</h4>
<ul>
<li>操作系统广泛使用链表、栈、队列、树、哈希表和位图等数据结构。</li>
</ul>
<h5 id="列表栈和队列">1.9.1 列表、栈和队列</h5>
<ul>
<li>链表支持动态插入和删除，适用于变长数据。</li>
<li>栈采用后进先出（LIFO）原则，常用于函数调用。</li>
<li>队列采用先进先出（FIFO）原则，常用于打印作业和任务调度。</li>
</ul>
<h5 id="树">1.9.2 树</h5>
<ul>
<li>树结构表示数据层次关系，二叉搜索树支持高效查找。</li>
<li>平衡二叉搜索树（如红黑树）用于Linux调度算法。</li>
</ul>
<h5 id="哈希函数与映射">1.9.3 哈希函数与映射</h5>
<ul>
<li>哈希函数将数据映射为索引，实现快速检索。</li>
<li>哈希冲突通过链表解决，常用于密码验证等场景。</li>
</ul>
<h5 id="位图">1.9.4 位图</h5>
<ul>
<li>位图用于高效表示大量资源状态，如磁盘块可用性。</li>
</ul>
<h4 id="计算环境">1.10 计算环境</h4>
<ul>
<li>操作系统适应多种计算环境，包括传统计算、移动计算、客户端-服务器、点对点、云计算和实时嵌入式系统。</li>
</ul>
<h5 id="传统计算">1.10.1 传统计算</h5>
<ul>
<li>包括PC、服务器、网络和远程访问。</li>
<li>时间分片技术允许多用户共享系统资源。</li>
</ul>
<h5 id="移动计算">1.10.2 移动计算</h5>
<ul>
<li>手持设备如智能手机和平板电脑。</li>
<li>支持多媒体、GPS定位、加速度传感器等功能。</li>
<li>Android和iOS为主流移动操作系统。</li>
</ul>
<h5 id="客户端-服务器计算">1.10.3 客户端-服务器计算</h5>
<ul>
<li>服务器满足客户端请求，分为计算服务器和文件服务器。</li>
</ul>
<h5 id="点对点计算">1.10.4 点对点计算</h5>
<ul>
<li>所有节点平等，可同时作为客户端和服务器。</li>
<li>优势在于去中心化，避免服务器瓶颈。</li>
</ul>
<h5 id="云计算">1.10.5 云计算</h5>
<ul>
<li>提供计算、存储和应用作为服务，基于虚拟化技术。</li>
<li>包括公有云、私有云、混合云及SaaS、PaaS、IaaS模式。</li>
</ul>
<h5 id="实时嵌入式系统">1.10.6 实时嵌入式系统</h5>
<ul>
<li>用于汽车引擎、医疗设备等，具有严格的时间约束。</li>
<li>实时系统需在限定时间内完成处理，否则导致失败。</li>
</ul>
<h4 id="自由与开源操作系统">1.11 自由与开源操作系统</h4>
<ul>
<li>开源软件提供源代码，允许自由使用、修改和分发。</li>
<li>GNU/Linux、BSD UNIX、Solaris为典型开源系统。</li>
</ul>
<h5 id="历史">1.11.1 历史</h5>
<ul>
<li>早期软件附带源代码，后逐渐转向闭源。</li>
<li>Richard Stallman发起GNU项目，倡导自由软件理念。</li>
</ul>
<h5 id="自由操作系统">1.11.2 自由操作系统</h5>
<ul>
<li>自由软件强调用户自由而非价格，保障四项基本自由。</li>
</ul>
<h5 id="gnulinux">1.11.3 GNU/Linux</h5>
<ul>
<li>Linux内核结合GNU工具形成完整操作系统。</li>
<li>多种发行版如Red Hat、Ubuntu、Debian等。</li>
</ul>
<h5 id="bsd-unix">1.11.4 BSD UNIX</h5>
<ul>
<li>衍生于AT&amp;T UNIX，发展出FreeBSD、NetBSD等多个版本。</li>
<li>提供完整的源代码，支持开发者研究和定制。</li>
</ul>
<h5 id="solaris">1.11.5 Solaris</h5>
<ul>
<li>Sun Microsystems开发的商业UNIX系统。</li>
<li>OpenSolaris开源项目衍生出Project Illumos。</li>
</ul>
<h5 id="开源系统作为学习工具">1.11.6 开源系统作为学习工具</h5>
<ul>
<li>开源项目促进学生理解操作系统原理，参与开发和改进。</li>
</ul>
<h4 id="总结">1.12 总结</h4>
<ul>
<li>操作系统管理硬件资源，提供应用程序运行环境。</li>
<li>中断机制协调硬件与CPU交互，主存为直接访问唯一存储。</li>
<li>多道程序设计和多任务提升CPU利用率和响应速度。</li>
<li>用户模式与内核模式区分权限，保障系统安全。</li>
<li>进程是操作系统的基本工作单元，涉及创建、调度、同步和通信。</li>
<li>内存管理、文件系统、存储设备和缓存优化系统性能。</li>
<li>保护与安全机制防止非法访问，虚拟化技术提升资源利用率。</li>
<li>数据结构支撑操作系统功能实现，适应多样计算环境。</li>
<li>自由与开源系统推动教育与技术创新。#### 第一章练习</li>
<li>1.12
集群系统与多处理器系统的区别在于集群由多个独立节点组成，通过网络通信协作；而多处理器系统共享内存和总线。要实现高可用服务，集群需要心跳机制、故障检测、数据复制和自动故障转移。</li>
<li>1.13
数据库集群的两种管理方式包括共享磁盘（所有节点访问同一存储）和主从复制（一个节点写，其他节点读）。前者提供一致性但存在单点故障风险；后者提高可用性但可能有数据同步延迟。</li>
<li>1.14
中断用于响应外部事件（如I/O完成），由硬件触发；陷阱是软件产生的异常或系统调用。用户程序可以有意生成陷阱以请求操作系统服务（如系统调用）。</li>
<li>1.15
Linux中HZ表示每秒时钟中断次数，jiffies记录自启动以来的中断总数。通过jiffies
/ HZ可计算出系统运行的秒数。</li>
<li>1.16 a.
CPU通过DMA控制器设置源地址、目标地址和传输长度来协调数据传输。<br />
</li>
<li>1.16 b. DMA完成后会触发中断通知CPU操作结束。<br />
</li>
<li>1.16
c. DMA允许CPU并发执行其他任务，不会直接干扰用户程序，但在内存带宽竞争激烈时可能导致性能下降。</li>
<li>1.17
没有硬件特权模式仍可通过软件仿真、解释执行或虚拟机监控器构造安全操作系统，但效率低且安全性依赖于软件实现，难以完全替代硬件支持。</li>
<li>1.18
多级缓存设计是为了平衡速度与容量：本地缓存速度快但容量小，适合私有数据；共享缓存容量大但访问延迟稍高，适合多核间共享数据。</li>
<li>1.19 存储系统按速度排序为：磁带 &lt; 光盘 &lt; 硬盘 &lt;
非易失性存储 &lt; 主存 &lt; 缓存 &lt; 寄存器。</li>
<li>1.20
示例：在SMP系统中，两个核心各自缓存同一内存变量，若其中一个修改了值但未同步，则另一核心看到的是旧值。</li>
<li>1.21 a.
单处理器中缓存一致性问题出现在不同指令阶段对同一数据的访问。<br />
</li>
<li>1.21 b.
多处理器中每个核心有自己的缓存，需通过协议（如MESI）保持一致性。<br />
</li>
<li>1.21
c. 分布式系统中数据分布于不同节点，需使用一致性算法（如Paxos、Raft）保证全局一致性。</li>
<li>1.22
内存保护机制包括分段与分页，结合基址与界限寄存器限制程序访问范围，利用MMU进行地址转换并检查权限，防止非法访问。</li>
<li>1.23 a. 校园学生活动中心适合LAN配置。<br />
</li>
<li>1.23 b. 跨校区大学系统适合WAN连接。<br />
</li>
<li>1.23 c. 居民小区适合LAN或WLAN配置。</li>
<li>1.24
移动设备操作系统需考虑电池寿命、屏幕尺寸、触控输入、传感器集成、应用沙箱化及频繁更新需求，相比传统PC更注重资源优化与安全性。</li>
<li>1.25
P2P系统无需中央服务器，具有更高的容错性、负载均衡能力和扩展性，适用于文件共享、流媒体、分布式计算等场景。</li>
<li>1.26
适合P2P系统的应用包括BitTorrent文件共享、Skype语音通信、IPFS分布式文件系统、区块链网络等。</li>
<li>1.27
开源操作系统的优点包括透明性（开发者喜欢）、可定制性（高级用户喜欢）、低成本（中小企业喜欢）；缺点包括技术支持不足（普通用户困扰）、碎片化（企业IT管理困难）、安全更新滞后（安全专家担忧）。</li>
</ul>
<h2 id="第二章-操作系统结构">第二章 操作系统结构</h2>
<h5 id="操作系统服务">2.1 操作系统服务</h5>
<ul>
<li>提供用户界面（GUI、触摸屏、命令行）。</li>
<li>程序执行：加载和运行程序，正常或异常终止。</li>
<li>I/O操作：读写文件或设备，需通过操作系统控制。</li>
<li>文件系统管理：创建/删除/读取/写入文件，设置权限。</li>
<li>通信：共享内存或消息传递，支持进程间或跨机器通信。</li>
<li>错误检测：处理硬件、I/O设备及程序错误，并采取适当措施。</li>
<li>资源分配：为多个进程分配CPU周期、内存、外设等资源。</li>
<li>日志记录：用于计费、统计资源使用情况。</li>
<li>保护与安全：防止非法访问系统资源，要求用户身份验证。</li>
</ul>
<h5 id="用户与操作系统接口">2.2 用户与操作系统接口</h5>
<ul>
<li>命令解释器（Shell）：
<ul>
<li>如UNIX/Linux的bash、C Shell，Windows的cmd。</li>
<li>可通过系统程序实现命令（如rm）。</li>
</ul></li>
<li>图形用户界面（GUI）：
<ul>
<li>使用窗口、菜单、图标，如macOS的Aqua、Windows的Explorer。</li>
<li>开源桌面环境包括KDE和GNOME。</li>
</ul></li>
<li>触摸屏接口：
<ul>
<li>适用于移动设备，如iPhone的Springboard、Android的触控交互。</li>
</ul></li>
<li>接口选择：
<ul>
<li>高级用户倾向CLI，普通用户偏好GUI。</li>
<li>CLI可通过脚本自动化重复任务。</li>
</ul></li>
</ul>
<h5 id="系统调用">2.3 系统调用</h5>
<ul>
<li>系统调用作用：
<ul>
<li>提供应用程序与操作系统之间的接口。</li>
<li>实现对文件、进程、设备、通信等的操作。</li>
</ul></li>
<li>示例流程：
<ul>
<li>如复制文件涉及open()、read()、write()、close()等系统调用。</li>
</ul></li>
<li>应用编程接口（API）：
<ul>
<li>Windows API、POSIX API、Java API。</li>
<li>API函数通常封装系统调用。</li>
</ul></li>
<li>参数传递方式：
<ul>
<li>寄存器、堆栈、内存块。</li>
</ul></li>
<li>系统调用分类：
<ul>
<li>进程控制：create(), terminate(), wait(), signal()等。</li>
<li>文件管理：open(), read(), write(), delete()等。</li>
<li>设备管理：request(), release(), read(), write()等。</li>
<li>信息维护：get_time(), set_time(), get_process_attributes()等。</li>
<li>通信：send(), receive(), pipe(), socket()等。</li>
<li>保护：chmod(), chown(), set_permissions()等。</li>
</ul></li>
</ul>
<h5 id="系统服务">2.4 系统服务</h5>
<ul>
<li>文件管理：创建、删除、复制、编辑文件。</li>
<li>状态信息：获取时间、内存、磁盘空间、用户数等。</li>
<li>文件修改：提供文本编辑器和搜索工具。</li>
<li>编程语言支持：编译器、调试器、解释器（如C/C++、Java、Python）。</li>
<li>程序加载与执行：绝对加载器、可重定位加载器、链接编辑器。</li>
<li>通信：虚拟连接、网络服务、远程登录、邮件传输。</li>
<li>后台服务（守护进程）：
<ul>
<li>如网络服务、定时任务、打印服务器。</li>
<li>Linux中称为daemon，Windows中称为service。</li>
</ul></li>
</ul>
<h5 id="链接器与加载器">2.5 链接器与加载器</h5>
<ul>
<li>编译过程：
<ul>
<li>源代码 → 目标文件（relocatable） → 链接生成可执行文件。</li>
</ul></li>
<li>链接器功能：
<ul>
<li>合并目标文件与库，解决符号引用。</li>
</ul></li>
<li>加载器功能：
<ul>
<li>将可执行文件加载到内存并启动执行。</li>
</ul></li>
<li>动态链接：
<ul>
<li>允许在运行时加载库（如Windows的DLL、Linux的.so）。</li>
</ul></li>
<li>ELF格式：
<ul>
<li>Executable and Linkable Format，定义可执行文件结构。</li>
<li>包含入口地址、段表、符号表等信息。</li>
</ul></li>
</ul>
<h5 id="应用为何依赖操作系统">2.6 应用为何依赖操作系统</h5>
<ul>
<li>不同操作系统差异：
<ul>
<li>系统调用接口不同。</li>
<li>可执行文件格式不同（如Windows PE、macOS Mach-O）。</li>
<li>CPU指令集不同（如x86 vs ARM）。</li>
</ul></li>
<li>跨平台解决方案：
<ul>
<li>解释型语言（Python、Ruby）。</li>
<li>虚拟机（如Java JVM）。</li>
<li>标准化API（如POSIX）。</li>
</ul></li>
<li>ABI（应用二进制接口）：
<ul>
<li>定义参数传递方式、栈布局、数据类型大小等底层细节。</li>
<li>不同ABI之间不兼容，限制跨平台能力。</li>
</ul></li>
</ul>
<h5 id="操作系统设计与实现">2.7 操作系统设计与实现</h5>
<ul>
<li>设计目标：
<ul>
<li>用户视角：易用、快速、可靠。</li>
<li>开发者视角：易维护、灵活、高效。</li>
</ul></li>
<li>机制与策略分离：
<ul>
<li>机制决定如何实现，策略决定做什么。</li>
<li>微内核将策略与机制解耦，增强灵活性。</li>
</ul></li>
<li>实现语言：
<ul>
<li>多数操作系统使用C/C++，部分关键代码用汇编。</li>
<li>Android示例：内核用C+ASM，系统库用C/C++，框架用Java。</li>
</ul></li>
<li>优势：
<ul>
<li>开发效率高、易于移植、便于优化。</li>
</ul></li>
<li>劣势：
<ul>
<li>性能略低，但现代编译器和硬件优化弥补此问题。</li>
</ul></li>
</ul>
<h5 id="操作系统结构">2.8 操作系统结构</h5>
<ul>
<li>单体结构（Monolithic）：
<ul>
<li>所有功能集中在内核，如早期UNIX。</li>
<li>优点：性能高；缺点：难以维护。</li>
</ul></li>
<li>分层结构（Layered）：
<ul>
<li>分层模块化设计，如THE OS。</li>
<li>优点：结构清晰；缺点：效率低。</li>
</ul></li>
<li>微内核（Microkernel）：
<ul>
<li>内核仅提供基础机制（如进程管理、通信），其他服务作为用户进程。</li>
<li>如Minix、QNX、Mach。</li>
<li>优点：稳定性好、扩展性强；缺点：性能开销大。</li>
</ul></li>
<li>模块化结构（Modular）：
<ul>
<li>支持动态加载内核模块（如Linux的loadable kernel modules）。</li>
</ul></li>
<li>混合结构（Hybrid）：
<ul>
<li>结合微内核与单体内核特性，如Windows NT、macOS XNU。</li>
</ul></li>
<li>Android架构：
<ul>
<li>基于Linux内核，系统库用C/C++，应用框架用Java。</li>
<li>采用Binder进行IPC通信。#### 第二章 操作系统结构（续）</li>
</ul></li>
</ul>
<h5 id="操作系统结构-1">2.8 操作系统结构</h5>
<ul>
<li>单体结构：
<ul>
<li>所有功能集中在单一地址空间中，如UNIX和早期Linux。</li>
<li>优点：性能高；缺点：难以维护和扩展。</li>
</ul></li>
<li>分层结构：
<ul>
<li>将操作系统划分为多个层次，每一层仅使用下层提供的服务。</li>
<li>优点：便于调试与验证；缺点：性能较差，接口定义复杂。</li>
</ul></li>
<li>微内核结构：
<ul>
<li>核心功能最小化，其余服务作为用户态进程运行。</li>
<li>优点：可移植性好、稳定性强；缺点：消息传递开销大，影响性能。</li>
</ul></li>
<li>模块化结构：
<ul>
<li>支持动态加载/卸载内核模块，如Linux的LKM。</li>
<li>提供灵活性和良好的性能平衡。</li>
</ul></li>
<li>混合结构：
<ul>
<li>结合单体内核与模块化设计，如Windows NT、macOS XNU。</li>
<li>平衡性能与可维护性。</li>
</ul></li>
</ul>
<h5 id="构建与启动操作系统">2.9 构建与启动操作系统</h5>
<ul>
<li>操作系统生成步骤：
<ul>
<li>编写或获取源代码 → 配置系统 → 编译 → 安装 → 启动。</li>
</ul></li>
<li>系统配置方式：
<ul>
<li>修改源码重新编译，或从库中链接预编译模块。</li>
</ul></li>
<li>Linux构建流程：
<ul>
<li>下载源码 → 使用make menuconfig配置 → 编译内核与模块 →
安装并重启。</li>
</ul></li>
<li>虚拟机安装选项：
<ul>
<li>可使用ISO镜像快速部署，或使用预配置虚拟机镜像。</li>
</ul></li>
</ul>
<h5 id="系统启动过程">2.9.2 系统启动过程</h5>
<ul>
<li>BIOS/UEFI引导流程：
<ul>
<li>引导程序定位并加载内核 → 初始化硬件 → 挂载根文件系统。</li>
</ul></li>
<li>多阶段引导：
<ul>
<li>BIOS加载MBR中的boot loader，再加载完整操作系统。</li>
</ul></li>
<li>UEFI优势：
<ul>
<li>支持更大磁盘、64位系统，集成完整引导管理器。</li>
</ul></li>
<li>GRUB引导器：
<ul>
<li>支持参数设置、多内核选择、内核参数修改。</li>
</ul></li>
<li>Android启动流程：
<ul>
<li>使用LK引导器，initramfs作为根文件系统。</li>
</ul></li>
<li>恢复模式支持：
<ul>
<li>所有主流系统均提供恢复或单用户模式用于诊断修复。</li>
</ul></li>
</ul>
<h5 id="操作系统调试">2.10 操作系统调试</h5>
<ul>
<li>故障分析：
<ul>
<li>内核崩溃时保存内存状态至专用区域，重启后生成core dump。</li>
<li>用户进程失败时记录日志并生成core文件供调试。</li>
</ul></li>
<li>性能监控工具：
<ul>
<li>Linux：ps、top、vmstat、iostat、netstat。</li>
<li>Windows：任务管理器。</li>
</ul></li>
<li>追踪工具：
<ul>
<li>strace、gdb、perf、tcpdump。</li>
</ul></li>
<li>BCC工具集：
<ul>
<li>基于eBPF实现动态内核追踪，提供Python接口。</li>
<li>示例工具：disksnoop、opensnoop，支持实时生产环境监控。</li>
</ul></li>
</ul>
<h5 id="总结-1">2.11 总结</h5>
<ul>
<li>操作系统核心功能：
<ul>
<li>提供程序执行环境，通过系统调用接口为用户提供服务。</li>
</ul></li>
<li>系统调用分类：
<ul>
<li>进程控制、文件管理、设备管理、信息维护、通信、保护。</li>
</ul></li>
<li>应用依赖原因：
<ul>
<li>可执行格式差异（PE/Mach-O/ELF）、指令集不同、系统调用不兼容。</li>
</ul></li>
<li>操作系统结构演进：
<ul>
<li>单体 → 分层 → 微内核 → 模块化 → 混合结构。</li>
</ul></li>
<li>启动机制：
<ul>
<li>引导程序负责加载内核、初始化硬件、挂载根文件系统。</li>
</ul></li>
<li>调试与性能优化：
<ul>
<li>使用计数器与追踪工具进行系统行为分析，BCC/eBPF提供高效内核级追踪能力。####
第四章 编程项目</li>
</ul></li>
</ul>
<h5 id="linux内核模块简介">4.1 Linux内核模块简介</h5>
<ul>
<li>本项目介绍如何创建并加载内核模块到Linux内核。</li>
<li>模块可在/proc文件系统中添加条目。</li>
<li>使用虚拟机完成实验，需通过终端编译程序并管理模块。</li>
</ul>
<h5 id="内核模块概述">4.2 内核模块概述</h5>
<ul>
<li>使用<code>lsmod</code>命令查看当前加载的内核模块。</li>
<li><code>simple.c</code>示例模块在加载和卸载时输出信息。
<ul>
<li><code>simple_init()</code>：模块加载时调用，返回整数表示成功或失败。</li>
<li><code>simple_exit()</code>：模块卸载时调用，无返回值。</li>
</ul></li>
<li>使用<code>printk()</code>函数输出日志信息，可通过<code>dmesg</code>查看。</li>
<li>注册模块入口和出口点：
<ul>
<li><code>module_init(simple_init)</code></li>
<li><code>module_exit(simple_exit)</code></li>
</ul></li>
<li>模块元信息：
<ul>
<li><code>MODULE_LICENSE("GPL")</code></li>
<li><code>MODULE_DESCRIPTION("Simple Module")</code></li>
<li><code>MODULE_AUTHOR("SGG")</code></li>
</ul></li>
</ul>
<h5 id="加载与卸载内核模块">4.3 加载与卸载内核模块</h5>
<ul>
<li>编译模块使用<code>make</code>命令，生成<code>simple.ko</code>文件。</li>
<li>加载模块使用<code>sudo insmod simple.ko</code>。</li>
<li>卸载模块使用<code>sudo rmmod simple</code>。</li>
<li>使用<code>dmesg</code>查看模块加载和卸载日志。</li>
<li>清空日志缓冲区使用<code>sudo dmesg -c</code>。</li>
</ul>
<h5 id="扩展功能练习">4.4 扩展功能练习</h5>
<ul>
<li>在模块中调用内核提供的常量和函数：
<ul>
<li><code>GOLDEN_RATIO_PRIME</code>：定义在<code>&lt;linux/hash.h&gt;</code>。</li>
<li><code>gcd()</code>函数：定义在<code>&lt;linux/gcd.h&gt;</code>，用于计算最大公约数。</li>
</ul></li>
<li>输出<code>HZ</code>和<code>jiffies</code>变量：
<ul>
<li><code>HZ</code>：定时器中断频率，定义在<code>&lt;asm/param.h&gt;</code>。</li>
<li><code>jiffies</code>：系统启动以来的中断次数，定义在<code>&lt;linux/jiffies.h&gt;</code>。</li>
</ul></li>
</ul>
<h5 id="proc文件系统模块">4.5 /proc文件系统模块</h5>
<ul>
<li><code>/proc</code>文件系统是伪文件系统，用于查询内核和进程状态。</li>
<li>创建<code>/proc/hello</code>文件示例（<code>hello.c</code>）：
<ul>
<li>使用<code>proc_create()</code>创建文件。</li>
<li>定义读取操作函数<code>proc_read()</code>。</li>
</ul></li>
<li><code>proc_read()</code>函数实现：
<ul>
<li>将“Hello World”写入内核缓冲区。</li>
<li>使用<code>copy_to_user()</code>将数据复制到用户空间。</li>
<li>控制只输出一次，避免重复读取。</li>
</ul></li>
</ul>
<h5 id="实验任务">4.6 实验任务</h5>
<ul>
<li>设计两个内核模块：
<ol type="1">
<li>创建<code>/proc/jiffies</code>文件：
<ul>
<li>读取时显示当前<code>jiffies</code>值。</li>
<li>模块卸载时删除该文件。</li>
</ul></li>
<li>创建<code>/proc/seconds</code>文件：
<ul>
<li>显示自模块加载以来经过的秒数。</li>
<li>使用<code>jiffies</code>和<code>HZ</code>进行换算（秒数 = jiffies /
HZ）。</li>
<li>模块卸载时删除该文件。</li>
</ul></li>
</ol></li>
</ul>
<h3 id="第三章-进程">第三章 进程</h3>
<h4 id="进程概念">3.1 进程概念</h4>
<h5 id="进程">3.1.1 进程</h5>
<ul>
<li>进程是正在执行的程序。</li>
<li>程序是被动实体，进程是主动实体。</li>
<li>内存布局包括：
<ul>
<li>文本段（可执行代码）</li>
<li>数据段（全局变量）</li>
<li>堆段（动态分配内存）</li>
<li>栈段（函数调用临时数据）</li>
</ul></li>
<li>程序变为进程需加载到内存。</li>
<li>同一程序可运行多个进程实例。</li>
</ul>
<h5 id="进程状态">3.1.2 进程状态</h5>
<figure>
<img src="https://fyindex.work/PicGo/image-20250717181828382.png"
alt="image-20250717181828382" />
<figcaption aria-hidden="true">image-20250717181828382</figcaption>
</figure>
<ul>
<li>进程状态包括：
<ul>
<li>新建（new）</li>
<li>就绪（ready）</li>
<li>运行（running）</li>
<li>等待（waiting）</li>
<li>终止（terminated）</li>
</ul></li>
<li>多个进程可处于就绪或等待状态，但仅一个进程在运行。</li>
</ul>
<h5 id="进程控制块pcb">3.1.3 进程控制块（PCB）</h5>
<p>Process Control Block</p>
<p><strong>PCB（进程控制块）</strong>是操作系统用于管理每个“进程”的一个数据结构。每当创建一个进程时，系统就会生成一个对应的
PCB，记录它的所有相关信息。</p>
<p>PCB
是操作系统核心管理进程的关键数据结构，必须受保护，防止用户程序直接访问或修改。</p>
<p>因此，PCB
存放在<strong>内核态专用的内存区域</strong>，只有操作系统内核代码能够访问。</p>
<p>即使你用
<code>sudo</code>（以管理员权限运行用户命令），你获得的是<strong>用户态的超级用户权限</strong>，而不是直接内核态权限。</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20250717181908345.png"
alt="image-20250717181908345" />
<figcaption aria-hidden="true">image-20250717181908345</figcaption>
</figure>
<ul>
<li>每个进程由PCB表示，包含以下信息：
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>调度信息</li>
<li>内存管理信息</li>
<li>I/O状态信息</li>
</ul></li>
</ul>
<h5 id="线程">3.1.4 线程</h5>
<ul>
<li>单线程进程只能顺序执行一个任务。</li>
<li>多线程进程可并发执行多个任务。</li>
<li>支持多核并行处理，提升性能。</li>
<li>PCB扩展以支持每个线程的信息。</li>
</ul>
<h4 id="进程调度">3.2 进程调度</h4>
<figure>
<img src="https://fyindex.work/PicGo/image-20250717182617776.png"
alt="image-20250717182617776" />
<figcaption aria-hidden="true">image-20250717182617776</figcaption>
</figure>
<h5 id="调度队列">3.2.1 调度队列</h5>
<ul>
<li>就绪队列：准备运行的进程。存放<strong>已准备好运行但尚未分配
CPU</strong> 的进程（也叫就绪进程）。通常是链表结构，头结点指向第一个
PCB（进程控制块）</li>
<li>等待队列：等待事件完成的进程。存放<strong>正在等待某个事件发生</strong>（如
I/O
完成、子进程结束、时钟中断等）的进程。每类事件都有自己的等待队列。</li>
<li>队列结构为链表，每个PCB含指针指向下一个PCB。</li>
</ul>
<h5 id="cpu调度">3.2.2 CPU调度</h5>
<ul>
<li><p>调度器的职责：</p>
<ul>
<li><p><strong>从就绪队列中选择一个进程</strong></p></li>
<li><p><strong>把它分配给一个 CPU 核心执行</strong></p></li>
<li><p><strong>决定何时切换（即上下文切换）</strong></p></li>
</ul></li>
<li><p>目标是最大化CPU利用率和实现时间分片。</p></li>
<li><p>CPU调度器从就绪队列选择进程执行。</p></li>
<li><p>I/O密集型与CPU密集型进程行为不同。</p></li>
<li><p>多核系统可同时运行多个进程。</p></li>
</ul>
<h5 id="上下文切换">3.2.3 上下文切换</h5>
<p><strong>上下文切换</strong>是操作系统在<strong>多个进程或线程之间切换执行</strong>的过程。每次切换，系统必须保存当前进程的执行状态，并恢复下一个进程的状态。</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20250717183157972.png"
alt="image-20250717183157972" />
<figcaption aria-hidden="true">image-20250717183157972</figcaption>
</figure>
<ul>
<li>中断导致当前进程上下文保存至PCB。</li>
<li>切换过程包括：
<ul>
<li>保存旧进程上下文</li>
<li>加载新进程上下文</li>
</ul></li>
<li>上下文切换纯属开销，无实际工作。</li>
<li>切换速度依赖硬件支持和操作系统复杂度。</li>
</ul>
<h4 id="进程操作">3.3 进程操作</h4>
<h5 id="进程创建">3.3.1 进程创建</h5>
<ul>
<li>父进程创建子进程，形成进程树。</li>
<li>子进程获取资源：CPU时间、内存、文件、I/O设备。</li>
<li>UNIX使用fork()创建子进程，随后可用exec()替换地址空间。</li>
<li>Windows使用CreateProcess()创建新进程。</li>
</ul>
<h5 id="进程终止">3.3.2 进程终止</h5>
<ul>
<li>进程通过exit()系统调用结束。</li>
<li>父进程可通过wait()获取子进程退出状态。</li>
<li>子进程资源被回收，若父进程未调用wait()则成为僵尸进程。</li>
<li>若父进程终止，init/systemd接管孤儿进程。</li>
</ul>
<h5 id="android进程层次">Android进程层次</h5>
<ul>
<li>进程按重要性排序，优先级从高到低：
<ul>
<li>前台进程（用户交互）</li>
<li>可见进程（前台引用）</li>
<li>服务进程（后台可见）</li>
<li>后台进程（非可见）</li>
<li>空进程（无活动组件）</li>
</ul></li>
<li>系统优先终止空进程，然后是后台进程等。</li>
</ul>
<h4 id="进程间通信ipc">3.4 进程间通信（IPC）</h4>
<ul>
<li>独立进程不共享数据，合作进程共享数据。</li>
<li>提供IPC的原因：
<ul>
<li>信息共享</li>
<li>计算加速（多核并行）</li>
<li>模块化设计</li>
</ul></li>
</ul>
<h4 id="共享内存模型下的ipc">3.5 共享内存模型下的IPC</h4>
<ul>
<li>进程建立共享内存区域进行通信。</li>
<li>生产者-消费者问题示例：
<ul>
<li>使用循环缓冲区（bounded buffer）</li>
<li>in和out指针管理缓冲区读写</li>
<li>同步机制防止同时访问冲突</li>
</ul></li>
</ul>
<h4 id="消息传递模型下的ipc">3.6 消息传递模型下的IPC</h4>
<ul>
<li>不共享地址空间，通过send()和receive()交换消息。</li>
<li>适用于分布式系统。</li>
<li>支持直接通信（命名对方）或间接通信（通过邮箱/端口）。</li>
</ul>
<h5 id="命名方式">3.6.1 命名方式</h5>
<ul>
<li>直接通信：
<ul>
<li>send(P, message)</li>
<li>receive(Q, message)</li>
</ul></li>
<li>间接通信：
<ul>
<li>send(A, message) 发送到邮箱A</li>
<li>receive(A, message) 从邮箱A接收</li>
</ul></li>
</ul>
<h5 id="同步方式">3.6.2 同步方式</h5>
<ul>
<li>阻塞发送/接收（同步）</li>
<li>非阻塞发送/接收（异步）</li>
<li>阻塞发送+阻塞接收实现同步 rendezvous</li>
</ul>
<h5 id="缓冲机制">3.6.3 缓冲机制</h5>
<ul>
<li>零容量：发送方必须等待接收方接收。</li>
<li>有界容量：最多n条消息，满时发送方阻塞。</li>
<li>无界容量：发送方永不阻塞。#### 第三章 进程（续）</li>
</ul>
<h5 id="ipc系统示例">3.7 IPC系统示例</h5>
<h6 id="posix共享内存">3.7.1 POSIX共享内存</h6>
<ul>
<li>使用内存映射文件组织共享内存。</li>
<li>shm_open() 创建共享内存对象。</li>
<li>ftruncate() 设置共享内存大小。</li>
<li>mmap() 建立内存映射，实现共享内存访问。</li>
<li>示例程序展示生产者写入 “Hello World!”，消费者读取并输出。</li>
</ul>
<h6 id="mach消息传递">3.7.2 Mach消息传递</h6>
<ul>
<li>Mach是专为分布式系统设计的操作系统，也用于macOS和iOS。</li>
<li>任务间通信通过端口（Port）进行，支持单向、有限长度的消息队列。</li>
<li>mach_msg() 是发送和接收消息的标准API。</li>
<li>支持简单消息（用户数据）和复杂消息（含内存指针或端口权限传输）。</li>
<li>利用虚拟内存技术避免消息复制，提升性能。</li>
</ul>
<h6 id="windows">3.7.3 Windows</h6>
<ul>
<li>Windows使用ALPC（高级本地过程调用）机制进行进程通信。</li>
<li>通信分为三种方式：
<ul>
<li>小消息（≤256字节）直接复制到端口队列。</li>
<li>大消息通过共享内存段（Section Object）传递。</li>
<li>超大消息允许服务器直接读写客户端地址空间。</li>
</ul></li>
<li>ALPC由系统内部使用，应用程序通过RPC间接调用。</li>
</ul>
<h6 id="管道pipes">3.7.4 管道（Pipes）</h6>
<h6 id="普通管道ordinary-pipes">3.7.4.1 普通管道（Ordinary Pipes）</h6>
<ul>
<li>单向通信：一端写入，另一端读取。</li>
<li>UNIX使用pipe()创建，fd[0]为读端，fd[1]为写端。</li>
<li>通常用于父子进程间通信。</li>
<li>若需双向通信，需使用两个管道。</li>
<li>Windows称其为匿名管道，使用CreatePipe()创建。</li>
</ul>
<h6 id="命名管道named-pipes">3.7.4.2 命名管道（Named Pipes）</h6>
<ul>
<li>支持跨无亲缘关系进程通信。</li>
<li>UNIX中称为FIFO，使用mkfifo()创建。</li>
<li>可持续存在，直到被显式删除。</li>
<li>Windows命名管道支持全双工通信，可跨机器使用。</li>
<li>使用CreateNamedPipe()创建，ConnectNamedPipe()连接。</li>
</ul>
<h5 id="客户端-服务器系统通信">3.8 客户端-服务器系统通信</h5>
<h6 id="套接字sockets">3.8.1 套接字（Sockets）</h6>
<ul>
<li>套接字是网络通信的端点，由IP+端口号唯一标识。</li>
<li>典型服务端口：SSH(22)、FTP(21)、HTTP(80)。</li>
<li>Java提供Socket类（TCP）、DatagramSocket类（UDP）及MulticastSocket类。</li>
<li>示例：日期服务器与客户端通过Socket交换当前时间。</li>
</ul>
<h6 id="远程过程调用rpc">3.8.2 远程过程调用（RPC）</h6>
<ul>
<li>RPC抽象了函数调用机制，适用于网络环境。</li>
<li>消息包含调用函数名、参数、返回值。</li>
<li>参数编组（Marshaling）解决不同机器的数据表示差异（如大端/小端）。</li>
<li>XDR（外部数据表示）定义平台无关的数据格式。</li>
<li>语义保证：“最多一次”（At Most Once）和“恰好一次”（Exactly
Once）。</li>
<li>绑定方式：
<ul>
<li>静态绑定：固定端口号。</li>
<li>动态绑定：通过匹配服务（Matchmaker）获取端口号。</li>
</ul></li>
</ul>
<h6 id="android中的rpc">3.8.2.1 Android中的RPC</h6>
<ul>
<li>Android使用Binder框架实现IPC，支持RPC。</li>
<li>Service组件可通过bindService()绑定，并提供远程接口。</li>
<li>AIDL（Android接口定义语言）生成Stub和服务接口。</li>
<li>客户端调用远程方法时，Binder自动处理参数编组、进程间传输及结果返回。</li>
</ul>
<h5 id="总结-2">3.9 总结</h5>
<ul>
<li>进程是正在执行的程序，具有文本段、数据段、堆、栈。</li>
<li>进程状态包括就绪、运行、等待、终止。</li>
<li>PCB记录进程状态、寄存器、调度信息等。</li>
<li>fork() 和 CreateProcess() 分别用于UNIX和Windows创建进程。</li>
<li>共享内存（POSIX
API）、消息传递（Mach、Windows）、管道（普通/命名）是常见IPC方式。</li>
<li>套接字和RPC用于客户端-服务器通信。</li>
<li>Android使用Binder框架支持RPC作为IPC机制。#### 第三章 进程（续）</li>
</ul>
<h5 id="进程调度与上下文切换">3.7 进程调度与上下文切换</h5>
<ul>
<li>上下文切换时，内核保存当前进程状态至PCB。</li>
<li>恢复下一个进程的上下文以继续执行。</li>
<li>包括程序计数器、寄存器、内存管理信息等。</li>
<li>切换速度受硬件和操作系统机制影响。</li>
</ul>
<h5 id="进程树与系统工具">3.8 进程树与系统工具</h5>
<ul>
<li>使用 <code>ps -ael</code> 查看UNIX/Linux进程树。</li>
<li>Windows可用Process Monitor查看进程父子关系。</li>
<li>init/systemd负责回收孤儿进程资源。</li>
</ul>
<h5 id="进程创建与终止">3.9 进程创建与终止</h5>
<ul>
<li>fork() 创建子进程，exec() 替换地址空间。</li>
<li>wait() 系统调用用于父进程等待子进程结束。</li>
<li>子进程未被wait()回收将变为僵尸进程。</li>
<li>父进程结束后，init/systemd接管孤儿进程。</li>
</ul>
<h5 id="进程数量计算示例">3.10 进程数量计算示例</h5>
<ul>
<li>图中程序循环4次调用fork()，共创建15个子进程（包括初始进程）。</li>
</ul>
<h5 id="ipc通信方式比较">3.11 IPC通信方式比较</h5>
<ul>
<li>普通管道适用于父子进程间临时通信。</li>
<li>命名管道支持无亲缘关系进程通信。</li>
<li>RPC若不保证“最多一次”或“恰好一次”语义可能导致重复请求或丢失。</li>
</ul>
<h5 id="共享内存与消息传递">3.12 共享内存与消息传递</h5>
<ul>
<li>共享内存实现高效数据交换，但需同步机制。</li>
<li>消息传递适用于分布式系统，提供更高抽象层次。</li>
<li>同步方式：阻塞/非阻塞发送与接收。</li>
<li>缓冲机制：零容量、有界容量、无界容量。</li>
</ul>
<h5 id="编程问题解析">3.13 编程问题解析</h5>
<h6 id="创建僵尸进程">3.18 创建僵尸进程</h6>
<ul>
<li>子进程退出后父进程不调用wait()。</li>
<li>可通过<code>ps -l</code>查看Z状态确认。</li>
<li>使用kill命令终止父进程可清除僵尸进程。</li>
</ul>
<h6 id="测量命令执行时间">3.19 测量命令执行时间</h6>
<ul>
<li>使用共享内存或管道在父子进程间传输开始时间。</li>
<li>gettimeofday()获取微秒级时间戳。</li>
<li>父进程等待子进程结束并计算时间差。</li>
</ul>
<h6 id="pid管理器">3.20 PID管理器</h6>
<ul>
<li>定义PID范围为300~5000。</li>
<li>使用位图表示PID使用状态。</li>
<li>实现allocate_map(), allocate_pid(), release_pid()接口。</li>
</ul>
<h6 id="collatz猜想多进程实现">3.21 Collatz猜想多进程实现</h6>
<ul>
<li>子进程生成序列并输出。</li>
<li>父进程调用wait()等待子进程完成。</li>
<li>需验证输入是否为正整数。</li>
</ul>
<h6 id="使用共享内存优化collatz程序">3.22
使用共享内存优化Collatz程序</h6>
<ul>
<li>父进程创建共享内存区域。</li>
<li>子进程写入序列数据。</li>
<li>父进程读取并输出，使用wait()同步。</li>
</ul>
<h6 id="网络服务实现">3.23~3.25 网络服务实现</h6>
<ul>
<li>修改日期服务器为“每日一句”服务器，监听端口6017。</li>
<li>实现Haiku诗歌服务器，监听端口5575。</li>
<li>编写回声服务器，使用InputStream处理二进制数据。</li>
</ul>
<h6 id="管道通信编程">3.26~3.27 管道通信编程</h6>
<ul>
<li>设计双管道实现字符串大小写反转通信。</li>
<li>filecopy.c使用管道复制文件内容。</li>
<li>父进程写入管道，子进程读取并写入目标文件。#### 编程项目</li>
<li>项目目标：设计一个C程序作为shell接口，支持命令执行、输入输出重定向、管道通信。</li>
</ul>
<h5 id="项目1unix-shell">项目1：UNIX Shell</h5>
<ul>
<li>功能要求：
<ul>
<li>接收用户命令并创建子进程执行。</li>
<li>支持后台运行（使用&amp;符号）。</li>
<li>支持命令历史（!!执行上一条命令）。</li>
<li>支持输入输出重定向（&lt; 和 &gt;）。</li>
<li>支持管道通信（|）。</li>
</ul></li>
<li>使用系统调用：
<ul>
<li>fork()：创建子进程。</li>
<li>execvp()：执行命令。</li>
<li>wait()：等待子进程结束。</li>
<li>dup2()：重定向标准输入输出。</li>
<li>pipe()：建立进程间管道。</li>
</ul></li>
<li>程序结构：
<ul>
<li>main()函数循环读取命令、解析参数、执行命令。</li>
<li>支持命令参数数组解析（args）。</li>
<li>支持错误处理（如无历史命令时输入!!）。</li>
</ul></li>
</ul>
<h5
id="项目2linux内核模块显示任务信息">项目2：Linux内核模块显示任务信息</h5>
<ul>
<li>功能：
<ul>
<li>通过写入/proc/pid获取进程信息。</li>
<li>读取/proc/pid显示命令名、PID、状态。</li>
</ul></li>
<li>关键函数：
<ul>
<li>proc_write()：接收用户写入的PID。</li>
<li>pid_task()：通过PID获取task_struct。</li>
<li>copy_from_user(), kstrtol()：用户空间数据处理。</li>
</ul></li>
<li>内存管理：
<ul>
<li>kmalloc() / kfree()：分配和释放内核内存。</li>
<li>注意防止内存泄漏。</li>
</ul></li>
</ul>
<h5
id="项目3linux内核模块列出所有任务">项目3：Linux内核模块列出所有任务</h5>
<h6 id="部分一线性遍历任务">部分一：线性遍历任务</h6>
<ul>
<li>使用宏for_each_process()遍历所有任务。</li>
<li>输出每个任务的命令名、状态、PID。</li>
<li>模块加载时输出到内核日志（dmesg查看）。</li>
<li>与ps -el命令对比验证。</li>
</ul>
<h6 id="部分二深度优先遍历任务树">部分二：深度优先遍历任务树</h6>
<ul>
<li>使用init_task作为根节点。</li>
<li>使用children和sibling字段遍历进程树。</li>
<li>使用list_for_each()宏遍历子进程链表。</li>
<li>输出任务信息并与ps -eLf对比验证。</li>
</ul>
<h5 id="项目4内核数据结构">项目4：内核数据结构</h5>
<h6 id="部分一链表操作">部分一：链表操作</h6>
<ul>
<li>定义结构体struct color，包含红、蓝、绿三色值。</li>
<li>使用Linux内核链表结构struct list_head。</li>
<li>实现链表操作：
<ul>
<li>LIST_HEAD()：定义链表头。</li>
<li>INIT_LIST_HEAD()：初始化节点。</li>
<li>list_add_tail()：尾部插入节点。</li>
<li>list_for_each_entry()：遍历链表。</li>
<li>list_del()：删除节点。</li>
<li>list_for_each_entry_safe()：安全删除遍历。</li>
</ul></li>
<li>模块加载时创建并输出四个颜色节点；卸载时释放内存。</li>
</ul>
<h6 id="部分二模块参数传递">部分二：模块参数传递</h6>
<ul>
<li>使用module_param()传递整型参数。</li>
<li>示例：insmod collatz.ko start=15。</li>
<li>默认值设置：start=25。</li>
<li>生成Collatz序列并存储在链表中。</li>
<li>加载时输出序列，卸载时清理内存。</li>
</ul>
<h1 id="第四章-进程操作与进程间通信">第四章 进程操作与进程间通信</h1>
<h2 id="进程操作-1">3.3 进程操作</h2>
<h3 id="进程终止-1">3.3.2 进程终止</h3>
<ul>
<li>进程执行完最后一条指令后通过 exit()
系统调用请求操作系统删除它。</li>
<li>终止时，进程可返回状态值给父进程（通过 wait() 系统调用）。</li>
<li>操作系统回收进程的所有资源（内存、文件、I/O 缓冲区等）。</li>
<li>进程可通过 TerminateProcess() 等系统调用被其他进程终止。</li>
<li>父进程可因以下原因终止子进程：
<ul>
<li>子进程超过资源配额。</li>
<li>子进程任务不再需要。</li>
<li>父进程退出，操作系统不允许子进程继续存在。</li>
</ul></li>
<li>如果父进程未调用 wait() 就退出，子进程会变成“孤儿进程”，init 或
systemd 会接管这些进程并调用 wait() 回收它们。</li>
<li>已终止但未被父进程调用 wait() 的进程称为“僵尸进程”。</li>
</ul>
<h3 id="android-进程层级">3.3.2.1 Android 进程层级</h3>
<ul>
<li>Android
根据资源重要性对进程进行分类，系统终止进程时优先结束重要性较低的进程。</li>
<li>进程分类（从高到低）：
<ul>
<li>前台进程（用户当前交互的应用）。</li>
<li>可见进程（非前台但被前台引用的进程）。</li>
<li>服务进程（如音乐播放）。</li>
<li>后台进程（用户不可见但运行任务的进程）。</li>
<li>空进程（无活跃组件的进程）。</li>
</ul></li>
<li>Android 会尽量赋予进程尽可能高的优先级。</li>
<li>开发者应遵循进程生命周期规范，以实现状态保存和恢复。</li>
</ul>
<h2 id="进程间通信ipc-1">3.4 进程间通信（IPC）</h2>
<h3 id="ipc-的基本模型">3.4.1 IPC 的基本模型</h3>
<ul>
<li>进程可分为独立进程（不共享数据）和协作进程（共享数据）。</li>
<li>协作进程需通过 IPC 机制进行通信，主要有两种模型：
<ul>
<li>共享内存模型：多个进程访问同一内存区域进行数据交换。</li>
<li>消息传递模型：进程通过发送和接收消息进行通信。</li>
</ul></li>
</ul>
<h3 id="chrome-浏览器的多进程架构">3.4.2 Chrome 浏览器的多进程架构</h3>
<ul>
<li>Chrome
使用多进程架构隔离网页内容，防止一个网页崩溃影响整个浏览器。</li>
<li>主要进程类型：
<ul>
<li>浏览器进程：管理 UI、磁盘和网络 I/O。</li>
<li>渲染器进程：处理 HTML、JavaScript、图像等。</li>
<li>插件进程：运行 Flash、QuickTime 等插件。</li>
</ul></li>
<li>渲染器进程运行在沙箱中，限制对系统资源的访问。</li>
</ul>
<h2 id="共享内存中的-ipc">3.5 共享内存中的 IPC</h2>
<h3 id="共享内存通信机制">3.5.1 共享内存通信机制</h3>
<ul>
<li>协作进程需建立共享内存区域，其他进程将其附加到自己的地址空间。</li>
<li>共享内存通信速度快，但需要进程自行同步访问。</li>
<li>示例：生产者-消费者问题使用共享内存实现。
<ul>
<li>共享缓冲区使用循环数组，in 和 out 指针管理。</li>
<li>生产者等待缓冲区不满，消费者等待缓冲区不空。</li>
<li>代码实现需注意并发访问同步问题。</li>
</ul></li>
</ul>
<h3 id="posix-共享内存-api">3.5.2 POSIX 共享内存 API</h3>
<ul>
<li>使用 shm_open() 创建共享内存对象。</li>
<li>使用 ftruncate() 设置共享内存大小。</li>
<li>使用 mmap() 将共享内存映射到进程地址空间。</li>
<li>示例：生产者写入 “Hello World!”，消费者读取并输出。</li>
</ul>
<h2 id="消息传递系统中的-ipc">3.6 消息传递系统中的 IPC</h2>
<h3 id="命名机制">3.6.1 命名机制</h3>
<ul>
<li>进程通信可采用直接通信（明确指定发送者或接收者）或间接通信（通过邮箱或端口）。</li>
<li>直接通信：send(P, message)、receive(Q,
message)，通信链路自动建立。</li>
<li>间接通信：通过邮箱（Mailbox）收发消息，多个进程可共享邮箱。</li>
<li>邮箱可由进程或操作系统拥有，操作系统需提供创建、发送、接收、删除邮箱的机制。</li>
</ul>
<h3 id="同步机制">3.6.2 同步机制</h3>
<ul>
<li>send() 和 receive() 可为阻塞或非阻塞：
<ul>
<li>阻塞发送：发送进程等待消息被接收。</li>
<li>非阻塞发送：发送进程立即返回。</li>
<li>阻塞接收：接收进程等待消息到达。</li>
<li>非阻塞接收：接收进程获取有效消息或空值。</li>
</ul></li>
<li>若 send() 和 receive() 均为阻塞，则形成“同步握手”。</li>
</ul>
<h3 id="缓冲机制-1">3.6.3 缓冲机制</h3>
<ul>
<li>消息队列可实现为三种方式：
<ul>
<li>零容量：发送者必须等待接收者接收消息。</li>
<li>有限容量：最多 n 个消息，满时发送者等待。</li>
<li>无限容量：发送者永不等待。</li>
</ul></li>
<li>零容量称为无缓冲消息系统，其他称为自动缓冲系统。</li>
</ul>
<h2 id="ipc-系统示例">3.7 IPC 系统示例</h2>
<h3 id="posix-共享内存">3.7.1 POSIX 共享内存</h3>
<ul>
<li>使用内存映射文件实现共享内存。</li>
<li>示例：生产者写入共享内存，消费者读取并输出。</li>
</ul>
<h3 id="mach-消息传递">3.7.2 Mach 消息传递</h3>
<ul>
<li>Mach 操作系统支持任务（类似进程）间的消息传递。</li>
<li>消息通过端口（Port）收发，端口为单向，支持双向通信需两个端口。</li>
<li>每个端口有端口权限（Port Rights），如 MACH_PORT_RIGHT_RECEIVE。</li>
<li>使用 mach_msg() 实现消息发送和接收。</li>
</ul>
<h3 id="windows-ipc">3.7.3 Windows IPC</h3>
<ul>
<li>Windows 使用 ALPC（高级本地过程调用）机制进行进程间通信。</li>
<li>ALPC 支持三种消息传递方式：
<ul>
<li>小消息（≤256 字节）直接复制。</li>
<li>大消息通过共享内存段（Section Object）传输。</li>
<li>超大消息允许服务器直接读写客户端地址空间。</li>
</ul></li>
<li>ALPC 不是公开 API，应用程序通过 RPC 调用间接使用。</li>
</ul>
<h3 id="管道pipes-1">3.7.4 管道（Pipes）</h3>
<h4 id="普通管道ordinary-pipes-1">3.7.4.1 普通管道（Ordinary
Pipes）</h4>
<ul>
<li>UNIX 和 Windows 都支持普通管道，用于父子进程间单向通信。</li>
<li>UNIX 使用 pipe() 创建管道，读写端分别用 fd[0] 和 fd[1]。</li>
<li>Windows 使用 CreatePipe() 创建匿名管道，需设置 SECURITY_ATTRIBUTES
和 STARTUPINFO。</li>
</ul>
<h4 id="命名管道named-pipes-1">3.7.4.2 命名管道（Named Pipes）</h4>
<ul>
<li>命名管道可在不同进程间通信，无需父子关系。</li>
<li>UNIX 命名管道称为 FIFO，使用 mkfifo() 创建。</li>
<li>Windows 命名管道支持全双工通信，使用 CreateNamedPipe() 创建。</li>
</ul>
<h2 id="客户端-服务器系统中的通信">3.8 客户端-服务器系统中的通信</h2>
<h3 id="套接字sockets-1">3.8.1 套接字（Sockets）</h3>
<ul>
<li>套接字提供跨网络的进程间通信机制。</li>
<li>支持 TCP（面向连接）和 UDP（无连接）协议。</li>
<li>套接字编程接口包括
socket()、bind()、listen()、accept()、connect()、send()、recv()
等函数。</li>
</ul>
<h3 id="远程过程调用rpc-1">3.8.2 远程过程调用（RPC）</h3>
<ul>
<li>RPC 允许程序调用远程主机上的过程，如同本地调用一样。</li>
<li>RPC 系统自动处理通信细节，如参数打包、网络传输、结果返回。</li>
<li>Windows 使用 ALPC 优化本地 RPC 调用。#### 3.8
客户端-服务器系统中的通信</li>
<li>套接字（Socket）是一个通信端点，通常使用客户端-服务器架构。</li>
<li>套接字由IP地址和端口号组成，服务器监听特定端口以接收客户端请求。</li>
<li>所有低于1024的端口被认为是知名端口，用于标准服务（如SSH、FTP、HTTP）。</li>
<li>客户端发起连接时会被分配一个大于1024的随机端口，确保连接唯一。</li>
<li>示例说明了使用Java实现的日期服务器和客户端，使用TCP套接字进行通信。</li>
<li>套接字通信虽然高效，但属于低级通信方式，仅支持无结构的字节流。</li>
</ul>
<h5 id="套接字">3.8.1 套接字</h5>
<ul>
<li>Java提供了三种类型的套接字：Socket（TCP）、DatagramSocket（UDP）和MulticastSocket。</li>
<li>示例展示了使用ServerSocket和Socket类实现的日期服务器。</li>
<li>客户端通过Socket连接到服务器并读取返回的日期信息。</li>
<li>使用IP地址127.0.0.1（回环地址）可以实现本机客户端与服务器通信。</li>
</ul>
<h5 id="远程过程调用rpc-2">3.8.2 远程过程调用（RPC）</h5>
<ul>
<li>RPC是一种抽象的远程服务机制，允许客户端像调用本地函数一样调用远程函数。</li>
<li>每个RPC消息包含目标函数标识和参数，通过端口与RPC守护进程通信。</li>
<li>参数编组（marshaling）解决客户端与服务器之间数据表示差异问题。</li>
<li>使用外部数据表示（XDR）实现机器无关的数据格式。</li>
<li>RPC调用语义包括“最多一次”和“恰好一次”两种，分别处理网络错误导致的重复调用问题。</li>
<li>“恰好一次”需要服务器确认调用已执行，客户端持续重试直到收到确认。</li>
<li>客户端与服务器之间的绑定可以通过固定端口或通过“会合机制”动态获取端口实现。</li>
</ul>
<h5 id="android中的rpc-1">3.8.2.1 Android中的RPC</h5>
<ul>
<li>Android使用Binder框架支持RPC，允许进程间通信。</li>
<li>应用组件Service可通过绑定实现客户端-服务器通信。</li>
<li>使用AIDL（Android接口定义语言）定义远程接口，并生成Stub文件。</li>
<li>客户端通过bindService()绑定服务，并调用远程方法。</li>
<li>Android内部处理参数编组、跨进程传递、调用服务实现并返回结果。</li>
</ul>
<h4 id="小结">3.9 小结</h4>
<ul>
<li>进程是正在执行的程序，状态由程序计数器和其他寄存器表示。</li>
<li>进程在内存中分为四个部分：文本段、数据段、堆和栈。</li>
<li>进程状态包括就绪、运行、等待和终止。</li>
<li>进程控制块（PCB）是操作系统中表示进程的数据结构。</li>
<li>进程调度器负责选择可用进程在CPU上运行。</li>
<li>上下文切换发生在切换运行进程时。</li>
<li>fork()和CreateProcess()分别用于在UNIX和Windows中创建进程。</li>
<li>共享内存允许多个进程共享同一内存区域。</li>
<li>消息传递是进程间通信的另一种方式，Mach和Windows都支持。</li>
<li>管道（Pipe）提供两个进程之间的通信通道，分为普通管道和命名管道。</li>
<li>UNIX使用pipe()系统调用创建普通管道，命名管道称为FIFO。</li>
<li>Windows提供匿名管道和命名管道，后者功能更强大。</li>
<li>客户端-服务器通信常用方式包括套接字和远程过程调用（RPC）。</li>
<li>Android使用Binder框架支持RPC作为进程间通信机制。#### 编程项目</li>
<li>项目1—UNIX
Shell：设计一个C程序作为Shell接口，支持用户命令的输入、执行、输入输出重定向和管道通信。</li>
<li>使用系统调用如fork()、exec()、wait()、dup2()和pipe()。</li>
<li>支持后台运行命令（使用&amp;符号）。</li>
<li>实现命令历史功能，用户可通过!!执行最近一次命令。</li>
<li>支持输入输出重定向（&gt; 和 &lt; 操作符）。</li>
<li>实现进程间通信（使用管道|操作符）。</li>
<li>项目2—Linux内核模块用于显示任务信息：编写内核模块，通过/proc/pid文件显示任务的命令名、PID和状态。</li>
<li>用户通过echo写入PID，通过cat读取任务信息。</li>
<li>使用kstrtol()将字符串转换为整数，使用proc_write()函数处理写入。</li>
<li>使用task_struct结构获取任务信息。</li>
<li>项目3—Linux内核模块用于列出所有任务：通过for_each_process()宏线性遍历任务。</li>
<li>使用深度优先搜索（DFS）遍历任务树，从init_task开始遍历子进程。</li>
<li>输出任务的命令名、状态和PID，并与ps命令结果对比验证。</li>
<li>项目4—内核数据结构：使用Linux内核提供的链表结构实现颜色结构的插入、遍历和删除。</li>
<li>使用LIST_HEAD()定义链表头，INIT_LIST_HEAD()初始化链表成员。</li>
<li>使用list_add_tail()添加节点，list_for_each_entry()遍历链表。</li>
<li>使用list_del()删除节点，并用kfree()释放内存。</li>
<li>模块入口中创建四个颜色结构节点并输出到日志，模块出口中删除节点并释放内存。</li>
<li>参数传递部分：通过insmod传递参数给内核模块，如初始值start=15。</li>
<li>内核模块使用module_param()声明参数，生成Collatz序列并存储在链表中。</li>
<li>模块加载时生成并输出序列，模块卸载时清理链表内存。###
线程与并发</li>
</ul>
<h4 id="概述">4.1 概述</h4>
<ul>
<li>线程是CPU调度的基本单位，包括线程ID、程序计数器、寄存器集合和栈。</li>
<li>同一进程的线程共享代码段、数据段、打开的文件和信号等资源。</li>
<li>多线程进程可以同时执行多个任务，例如浏览器同时显示内容和下载数据。</li>
<li>在多核系统中，多线程可充分利用多个CPU核心提升性能。</li>
<li>使用多线程的Web服务器可以同时处理多个客户端请求，提高效率。</li>
<li>Linux内核本身也使用多线程处理设备管理、内存管理和中断处理等任务。</li>
</ul>
<h5 id="动机">4.1.1 动机</h5>
<ul>
<li>图像处理应用可为每张图片生成缩略图使用单独线程。</li>
<li>浏览器可使用不同线程进行网络数据下载和内容显示。</li>
<li>文字处理软件可使用多个线程分别处理图形显示、键盘响应和拼写检查。</li>
<li>多线程Web服务器可创建多个线程处理请求，而无需创建新进程，节省资源。</li>
</ul>
<h5 id="优势">4.1.2 优势</h5>
<ul>
<li>响应性：多线程应用在执行耗时操作时仍能保持用户界面响应。</li>
<li>资源共享：线程默认共享进程资源，便于在同一个地址空间中实现多任务。</li>
<li>经济性：线程创建和上下文切换比进程更节省时间和内存。</li>
<li>可扩展性：多线程在多核系统中可真正实现并行执行，提升性能。</li>
</ul>
<h4 id="多核编程">4.2 多核编程</h4>
<ul>
<li>单核系统中线程是并发执行（时间交错），多核系统中可实现真正的并行执行。</li>
<li>并发表示多个任务交替执行，而并行表示多个任务同时执行。</li>
</ul>
<h5 id="编程挑战">4.2.1 编程挑战</h5>
<ul>
<li>任务识别：将应用划分为可并行执行的独立任务。</li>
<li>负载均衡：确保各任务工作量均衡，避免资源浪费。</li>
<li>数据划分：将任务处理的数据分割以支持并行。</li>
<li>数据依赖：确保任务间数据依赖关系正确同步。</li>
<li>测试调试：多线程程序的执行路径复杂，测试和调试难度大。</li>
</ul>
<h5 id="并行类型">4.2.2 并行类型</h5>
<ul>
<li>数据并行：将相同数据的不同子集分配到不同核心处理，如数组求和。</li>
<li>任务并行：将不同任务分配到不同核心处理，如对同一数组执行不同统计操作。</li>
<li>实际应用中常结合数据并行和任务并行策略。</li>
</ul>
<h4 id="多线程模型">4.3 多线程模型</h4>
<ul>
<li>线程可在用户空间或内核空间实现。</li>
<li>用户线程由线程库管理，内核线程由操作系统直接管理。</li>
</ul>
<h5 id="多对一模型">4.3.1 多对一模型</h5>
<ul>
<li>多个用户线程映射到一个内核线程，线程管理效率高。</li>
<li>但一个线程阻塞会导致整个进程阻塞，且无法在多核上并行执行。</li>
<li>早期的Green线程库采用此模型。</li>
</ul>
<h5 id="一对一模型">4.3.2 一对一模型</h5>
<ul>
<li>每个用户线程对应一个内核线程，允许线程阻塞时其他线程继续执行。</li>
<li>支持多核并行，但大量线程可能影响系统性能。</li>
<li>Linux和Windows采用此模型。</li>
</ul>
<h5 id="多对多模型">4.3.3 多对多模型</h5>
<ul>
<li>多个用户线程映射到少量或等量的内核线程，支持灵活的并发执行。</li>
<li>不受线程数量限制，适合多核系统。</li>
<li>有些系统支持两层模型，允许用户线程绑定到内核线程。</li>
<li>实际实现复杂，多数系统仍采用一对一模型。</li>
</ul>
<h4 id="线程库">4.4 线程库</h4>
<ul>
<li>线程库提供创建和管理线程的API。</li>
<li>线程库可在用户空间或内核空间实现。</li>
</ul>
<h5 id="posix线程pthreads">4.4.1 POSIX线程（Pthreads）</h5>
<ul>
<li>Pthreads是POSIX标准定义的线程API，可实现为用户级或内核级线程。</li>
<li>示例程序使用pthread_create创建线程，pthread_join等待线程结束。</li>
<li>可使用循环等待多个线程完成。</li>
</ul>
<h5 id="windows线程">4.4.2 Windows线程</h5>
<ul>
<li>Windows线程库使用CreateThread创建线程，WaitForSingleObject等待线程结束。</li>
<li>支持等待多个线程的WaitForMultipleObjects函数。</li>
</ul>
<h5 id="java线程">4.4.3 Java线程</h5>
<ul>
<li>Java线程基于Thread类或Runnable接口实现。</li>
<li>使用Lambda表达式简化线程创建语法。</li>
<li>Java线程通过join()方法等待线程完成。</li>
<li>Java Executor框架提供更高级的线程管理功能。</li>
</ul>
<h6 id="java-executor框架">Java Executor框架</h6>
<ul>
<li>Executor接口提供execute方法执行任务。</li>
<li>ExecutorService扩展Executor，支持任务提交和线程池管理。</li>
<li>Callable接口支持返回结果的任务，Future对象用于获取结果。</li>
<li>示例程序使用Callable实现数组求和，ExecutorService执行任务。</li>
</ul>
<h4 id="隐式线程">4.5 隐式线程</h4>
<ul>
<li>隐式线程将线程创建和管理交给编译器和运行库，开发者只需识别可并行任务。</li>
</ul>
<h5 id="线程池">4.5.1 线程池</h5>
<ul>
<li>线程池在启动时创建多个线程并放入池中，按需分配任务。</li>
<li>优点包括快速响应请求、限制线程数量、支持不同任务调度策略。</li>
<li>Windows和Java均提供线程池支持。</li>
</ul>
<h6 id="java线程池">Java线程池</h6>
<ul>
<li>Java的Executors类提供newSingleThreadExecutor、newFixedThreadPool和newCachedThreadPool三种线程池。</li>
<li>示例程序使用newCachedThreadPool创建线程池并执行任务。</li>
</ul>
<h5 id="fork-join模型">4.5.2 Fork-Join模型</h5>
<ul>
<li>Fork-Join模型通过分治算法将任务拆分为子任务并行执行。</li>
<li>Java的ForkJoinPool实现该模型，支持递归任务拆分。</li>
<li>示例程序使用ForkJoinPool计算数组求和。</li>
</ul>
<h6 id="java中的fork-join">Java中的Fork-Join</h6>
<ul>
<li>ForkJoinTask是抽象基类，RecursiveTask返回结果，RecursiveAction不返回结果。</li>
<li>SumTask类实现RecursiveTask，compute方法执行分治计算。</li>
<li>THRESHOLD参数决定何时直接计算而非继续拆分任务。</li>
</ul>
<h5 id="openmp">4.5.3 OpenMP</h5>
<ul>
<li>OpenMP是一组用于C/C++/FORTRAN的编译指令和API，支持共享内存环境下的并行编程。</li>
<li>使用#pragma omp parallel指令创建线程，线程数由系统核心数决定。</li>
<li>支持并行化循环，如#pragma omp parallel for。</li>
</ul>
<h5 id="grand-central-dispatchgcd">4.5.4 Grand Central
Dispatch（GCD）</h5>
<ul>
<li>GCD是Apple开发的并发技术，结合运行库、API和语言扩展。</li>
<li>任务通过dispatch队列调度，分为串行队列和并发队列。</li>
<li>并发队列分为四个服务质量等级：用户交互、用户发起、实用工具、后台。</li>
<li>使用Block或Closure定义任务，dispatch_async提交任务。</li>
</ul>
<h5 id="intel线程构建模块tbb">4.5.5 Intel线程构建模块（TBB）</h5>
<ul>
<li>TBB是C++模板库，支持并行编程，无需特殊编译器支持。</li>
<li>提供parallel_for等模板实现并行循环。</li>
<li>自动划分任务并负载均衡，优先执行缓存命中任务。</li>
<li>提供线程安全的数据结构如并发哈希表、队列和向量。#### 4.6
线程问题</li>
<li>在多线程程序设计中需要考虑多个问题，包括系统调用、信号处理、线程取消、线程局部存储和调度激活等。</li>
</ul>
<h5 id="fork-和-exec-系统调用">4.6.1 fork() 和 exec() 系统调用</h5>
<ul>
<li><code>fork()</code>
创建新进程时，在多线程程序中需决定是否复制所有线程或仅复制调用线程。</li>
<li>一些 UNIX 系统提供两个版本的
<code>fork()</code>，一个复制所有线程，另一个仅复制调用线程。</li>
<li><code>exec()</code> 会替换整个进程（包括所有线程），因此若在
<code>fork()</code> 后立即调用
<code>exec()</code>，仅复制调用线程即可；否则应复制所有线程。</li>
</ul>
<h5 id="信号处理">4.6.2 信号处理</h5>
<ul>
<li>信号用于通知进程某个事件发生，分为同步信号（如非法内存访问）和异步信号（如
<control><C> 终止进程）。</li>
<li>多线程程序中，信号可被发送到特定线程、所有线程、某些线程或指定线程。</li>
<li>同步信号应发送给引发信号的线程，异步信号通常发送给未阻塞该信号的第一个线程。</li>
<li>POSIX 提供 <code>pthread_kill()</code>
函数将信号发送到指定线程，Windows 使用异步过程调用（APC）模拟信号。</li>
</ul>
<h5 id="线程取消">4.6.3 线程取消</h5>
<ul>
<li>线程取消包括异步取消（立即终止线程）和延迟取消（线程周期性检查是否应终止）。</li>
<li>异步取消可能导致资源无法释放或数据不一致，因此推荐使用延迟取消。</li>
<li>Pthreads 提供 <code>pthread_cancel()</code>
取消线程，并支持三种取消模式：禁用、延迟取消和异步取消。</li>
<li>默认使用延迟取消，通过 <code>pthread_testcancel()</code>
检查是否收到取消请求，并可在取消时调用清理函数释放资源。</li>
<li>Java 中通过 <code>interrupt()</code> 方法设置中断状态，线程通过
<code>isInterrupted()</code> 检查中断状态并响应取消请求。</li>
</ul>
<h5 id="线程局部存储-tls">4.6.4 线程局部存储 (TLS)</h5>
<ul>
<li>线程局部存储允许每个线程拥有独立的数据副本，适用于每个线程需维护独立状态的场景。</li>
<li>TLS 与局部变量不同，其作用域跨越多个函数调用。</li>
<li>Java 使用 <code>ThreadLocal&lt;T&gt;</code> 类实现 TLS，Pthreads
使用 <code>pthread_key_t</code>，C# 使用
<code>[ThreadStatic]</code>，gcc 使用 <code>thread</code> 关键字。</li>
</ul>
<h5 id="调度激活">4.6.5 调度激活</h5>
<ul>
<li>多对多和两级线程模型中需要内核与线程库通信，通过轻量级进程（LWP）协调用户线程与内核线程。</li>
<li>调度激活机制允许内核通知应用程序线程阻塞或唤醒事件，确保线程调度高效。</li>
<li>当线程阻塞时，内核分配新 LWP
并运行上行调用处理程序保存阻塞线程状态，调度其他线程运行。</li>
</ul>
<h4 id="操作系统示例">4.7 操作系统示例</h4>
<h5 id="windows-线程">4.7.1 Windows 线程</h5>
<ul>
<li>Windows 使用一对一模型，每个用户线程对应一个内核线程。</li>
<li>线程结构包括线程
ID、寄存器集、程序计数器、用户栈和内核栈、私有存储区。</li>
<li>主要数据结构为 ETHREAD（线程控制块）、KTHREAD（内核线程块）和
TEB（线程环境块）。</li>
</ul>
<h5 id="linux-线程">4.7.2 Linux 线程</h5>
<ul>
<li>Linux 使用 <code>clone()</code>
系统调用创建线程，通过标志位控制父子任务的资源共享程度。</li>
<li><code>clone()</code>
可创建类似进程或线程的任务，未设置标志时行为等同于
<code>fork()</code>。</li>
<li>Linux 将线程和进程统称为任务，使用 <code>struct task_struct</code>
表示每个任务。</li>
<li><code>clone()</code> 的灵活性支持容器技术，允许创建隔离的 Linux
系统实例。</li>
</ul>
<h4 id="小结-1">4.8 小结</h4>
<ul>
<li>线程是 CPU 调度的基本单位，共享进程资源如代码和数据。</li>
<li>多线程应用的四大优势：响应性、资源共享、经济性和可扩展性。</li>
<li>多线程程序设计挑战包括任务划分、数据共享、依赖识别和调试。</li>
<li>数据并行和任务并行分别用于分布式数据和任务。</li>
<li>线程库如 Windows、Pthreads 和 Java 提供线程创建和管理 API。</li>
<li>隐式线程通过线程池、fork-join 框架等机制简化并发编程。</li>
<li>线程取消支持异步和延迟两种方式，推荐使用延迟取消。</li>
<li>Linux 不区分线程和进程，使用 <code>clone()</code>
实现灵活的任务创建。### CPU调度</li>
</ul>
<h4 id="基本概念">5.1 基本概念</h4>
<h5 id="cpuio突发周期">5.1.1 CPU–I/O突发周期</h5>
<ul>
<li>进程执行由CPU执行和I/O等待交替组成。</li>
<li>大多数CPU突发时间较短，少数较长，分布呈指数或超指数形式。</li>
<li>I/O密集型程序有大量短CPU突发，CPU密集型程序有少量长CPU突发。</li>
</ul>
<h5 id="cpu调度器">5.1.2 CPU调度器</h5>
<ul>
<li>当CPU空闲时，调度器从就绪队列中选择一个进程执行。</li>
<li>就绪队列可以是FIFO、优先队列、树或无序链表。</li>
<li>队列中的记录通常是进程控制块（PCB）。</li>
</ul>
<h5 id="抢占式与非抢占式调度">5.1.3 抢占式与非抢占式调度</h5>
<ul>
<li>调度决策发生在进程状态转换时。</li>
<li>非抢占式调度仅在进程等待或终止时调度，抢占式调度可在任何时间中断进程。</li>
<li>现代系统如Windows、Linux、UNIX等使用抢占式调度。</li>
<li>抢占可能导致竞态条件和内核设计复杂性。</li>
</ul>
<h5 id="分派器">5.1.4 分派器</h5>
<ul>
<li>分派器将CPU控制权交给调度器选中的进程。</li>
<li>包括上下文切换、切换到用户模式、跳转到用户程序恢复执行。</li>
<li>分派延迟是指分派器停止一个进程并启动另一个进程所需的时间。</li>
</ul>
<h4 id="调度准则">5.2 调度准则</h4>
<ul>
<li>CPU利用率：尽可能保持CPU忙碌，通常在40%到90%之间。</li>
<li>吞吐量：单位时间内完成的进程数量。</li>
<li>周转时间：从进程提交到完成的总时间。</li>
<li>等待时间：在就绪队列中等待的时间。</li>
<li>响应时间：从请求提交到首次响应的时间。</li>
<li>目标是最大化CPU利用率和吞吐量，最小化周转时间、等待时间和响应时间。</li>
</ul>
<h4 id="调度算法">5.3 调度算法</h4>
<h5 id="先来先服务调度fcfs">5.3.1 先来先服务调度（FCFS）</h5>
<ul>
<li>最简单的调度算法，使用FIFO队列。</li>
<li>平均等待时间可能较长。</li>
<li>可能导致“车队效应”，降低CPU和设备利用率。</li>
<li>非抢占式，适用于批处理系统，不适用于交互式系统。</li>
</ul>
<h5 id="最短作业优先调度sjf">5.3.2 最短作业优先调度（SJF）</h5>
<ul>
<li>最优调度算法，最小化平均等待时间。</li>
<li>需要知道下一次CPU突发时间，实际中不可实现。</li>
<li>使用指数平均预测下一次CPU突发时间。</li>
<li>可分为抢占式（最短剩余时间优先）和非抢占式。</li>
</ul>
<h5 id="轮转调度rr">5.3.3 轮转调度（RR）</h5>
<ul>
<li>类似FCFS，但加入时间片（时间量子）机制。</li>
<li>时间片通常为10到100毫秒。</li>
<li>抢占式调度，确保公平分配CPU时间。</li>
<li>平均等待时间较长，但适用于交互式系统。</li>
<li>时间片大小影响性能：过大退化为FCFS，过小导致频繁上下文切换。</li>
</ul>
<h5 id="优先级调度">5.3.4 优先级调度</h5>
<ul>
<li>SJF是优先级调度的特例，优先级由预测的CPU突发时间决定。</li>
<li>可分为抢占式和非抢占式。</li>
<li>存在“无限阻塞”或“饥饿”问题，可通过“老化”机制解决。</li>
<li>优先级可由内部或外部因素定义。</li>
</ul>
<h5 id="多级队列调度">5.3.5 多级队列调度</h5>
<ul>
<li>将进程按类型分到不同队列，每个队列可有不同调度算法。</li>
<li>队列之间调度通常采用固定优先级抢占式调度。</li>
<li>例如：前台进程（交互式）使用RR，后台进程（批处理）使用FCFS。</li>
</ul>
<h5 id="多级反馈队列调度">5.3.6 多级反馈队列调度</h5>
<ul>
<li>允许进程在不同队列间移动，根据CPU突发行为调整优先级。</li>
<li>短CPU突发进程保留在高优先级队列，长CPU突发进程降级。</li>
<li>防止饥饿，通过老化机制提升低优先级进程优先级。</li>
<li>参数包括队列数量、每个队列的调度算法、进程升级/降级方法等。</li>
</ul>
<h4 id="线程调度">5.4 线程调度</h4>
<h5 id="竞争范围">5.4.1 竞争范围</h5>
<ul>
<li>用户级线程调度（PCS）：在线程库内部调度，竞争发生在同一进程内的线程之间。</li>
<li>内核级线程调度（SCS）：由操作系统调度，竞争发生在系统内所有线程之间。</li>
<li>多对一和多对多模型使用PCS，一对一模型（如Windows、Linux）使用SCS。</li>
</ul>
<h5 id="pthread调度">5.4.2 Pthread调度</h5>
<ul>
<li>POSIX Pthread
API支持设置竞争范围为PTHREAD_SCOPE_PROCESS（PCS）或PTHREAD_SCOPE_SYSTEM（SCS）。</li>
<li>使用pthread_attr_setscope和pthread_attr_getscope函数设置和获取调度策略。</li>
<li>Linux和macOS仅支持PTHREAD_SCOPE_SYSTEM。</li>
</ul>
<h4 id="多处理器调度">5.5 多处理器调度</h4>
<h5 id="多处理器调度方法">5.5.1 多处理器调度方法</h5>
<ul>
<li>非对称多处理（AMP）：单一主处理器处理所有调度和I/O，其他处理器执行用户代码。</li>
<li>对称多处理（SMP）：每个处理器自我调度，共享就绪队列或各自私有队列。</li>
<li>私有队列减少锁竞争，但需负载均衡算法保持负载均衡。</li>
</ul>
<h5 id="多核处理器">5.5.2 多核处理器</h5>
<ul>
<li>多核处理器在单一芯片上集成多个核心，每个核心相当于一个逻辑CPU。</li>
<li>多线程核心通过硬件线程提升性能，减少内存等待时间。</li>
<li>细粒度和粗粒度多线程技术不同，影响调度策略。</li>
<li>操作系统需考虑线程在逻辑CPU上的调度和核心内硬件线程的调度。</li>
</ul>
<h5 id="负载均衡">5.5.3 负载均衡</h5>
<ul>
<li>负载均衡确保所有处理器负载均衡，提高系统吞吐量。</li>
<li>推迁移（push migration）：定期检查并迁移线程。</li>
<li>拉迁移（pull migration）：空闲处理器主动从繁忙处理器拉取线程。</li>
<li>Linux CFS调度器和FreeBSD ULE调度器同时使用推和拉迁移。</li>
</ul>
<h5 id="处理器亲和性">5.5.4 处理器亲和性</h5>
<ul>
<li>线程在特定处理器上运行后，缓存数据被填充，称为“热缓存”。</li>
<li>迁移线程需清空缓存并重新填充，代价高。</li>
<li>操作系统尽量避免线程迁移，保持“处理器亲和性”。</li>
<li>软亲和性：尽量保持线程在同处理器运行，但不保证。</li>
<li>硬亲和性：通过系统调用指定线程可在哪些处理器上运行。</li>
<li>NUMA系统中，线程应尽量在本地内存访问快的处理器上运行。</li>
</ul>
<h5 id="异构多处理">5.5.5 异构多处理</h5>
<ul>
<li>异构多处理（HMP）使用不同性能和功耗的核心（如ARM
big.LITTLE架构）。</li>
<li>高性能核心用于短时间高负载任务，低功耗核心用于长时间后台任务。</li>
<li>Windows 10支持根据任务需求选择调度策略。#### 5.6 实时CPU调度</li>
<li>实时系统分为软实时系统和硬实时系统，软实时系统不保证关键进程的调度时间，硬实时系统必须在截止时间前完成任务。</li>
<li>事件延迟包括中断延迟和调度延迟，中断延迟是中断到达至服务程序开始的时间，调度延迟是调度器停止当前进程并启动新进程的时间。</li>
<li>实时系统需最小化延迟，硬实时系统要求中断延迟和调度延迟必须被严格限制。</li>
<li>优先级调度算法是实时系统的核心，支持抢占式调度，高优先级进程可抢占低优先级进程。</li>
<li>周期性任务具有固定的处理时间、截止时间和周期，调度器根据任务的截止时间或速率分配优先级。</li>
<li>抢占式优先级调度仅能保证软实时功能，硬实时系统还需额外的调度机制确保任务在截止时间前完成。</li>
</ul>
<h4 id="速率单调调度">5.6.3 速率单调调度</h4>
<ul>
<li>速率单调调度基于静态优先级，任务周期越短优先级越高。</li>
<li>示例：P1周期50，处理时间20；P2周期100，处理时间35，总CPU利用率为75%。若P2优先级高于P1，会导致P1错过截止时间；若P1优先级更高，则两者均可按时完成。</li>
<li>速率单调调度是最优算法，若一组进程不能通过此算法调度，则无法通过其他静态优先级算法调度。</li>
<li>但存在局限性：CPU利用率受限，N个进程的最差利用率为N(2^(1/N)−1)，随着进程数量增加，利用率下降。</li>
</ul>
<h4 id="最早截止时间优先调度">5.6.4 最早截止时间优先调度</h4>
<ul>
<li>最早截止时间优先(EDF)调度动态分配优先级，截止时间越早优先级越高。</li>
<li>示例：P1周期50，处理时间25；P2周期80，处理时间35，总CPU利用率为94%。在速率单调调度下P2会错过截止时间，但在EDF调度下两者均可按时完成。</li>
<li>EDF调度不依赖任务周期性，仅需任务宣布截止时间，理论上可达到100%的CPU利用率，但实际受上下文切换和中断处理影响。</li>
</ul>
<h4 id="比例共享调度">5.6.5 比例共享调度</h4>
<ul>
<li>比例共享调度将T份时间分给所有应用，每个应用获得N份时间，确保其获得N/T的处理器时间。</li>
<li>示例：总份额T=100，A分配50份，B分配15份，C分配20份，分别获得50%、15%、20%的CPU时间。</li>
<li>需结合准入控制策略，确保应用获得分配的时间份额，若新进程请求的份额不可用，则拒绝其进入系统。</li>
</ul>
<h4 id="posix实时调度">5.6.6 POSIX实时调度</h4>
<ul>
<li>POSIX标准定义了两种实时调度类：SCHED_FIFO（先来先服务）和SCHED_RR（轮转法）。</li>
<li>SCHED_FIFO按FIFO队列调度，无同优先级时间片划分；SCHED_RR提供同优先级时间片划分。</li>
<li>提供API获取和设置调度策略：pthread_attr_getschedpolicy() 和
pthread_attr_setschedpolicy()。</li>
</ul>
<h4 id="操作系统示例-1">5.7 操作系统示例</h4>
<h5 id="示例linux调度">5.7.1 示例：Linux调度</h5>
<ul>
<li>Linux调度基于调度类，CFS（完全公平调度器）为默认调度算法。</li>
<li>CFS使用虚拟运行时间(vruntime)决定任务调度顺序，优先级高的任务vruntime增长较慢。</li>
<li>Linux支持实时调度，采用POSIX标准，实时任务优先级高于普通任务，分为0-99（实时）和100-139（普通）两个优先级范围。</li>
<li>支持负载均衡，基于调度域结构平衡负载，考虑NUMA架构减少线程迁移带来的内存访问延迟。</li>
</ul>
<h5 id="示例windows调度">5.7.2 示例：Windows调度</h5>
<ul>
<li>Windows采用抢占式优先级调度，32级优先级方案，16-31为实时类，1-15为变量类。</li>
<li>提供API设置进程优先级类（如NORMAL、HIGH、REALTIME等）和线程相对优先级（如NORMAL、HIGHEST、TIME_CRITICAL等）。</li>
<li>线程时间片用尽后优先级降低，等待I/O后优先级提升，增强交互线程响应。</li>
<li>Windows
7引入用户模式调度(UMS)，应用程序可独立创建和管理线程，提升效率。</li>
</ul>
<h5 id="示例solaris调度">5.7.3 示例：Solaris调度</h5>
<ul>
<li>Solaris支持六种调度类：时间共享(TS)、交互(IA)、实时(RT)、系统(SYS)、公平共享(FSS)、固定优先级(FP)。</li>
<li>时间共享类动态调整优先级，高优先级用于交互进程，低优先级用于CPU密集型进程。</li>
<li>实时类优先级最高，确保任务在截止时间内完成；系统类用于内核线程。</li>
<li>调度器将类内优先级转换为全局优先级，选择最高优先级线程运行。</li>
</ul>
<h4 id="算法评估">5.8 算法评估</h4>
<h5 id="确定性建模">5.8.1 确定性建模</h5>
<ul>
<li>确定性建模使用特定工作负载评估算法性能，计算平均等待时间等指标。</li>
<li>示例：FCFS平均等待时间28ms，SJF为13ms，RR为23ms，SJF最优。</li>
<li>优点：简单快速，提供精确数字；缺点：仅适用于特定输入，需精确数据。</li>
</ul>
<h5 id="排队模型">5.8.2 排队模型</h5>
<ul>
<li>排队模型基于CPU和I/O突发的概率分布，计算平均吞吐量、等待时间等。</li>
<li>Little公式：n = λ×W，表示队列长度、到达率和等待时间的关系。</li>
<li>优点：适用于动态工作负载；缺点：数学复杂，假设独立性可能不准确。</li>
</ul>
<h5 id="模拟">5.8.3 模拟</h5>
<ul>
<li>使用模拟器建模系统，记录调度性能数据。</li>
<li>数据来源：随机生成或实际系统测量（如trace文件）。</li>
<li>优点：更准确，可重复测试；缺点：计算资源消耗大，设计复杂。</li>
</ul>
<h5 id="实现">5.8.4 实现</h5>
<ul>
<li>在真实系统中实现调度算法并测试，最准确但成本高。</li>
<li>需修改操作系统代码，进行回归测试确保稳定性。</li>
<li>用户行为可能影响调度效果，需动态调整参数适应不同应用场景。</li>
</ul>
<h4 id="总结-3">5.9 总结</h4>
<ul>
<li>CPU调度选择等待队列中的进程并分配CPU，调度算法分为抢占式和非抢占式。</li>
<li>调度算法评估标准包括CPU利用率、吞吐量、周转时间、等待时间和响应时间。</li>
<li>常见算法：FCFS简单但可能导致长进程阻塞短进程；SJF最优但实现困难；RR提供时间片，防止长进程阻塞；优先级调度按优先级分配CPU。</li>
<li>多级队列和多级反馈队列将进程分组调度，允许进程在队列间迁移。</li>
<li>多核处理器需负载均衡，但线程迁移可能影响缓存性能。</li>
<li>实时调度分为软实时和硬实时，硬实时需提供时间保证。</li>
<li>Linux使用CFS基于vruntime公平分配CPU时间；Windows使用32级优先级调度；Solaris使用六类调度映射全局优先级。</li>
<li>算法评估方法包括建模、模拟和实现，各有优劣。#### 第五章 习题</li>
<li>5.11
I/O密集型程序更可能进行自愿上下文切换，CPU密集型程序更可能进行非自愿上下文切换。因为I/O密集型程序经常主动等待I/O操作完成，而CPU密集型程序更可能被调度器抢占。</li>
<li>5.12
调度准则之间存在冲突：CPU利用率高可能增加响应时间；最小平均周转时间可能增加最大等待时间；提高I/O设备利用率可能降低CPU利用率。</li>
<li>5.13
BTV调度器通过为高优先级线程分配更多彩票票数，使其在每次抽奖中获胜概率更高，从而获得更多CPU时间。</li>
<li>5.14
每个核心独立运行队列可减少锁竞争，但可能导致负载不均；共享运行队列可实现负载均衡，但可能引发并发访问性能问题。</li>
<li>5.15
α=0时预测始终为初始值τ0=100ms；α=0.99时预测几乎完全依赖最近一次CPU突发时间。</li>
<li>5.16
回归轮转调度偏向I/O密集型进程，因为它们频繁让出CPU，不会导致时间片增加，而CPU密集型进程会因用满时间片而获得更长时间片和优先级提升。</li>
<li>5.17
包括绘制Gantt图、计算不同调度算法下的周转时间和等待时间，并比较平均等待时间。</li>
<li>5.18
使用优先级抢占调度，高优先级进程可中断低优先级进程，相同优先级使用轮转调度（时间片为10）。</li>
<li>5.19
nice值小于0表示更高优先级，系统通常限制只有root可设置，防止普通用户滥用高优先级影响系统稳定性。</li>
<li>5.20
可能导致饥饿的算法：优先级调度（低优先级进程可能永远得不到执行）。</li>
<li>5.21
在就绪队列中放入同一进程的两个指针可增加其执行频率，但会增加调度开销和复杂性。可通过动态调整时间片实现类似效果。</li>
<li>5.22
轮转调度下，时间片为1ms时CPU利用率约为98%，为10ms时约为91%，因为I/O密集型任务频繁切换导致更多上下文切换开销。</li>
<li>5.23
用户可通过将任务拆分为多个子任务，使其在多级队列中分布更广，从而获得更多CPU时间。</li>
<li>5.24
β&gt;α&gt;0时等价于最短作业优先；α&lt;β&lt;0时等价于最长作业优先。</li>
<li>5.25
RR和多级反馈队列偏向短进程；FCFS不利于短进程，因其需等待前面长进程完成。</li>
<li>5.26
共享就绪队列在SMP环境中可能导致缓存一致性问题和锁竞争，影响性能。</li>
<li>5.27
若一个队列全是高优先级线程，另一个全是低优先级线程，负载均衡会破坏优先级调度效果。</li>
<li>5.28
将新进程放在父进程队列可提高缓存命中率；放在不同队列可提高负载均衡。</li>
<li>5.29
NUMA感知调度应将线程重新调度到原CPU，以减少远程内存访问延迟。</li>
<li>5.30
Windows调度优先级计算示例：实时优先级类NORMAL为24；高于正常类HIGHEST为13；低于正常类ABOVE
NORMAL为6。</li>
<li>5.31 最高优先级为“高于正常”优先级类+“最高”相对优先级。</li>
<li>5.32
Solaris时间片调度：优先级15为60ms，优先级40为5ms；优先级50完成后调整为45；优先级20阻塞后调整为35。</li>
<li>5.33
CFS调度下，nice值-5的A进程比nice值+5的B进程具有更低的vruntime，获得更多的CPU时间。</li>
<li>5.34
在任务周期不固定或有多个任务共享相同周期时，最早截止优先调度（EDF）优于速率单调调度（RMS）。</li>
<li>5.35
P1和P2在速率单调调度下无法满足截止时间，但在最早截止优先调度下可以。</li>
<li>5.36
在硬实时系统中，中断和调度延迟必须有上限，以确保任务在截止时间前完成。</li>
<li>5.37 异构多处理可提高能效和性能，适合移动设备中不同任务需求。####
编程项目</li>
<li>项目涉及实现多种进程调度算法，包括先来先服务（FCFS）、最短作业优先（SJF）、优先级调度、轮转调度（RR），以及结合优先级和轮转的调度算法。</li>
<li>优先级范围为1到10，数值越高优先级越高；轮转调度的时间片为10毫秒。</li>
<li>所有任务同时到达，不需要支持抢占式调度。</li>
<li>任务格式为[任务名] [优先级] [CPU突发时间]，例如：T1, 4, 20。</li>
</ul>
<h4 id="实现策略">实现策略</h4>
<ul>
<li>可使用单一无序任务列表，根据调度算法选择任务。</li>
<li>可按调度标准排序列表（如优先级）。</li>
<li>可为每个唯一优先级设置单独队列。</li>
<li>列表和队列功能不同，一般列表更适合本项目。</li>
</ul>
<h4 id="c语言实现细节">C语言实现细节</h4>
<ul>
<li>driver.c读取任务、插入链表并调用schedule()函数。</li>
<li>schedule()函数通过pickNextTask()选择任务，并通过run()执行。</li>
<li>使用Makefile指定调度算法，如输入make fcfs构建先来先服务调度器。</li>
<li>执行方式为./fcfs schedule.txt。</li>
</ul>
<h4 id="java实现细节">Java实现细节</h4>
<ul>
<li>Driver.java读取任务、插入ArrayList并调用schedule()方法。</li>
<li>通过Algorithm接口实现五种调度算法，定义schedule()和pickNextTask()方法。</li>
<li>Task类通过CPU.java的run()方法执行。</li>
<li>执行方式为java Driver fcfs schedule.txt。</li>
</ul>
<h4 id="进阶挑战">进阶挑战</h4>
<ul>
<li>使用原子整数（AtomicInteger）解决SMP环境中任务标识符分配的竞态条件。</li>
<li>在Linux/macOS中使用sync_fetch_and_add()函数实现原子操作。</li>
<li>计算每种调度算法的平均周转时间、等待时间和响应时间。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://fyind.de">Fyind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://fyind.de/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/">http://fyind.de/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Operating-System/">Operating System</a></div><div class="post-share"><div class="social-share" data-image="/img/pic1.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">C++高性能编程</div></div><div class="info-2"><div class="info-item-1">CMake g++14 支持C++23需要g++14版本，可以安装 1sudo apt install gcc-14 g++-14 Cmake 新建 CMakeLists.txt 里面写 123456789cmake_minimum_required(VERSION 3.28)set(CMAKE_CXX_COMPILER g++-14)set(CMAKE_CXX_STANDARD 23)project(exampleproject LANGUAGES CXX)add_executable(exampleproject main.cpp) 构建 优点： - 明确指定源代码和构建目录 - 避免在源代码目录中生成构建文件 - 支持out-of-source构建（推荐做法） 1cmake -S /mnt/d/Fyind/Master_Semester7/cpp -B /mnt/d/Fyind/Master_Semester7/cpp/build C++23 print 12345678#include &lt;print&gt;int main() &#123;    std::prin...</div></div></div></a><a class="pagination-related" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Kubuntu配置</div></div><div class="info-2"><div class="info-item-1">Kubuntu 首先安装Kubuntu,完成后的 系统配置  更新系统 设置中文 安装GPU驱动  安装软件  Google Chrome Typora  Zsh 12345678910111213141516171819202122sudo apt updatesudo apt install zshchsh -s $(which zsh)sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# 克隆 Powerlevel10k 仓库git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k# 修改 .zshrc 配置文件sed -i &#x27;s/ZSH_THEME=&quot;robbyrussell&quot;/ZSH_THEME=&quot;powerlevel10k\/power...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fyind</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fyind"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Fyind" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tarjan0025@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=d0kMY0nN" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来逛逛我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">第一章 引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 操作系统的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 计算机系统组织</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#io%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 I&#x2F;O结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 计算机系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 单处理器系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 多处理器系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 集群系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 操作系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 多道程序设计与多任务处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 双模式与多模式操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.5.1 进程管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.5.2 内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.6.</span> <span class="toc-text">1.5.3 文件系统管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.7.</span> <span class="toc-text">1.5.4 存储设备管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.8.</span> <span class="toc-text">1.5.5 缓存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#io%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.9.</span> <span class="toc-text">1.5.6 I&#x2F;O系统管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.5.</span> <span class="toc-text">1.6 安全与保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">1.7 虚拟化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.</span> <span class="toc-text">1.8 分布式系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">1.9 内核数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.9.1 列表、栈和队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.8.2.</span> <span class="toc-text">1.9.2 树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="toc-number">1.8.3.</span> <span class="toc-text">1.9.3 哈希函数与映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE"><span class="toc-number">1.8.4.</span> <span class="toc-text">1.9.4 位图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83"><span class="toc-number">1.9.</span> <span class="toc-text">1.10 计算环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.10.1 传统计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.2.</span> <span class="toc-text">1.10.2 移动计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.3.</span> <span class="toc-text">1.10.3 客户端-服务器计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.4.</span> <span class="toc-text">1.10.4 点对点计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.5.</span> <span class="toc-text">1.10.5 云计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.9.6.</span> <span class="toc-text">1.10.6 实时嵌入式系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E4%B8%8E%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.</span> <span class="toc-text">1.11 自由与开源操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.11.1 历史</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.2.</span> <span class="toc-text">1.11.2 自由操作系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gnulinux"><span class="toc-number">1.10.3.</span> <span class="toc-text">1.11.3 GNU&#x2F;Linux</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bsd-unix"><span class="toc-number">1.10.4.</span> <span class="toc-text">1.11.4 BSD UNIX</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#solaris"><span class="toc-number">1.10.5.</span> <span class="toc-text">1.11.5 Solaris</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%BA%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7"><span class="toc-number">1.10.6.</span> <span class="toc-text">1.11.6 开源系统作为学习工具</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.11.</span> <span class="toc-text">1.12 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">第二章 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.0.1.</span> <span class="toc-text">2.1 操作系统服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">0.0.2.</span> <span class="toc-text">2.2 用户与操作系统接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">0.0.3.</span> <span class="toc-text">2.3 系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.0.4.</span> <span class="toc-text">2.4 系统服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">0.0.5.</span> <span class="toc-text">2.5 链接器与加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BA%E4%BD%95%E4%BE%9D%E8%B5%96%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">0.0.6.</span> <span class="toc-text">2.6 应用为何依赖操作系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">0.0.7.</span> <span class="toc-text">2.7 操作系统设计与实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">0.0.8.</span> <span class="toc-text">2.8 操作系统结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-1"><span class="toc-number">0.0.9.</span> <span class="toc-text">2.8 操作系统结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">0.0.10.</span> <span class="toc-text">2.9 构建与启动操作系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">0.0.11.</span> <span class="toc-text">2.9.2 系统启动过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95"><span class="toc-number">0.0.12.</span> <span class="toc-text">2.10 操作系统调试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">0.0.13.</span> <span class="toc-text">2.11 总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B"><span class="toc-number">0.0.14.</span> <span class="toc-text">4.1 Linux内核模块简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="toc-number">0.0.15.</span> <span class="toc-text">4.2 内核模块概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">0.0.16.</span> <span class="toc-text">4.3 加载与卸载内核模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E7%BB%83%E4%B9%A0"><span class="toc-number">0.0.17.</span> <span class="toc-text">4.4 扩展功能练习</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="toc-number">0.0.18.</span> <span class="toc-text">4.5 &#x2F;proc文件系统模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">0.0.19.</span> <span class="toc-text">4.6 实验任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">第三章 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 进程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.1.1 进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.1.2 进程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.1.3 进程控制块（PCB）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">3.1.4 线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 调度队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cpu%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 CPU调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2.3 上下文切换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.1 进程创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.3.2 进程终止</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#android%E8%BF%9B%E7%A8%8B%E5%B1%82%E6%AC%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">Android进程层次</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc"><span class="toc-number">1.4.</span> <span class="toc-text">3.4 进程间通信（IPC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84ipc"><span class="toc-number">1.5.</span> <span class="toc-text">3.5 共享内存模型下的IPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84ipc"><span class="toc-number">1.6.</span> <span class="toc-text">3.6 消息传递模型下的IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">3.6.1 命名方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">3.6.2 同步方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.6.3 缓冲机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ipc%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">3.7 IPC系统示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#posix%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">3.7.1 POSIX共享内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#mach%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">3.7.2 Mach消息传递</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#windows"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">3.7.3 Windows</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E9%81%93pipes"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">3.7.4 管道（Pipes）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%AE%A1%E9%81%93ordinary-pipes"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">3.7.4.1 普通管道（Ordinary Pipes）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93named-pipes"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">3.7.4.2 命名管道（Named Pipes）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E9%80%9A%E4%BF%A1"><span class="toc-number">1.6.5.</span> <span class="toc-text">3.8 客户端-服务器系统通信</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97sockets"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">3.8.1 套接字（Sockets）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">3.8.2 远程过程调用（RPC）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#android%E4%B8%AD%E7%9A%84rpc"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">3.8.2.1 Android中的RPC</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.6.6.</span> <span class="toc-text">3.9 总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.6.7.</span> <span class="toc-text">3.7 进程调度与上下文切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.8.</span> <span class="toc-text">3.8 进程树与系统工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2"><span class="toc-number">1.6.9.</span> <span class="toc-text">3.9 进程创建与终止</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%95%B0%E9%87%8F%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.10.</span> <span class="toc-text">3.10 进程数量计算示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ipc%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.11.</span> <span class="toc-text">3.11 IPC通信方式比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">1.6.12.</span> <span class="toc-text">3.12 共享内存与消息传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.13.</span> <span class="toc-text">3.13 编程问题解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.6.13.1.</span> <span class="toc-text">3.18 创建僵尸进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.6.13.2.</span> <span class="toc-text">3.19 测量命令执行时间</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pid%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.6.13.3.</span> <span class="toc-text">3.20 PID管理器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#collatz%E7%8C%9C%E6%83%B3%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.13.4.</span> <span class="toc-text">3.21 Collatz猜想多进程实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96collatz%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.13.5.</span> <span class="toc-text">3.22
使用共享内存优化Collatz程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.13.6.</span> <span class="toc-text">3.23~3.25 网络服务实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">1.6.13.7.</span> <span class="toc-text">3.26~3.27 管道通信编程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE1unix-shell"><span class="toc-number">1.6.14.</span> <span class="toc-text">项目1：UNIX Shell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE2linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%98%BE%E7%A4%BA%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.15.</span> <span class="toc-text">项目2：Linux内核模块显示任务信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE3linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.16.</span> <span class="toc-text">项目3：Linux内核模块列出所有任务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E4%B8%80%E7%BA%BF%E6%80%A7%E9%81%8D%E5%8E%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.16.1.</span> <span class="toc-text">部分一：线性遍历任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E4%BA%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BB%BB%E5%8A%A1%E6%A0%91"><span class="toc-number">1.6.16.2.</span> <span class="toc-text">部分二：深度优先遍历任务树</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE4%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.17.</span> <span class="toc-text">项目4：内核数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E4%B8%80%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.17.1.</span> <span class="toc-text">部分一：链表操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E4%BA%8C%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.6.17.2.</span> <span class="toc-text">部分二：模块参数传递</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">第四章 进程操作与进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C-1"><span class="toc-number"></span> <span class="toc-text">3.3 进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-1"><span class="toc-number">1.</span> <span class="toc-text">3.3.2 进程终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#android-%E8%BF%9B%E7%A8%8B%E5%B1%82%E7%BA%A7"><span class="toc-number">2.</span> <span class="toc-text">3.3.2.1 Android 进程层级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc-1"><span class="toc-number"></span> <span class="toc-text">3.4 进程间通信（IPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">3.4.1 IPC 的基本模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">3.4.2 Chrome 浏览器的多进程架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84-ipc"><span class="toc-number"></span> <span class="toc-text">3.5 共享内存中的 IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">3.5.1 共享内存通信机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-api"><span class="toc-number">2.</span> <span class="toc-text">3.5.2 POSIX 共享内存 API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-ipc"><span class="toc-number"></span> <span class="toc-text">3.6 消息传递系统中的 IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">3.6.1 命名机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">3.6.2 同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6-1"><span class="toc-number">3.</span> <span class="toc-text">3.6.3 缓冲机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipc-%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">3.7 IPC 系统示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">3.7.1 POSIX 共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mach-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.</span> <span class="toc-text">3.7.2 Mach 消息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows-ipc"><span class="toc-number">3.</span> <span class="toc-text">3.7.3 Windows IPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93pipes-1"><span class="toc-number">4.</span> <span class="toc-text">3.7.4 管道（Pipes）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%AE%A1%E9%81%93ordinary-pipes-1"><span class="toc-number">4.1.</span> <span class="toc-text">3.7.4.1 普通管道（Ordinary
Pipes）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93named-pipes-1"><span class="toc-number">4.2.</span> <span class="toc-text">3.7.4.2 命名管道（Named Pipes）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">3.8 客户端-服务器系统中的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97sockets-1"><span class="toc-number">1.</span> <span class="toc-text">3.8.1 套接字（Sockets）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc-1"><span class="toc-number">2.</span> <span class="toc-text">3.8.2 远程过程调用（RPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.0.1.</span> <span class="toc-text">3.8.1 套接字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc-2"><span class="toc-number">2.0.2.</span> <span class="toc-text">3.8.2 远程过程调用（RPC）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#android%E4%B8%AD%E7%9A%84rpc-1"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.8.2.1 Android中的RPC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">3.9 小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">4.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA"><span class="toc-number">2.2.1.</span> <span class="toc-text">4.1.1 动机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">2.2.2.</span> <span class="toc-text">4.1.2 优势</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">4.2 多核编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">4.2.1 编程挑战</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">4.2.2 并行类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4.3 多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.3.1 多对一模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.3.2 一对一模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3.3 多对多模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">2.5.</span> <span class="toc-text">4.4 线程库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#posix%E7%BA%BF%E7%A8%8Bpthreads"><span class="toc-number">2.5.1.</span> <span class="toc-text">4.4.1 POSIX线程（Pthreads）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#windows%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">4.4.2 Windows线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">4.4.3 Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#java-executor%E6%A1%86%E6%9E%B6"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">Java Executor框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">4.5 隐式线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.6.1.</span> <span class="toc-text">4.5.1 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#java%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">Java线程池</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fork-join%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">4.5.2 Fork-Join模型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84fork-join"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">Java中的Fork-Join</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#openmp"><span class="toc-number">2.6.3.</span> <span class="toc-text">4.5.3 OpenMP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#grand-central-dispatchgcd"><span class="toc-number">2.6.4.</span> <span class="toc-text">4.5.4 Grand Central
Dispatch（GCD）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#intel%E7%BA%BF%E7%A8%8B%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97tbb"><span class="toc-number">2.6.5.</span> <span class="toc-text">4.5.5 Intel线程构建模块（TBB）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fork-%E5%92%8C-exec-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.6.6.</span> <span class="toc-text">4.6.1 fork() 和 exec() 系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">2.6.7.</span> <span class="toc-text">4.6.2 信号处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="toc-number">2.6.8.</span> <span class="toc-text">4.6.3 线程取消</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8-tls"><span class="toc-number">2.6.9.</span> <span class="toc-text">4.6.4 线程局部存储 (TLS)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%BF%80%E6%B4%BB"><span class="toc-number">2.6.10.</span> <span class="toc-text">4.6.5 调度激活</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.</span> <span class="toc-text">4.7 操作系统示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#windows-%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.1.</span> <span class="toc-text">4.7.1 Windows 线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#linux-%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.2.</span> <span class="toc-text">4.7.2 Linux 线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.8.</span> <span class="toc-text">4.8 小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.9.</span> <span class="toc-text">5.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cpuio%E7%AA%81%E5%8F%91%E5%91%A8%E6%9C%9F"><span class="toc-number">2.9.1.</span> <span class="toc-text">5.1.1 CPU–I&#x2F;O突发周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cpu%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">5.1.2 CPU调度器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%B8%8E%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">2.9.3.</span> <span class="toc-text">5.1.3 抢占式与非抢占式调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%B4%BE%E5%99%A8"><span class="toc-number">2.9.4.</span> <span class="toc-text">5.1.4 分派器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">2.10.</span> <span class="toc-text">5.2 调度准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.11.</span> <span class="toc-text">5.3 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6fcfs"><span class="toc-number">2.11.1.</span> <span class="toc-text">5.3.1 先来先服务调度（FCFS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6sjf"><span class="toc-number">2.11.2.</span> <span class="toc-text">5.3.2 最短作业优先调度（SJF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6rr"><span class="toc-number">2.11.3.</span> <span class="toc-text">5.3.3 轮转调度（RR）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">2.11.4.</span> <span class="toc-text">5.3.4 优先级调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">2.11.5.</span> <span class="toc-text">5.3.5 多级队列调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">2.11.6.</span> <span class="toc-text">5.3.6 多级反馈队列调度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.12.</span> <span class="toc-text">5.4 线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E8%8C%83%E5%9B%B4"><span class="toc-number">2.12.1.</span> <span class="toc-text">5.4.1 竞争范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread%E8%B0%83%E5%BA%A6"><span class="toc-number">2.12.2.</span> <span class="toc-text">5.4.2 Pthread调度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">2.13.</span> <span class="toc-text">5.5 多处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95"><span class="toc-number">2.13.1.</span> <span class="toc-text">5.5.1 多处理器调度方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.13.2.</span> <span class="toc-text">5.5.2 多核处理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.13.3.</span> <span class="toc-text">5.5.3 负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="toc-number">2.13.4.</span> <span class="toc-text">5.5.4 处理器亲和性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%9E%84%E5%A4%9A%E5%A4%84%E7%90%86"><span class="toc-number">2.13.5.</span> <span class="toc-text">5.5.5 异构多处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9F%E7%8E%87%E5%8D%95%E8%B0%83%E8%B0%83%E5%BA%A6"><span class="toc-number">2.14.</span> <span class="toc-text">5.6.3 速率单调调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6"><span class="toc-number">2.15.</span> <span class="toc-text">5.6.4 最早截止时间优先调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6"><span class="toc-number">2.16.</span> <span class="toc-text">5.6.5 比例共享调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#posix%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">2.17.</span> <span class="toc-text">5.6.6 POSIX实时调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.18.</span> <span class="toc-text">5.7 操作系统示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8Blinux%E8%B0%83%E5%BA%A6"><span class="toc-number">2.18.1.</span> <span class="toc-text">5.7.1 示例：Linux调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8Bwindows%E8%B0%83%E5%BA%A6"><span class="toc-number">2.18.2.</span> <span class="toc-text">5.7.2 示例：Windows调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8Bsolaris%E8%B0%83%E5%BA%A6"><span class="toc-number">2.18.3.</span> <span class="toc-text">5.7.3 示例：Solaris调度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0"><span class="toc-number">2.19.</span> <span class="toc-text">5.8 算法评估</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%BB%BA%E6%A8%A1"><span class="toc-number">2.19.1.</span> <span class="toc-text">5.8.1 确定性建模</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.19.2.</span> <span class="toc-text">5.8.2 排队模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-number">2.19.3.</span> <span class="toc-text">5.8.3 模拟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.19.4.</span> <span class="toc-text">5.8.4 实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">2.20.</span> <span class="toc-text">5.9 总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.21.</span> <span class="toc-text">实现策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">2.22.</span> <span class="toc-text">C语言实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">2.23.</span> <span class="toc-text">Java实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E6%8C%91%E6%88%98"><span class="toc-number">2.24.</span> <span class="toc-text">进阶挑战</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程">C++高性能编程</a><time datetime="2025-07-17T19:47:19.000Z" title="Created 2025-07-17 19:47:19">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="操作系统概念">操作系统概念</a><time datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置">Kubuntu配置</a><time datetime="2025-07-15T05:25:37.000Z" title="Created 2025-07-15 05:25:37">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E6%88%91%E4%BB%AC%E5%9C%A8AI%E6%97%B6%E4%BB%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/" title="我们在AI时代该如何学习">我们在AI时代该如何学习</a><time datetime="2025-07-12T23:12:19.000Z" title="Created 2025-07-12 23:12:19">2025-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CA-Top-Down-Approach/" title="计算机网络A Top Down Approach">计算机网络A Top Down Approach</a><time datetime="2025-07-12T22:02:58.000Z" title="Created 2025-07-12 22:02:58">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fyind</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>