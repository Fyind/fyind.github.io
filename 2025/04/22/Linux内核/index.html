<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux内核 | Fyind's Blog</title><meta name="author" content="Fyind"><meta name="copyright" content="Fyind"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="中断 中断机制： 中断分为硬件中断和软件中断  硬件中断是由硬件中断控制芯片发出的 软中断是异常  代码实现： asm.s, system_call.s, trap.c, fork.c, signal.c, sys.c 中断的工作流程 CPU的工作模式转换，寄存器拷贝压栈，中断异常向量表，保存正常运行函数的返回值, 跳转到对应的中断服务函数上运行, 模式复原， 跳转回正常函数 硬件中断前处理 as">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核">
<meta property="og:url" content="http://fyind.de/2025/04/22/Linux%E5%86%85%E6%A0%B8/index.html">
<meta property="og:site_name" content="Fyind&#39;s Blog">
<meta property="og:description" content="中断 中断机制： 中断分为硬件中断和软件中断  硬件中断是由硬件中断控制芯片发出的 软中断是异常  代码实现： asm.s, system_call.s, trap.c, fork.c, signal.c, sys.c 中断的工作流程 CPU的工作模式转换，寄存器拷贝压栈，中断异常向量表，保存正常运行函数的返回值, 跳转到对应的中断服务函数上运行, 模式复原， 跳转回正常函数 硬件中断前处理 as">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://fyind.de/img/pic1.PNG">
<meta property="article:published_time" content="2025-04-22T17:09:28.000Z">
<meta property="article:modified_time" content="2025-07-18T10:49:53.874Z">
<meta property="article:author" content="Fyind">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyind.de/img/pic1.PNG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux内核",
  "url": "http://fyind.de/2025/04/22/Linux%E5%86%85%E6%A0%B8/",
  "image": "http://fyind.de/img/pic1.PNG",
  "datePublished": "2025-04-22T17:09:28.000Z",
  "dateModified": "2025-07-18T10:49:53.874Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fyind",
      "url": "http://fyind.de"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pic1.PNG"><link rel="canonical" href="http://fyind.de/2025/04/22/Linux%E5%86%85%E6%A0%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://fyindex.work/PicGo/liuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yae.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Fyind's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux内核</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/TUM%E7%AC%94%E8%AE%B0"><i class="fa-fw fas fa-folder-open"></i><span> TUM笔记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-22T17:09:28.000Z" title="Created 2025-04-22 17:09:28">2025-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-18T10:49:53.874Z" title="Updated 2025-07-18 10:49:53">2025-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="中断">中断</h2>
<p>中断机制：</p>
<p>中断分为<strong>硬件中断</strong>和<strong>软件中断</strong></p>
<ul>
<li>硬件中断是由硬件中断控制芯片发出的</li>
<li>软中断是异常</li>
</ul>
<p>代码实现：</p>
<p><code>asm.s, system_call.s, trap.c, fork.c, signal.c, sys.c</code></p>
<h3 id="中断的工作流程">中断的工作流程</h3>
<p>CPU的工作模式转换，寄存器拷贝压栈，中断异常向量表，保存正常运行函数的返回值,
跳转到对应的中断服务函数上运行, 模式复原， 跳转回正常函数</p>
<p>硬件中断前处理 <code>asm.s</code> 中断执行 <code>trap.c</code></p>
<p>软件中断前 <code>system_call.s</code> 执行
<code>fork.c signal.c exit.c sys.c</code></p>
<h2 id="进程管理">进程管理</h2>
<p>系统时间：</p>
<p>CPU内部有个RTC，mktime函数计算从1970年1月1日0时的秒数</p>
<p>给mktime的参数是从RTC(CMOS)读出的,放到全局遍历里，为jiffies所用</p>
<h3 id="jiffies">jiffies</h3>
<p>是系统时钟的滴答，一个滴答是10ms</p>
<h4 id="dotimer">dotimer</h4>
<p>cpl 是内核中只是状态的变量：当前是内核态(0)还是用户态(1)</p>
<h1 id="linux内核设计与实现">Linux内核设计与实现</h1>
<h2 id="进程管理-1">进程管理</h2>
<p>进程是处于执行期的程序,还包含其他资源。线程是在进程中活动的对象。Linux不对线程和进程特别区分,线程是一种特殊的进程。</p>
<p>现代操作系统进程有虚拟处理器和虚拟内存。</p>
<h3 id="进程描述符">进程描述符</h3>
<p>进程的列表放在一个任务队列的双向循环链表中。链表中的每一项是
<code>task_struct</code> 是进程描述符结构体</p>
<p>Linux 通过 slab 分配器分配 <code>task_struct</code> 的结构</p>
<h4 id="进程描述符的存放">进程描述符的存放</h4>
<p>内核通过唯一的PID表示进程。PID是<code>pid_t</code> (int)
类型，<code>/proc/sys/kernel/pid_max</code> 存放了进程数量上限。</p>
<p>通过current宏可以找到当前正在运行进程的进程标识符.</p>
<h4 id="进程的状态">进程的状态</h4>
<ul>
<li><code>TASK_RUNNING</code> 运行</li>
<li><code>TASK_INTERRUPTIBLE</code> 可中断</li>
<li><code>TASK_UNINTERRUPTIBLE</code> 不可中断</li>
<li><code>__TASK_TRACED</code> 被其他进程跟踪</li>
<li><code>__TASK_STOPPED</code> 停止</li>
</ul>
<h4 id="设置当前进程状态">设置当前进程状态</h4>
<p>可以用 <code>set_task_state(task, state)</code></p>
<h4 id="进程的家族树">进程的家族树</h4>
<p>所有进程都是 init
进程的后代，它PID为1，系统启动的最后阶段启动init进程。</p>
<p>每个进程有父进程,
也有零个或多个子进程。<code>current-&gt;parent</code>
可以访问父进程，<code>current-&gt;children</code> 是子进程的链表.</p>
<p>init 进程的进程符是 <code>init_task</code></p>
<p>next 和 prev 可以获得前一个或者后一个进程。</p>
<h3 id="进程创建">进程创建</h3>
<p>首先 <code>fork()</code>
拷贝当前进程创建一个子进程。子进程和父进程区别仅在PID,PPID
和一些资源和统计量。<code>exec()</code>
负责读取可执行文件，载入地址空间开始运行。</p>
<h4 id="写时拷贝">写时拷贝</h4>
<p>不复制整个地址空间，只有在需要写入的时候，数据才复制。否则父子进程共享一个拷贝。</p>
<h4 id="fork">fork()</h4>
<p>通过 clone() 实现 fork()</p>
<h3 id="线程">线程</h3>
<p>Linux 把所有线程都当作进程实现。</p>
<h4 id="创建线程">创建线程</h4>
<p>和创建进程类似，不过传递参数不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>进程是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHILD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>CLONE FILES: 父子进程共享打开的文件</li>
<li>CLONE FS: 共享文件系统信息</li>
<li>CLONE VM: 共享地址空间</li>
<li>CLONE SIGHAND: 共享信号处理函数，被阻断信号</li>
</ul>
<h4 id="内核线程">内核线程</h4>
<p>内核需要在后台完成一些操作，可以通过内核线程完成。它是独立运行在内核空间的标准线程。内核线程没有独立的地址空间。</p>
<p><code>ps -ef</code> 可以看到内核线程</p>
<p>内核线程只能由内核线程创建, 在 <code>linux/kthread.h</code> 里
<code>kthread_create()</code> 可以创建内核线程</p>
<h3 id="进程终结">进程终结</h3>
<p>发生在调用 <code>exit()</code> 时候。</p>
<h2 id="进程调度">进程调度</h2>
<h3 id="多任务">多任务</h3>
<p>可分为非抢占式(cooperative multitasking) 和抢占式多任务 (preemptive
multitasking)</p>
<ul>
<li><p>Linux
有抢占式多任务，调度程序决定什么时候停止一个进程的运行，以便其他程序可以执行。这个强制挂起的动作叫抢占
(preemption)</p>
<p>进程在被抢占前可以运行的时间叫进程的时间片 (timeslice),
不过Linux没有采用时间片。</p></li>
<li><p>非抢占模式下，处非程序自己主动停止运行，否则会一直执行。进程主动挂起叫让步
(yielding)。</p></li>
</ul>
<h3 id="策略">策略</h3>
<h4 id="io消耗型进程和处理器消耗型">I/O消耗型进程和处理器消耗型</h4>
<p>IO消耗性是经常等待IO的,
比如GUI。处理器消耗型是一直运行的比如计算程序。</p>
<h4 id="进程优先级">进程优先级</h4>
<p>Linux有两种</p>
<ul>
<li>nice 值 从 <code>[-20,19]</code> 默认0，越低越优先</li>
<li>实时优先级，从<code>[0,99]</code>
越高越优先，任何实时进程优先级都高于普通进程</li>
</ul>
<h3 id="linux调度算法">Linux调度算法</h3>
<h4 id="调度器类">调度器类</h4>
<p>完全公平调度(CFS)针对普通进程的调度类，是<code>SCHED_NORMAL</code>
实现在 <code>kernel/sched_fair.c</code> 里面。</p>
<h4 id="公平调度">公平调度</h4>
<p>CFG基于：进程调度的效果类似系统中有完美的多处理器。每个进程能获得
<code>1/n</code> 的处理器时间。</p>
<h3 id="linux的调度实现">Linux的调度实现</h3>
<p>在 <code>kernel/sched_fair.c</code> 里面</p>
<h4 id="时间记账">时间记账</h4>
<p>CFS调度器结构体是 <code>sched_entity</code> 里面的
<code>vruntime</code> 存放进程虚拟运行时间。<code>update_curr()</code>
实现了记账。</p>
<h4 id="进程选择">进程选择</h4>
<p>CFS挑选vruntime最小的进程运行。CFS使用红黑树组织可运行进程队列。取出里面最小的。</p>
<h4 id="调度器入口">调度器入口</h4>
<p>是 <code>schedule()</code>
选择哪个进程可以运行。先找到最高优先级的调度类，再问谁是下一个运行的进程。</p>
<h4 id="睡眠和唤醒">睡眠和唤醒</h4>
<p>被阻塞的进程处于不可执行状态。原因是等待一些事件。休眠通过等待队列进行处理。</p>
<h3 id="抢占和上下文切换">抢占和上下文切换</h3>
<p>从一个可执行进程切换到另一个可执行进程。由
<code>context_switch()</code> 负责。</p>
<h3 id="实时调度策略">实时调度策略</h3>
<p>提供 <code>SCHED_FIFO</code> 和 <code>SCHED_RR</code>
RR在耗尽时间片后就不能再执行了。</p>
<h3 id="与调度相关的系统调用">与调度相关的系统调用</h3>
<p>比如 <code>nice()</code> 设置nice值，<code>sched_setparam()</code>
设置优先级</p>
<p><code>sched_yield()</code> 放弃处理器时间</p>
<h2 id="系统调用">系统调用</h2>
<p>系统调用再用户空间和进程设备直接加了一个中间层。它为用户提供一种硬件的抽象接口。</p>
<h4 id="posix">POSIX</h4>
<p>流行的编程接口时基于POSIX标准的，它提供一套基于Unix的可移植操作系统标准。Linux的系统调用作为C库的一部分提供。C库实现了Unix系统的主要API</p>
<h4 id="系统调用-1">系统调用</h4>
<h2 id="内存管理">内存管理</h2>
<h3 id="页">页</h3>
<p>内核把物理页作为内存管理的基本单位。内存管理单元是MMU.</p>
<p>内核用 <code>struct page</code> 来表示每个物理页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">atomic_t</span> _count;</span><br><span class="line">    <span class="type">atomic_t</span> _mapcount;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="type">pgoff_t</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="type">void</span> *virtual;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>flags 来存放页的状态</li>
<li>count 存放页的引用次数,
如果是-1就是没有引用，在内存分配就可以使用它</li>
<li>virtual 是页的虚拟地址</li>
</ul>
<h3 id="内存区域的划分">3. <strong>内存区域的划分</strong></h3>
<p>Linux 内核将物理内存分为几个区域来管理：</p>
<ul>
<li><strong>低端内存（Low Memory）</strong>：通常指低于 896 MB
的内存，主要用于用户空间进程。</li>
<li><strong>高端内存（High Memory）</strong>：通常指高于 896 MB
的内存，主要是用于内核空间。</li>
<li><strong>DMA 区域（Direct Memory
Access）</strong>：用于设备直接访问的内存区域。</li>
</ul>
<h3 id="内存分配机制"><strong>内存分配机制</strong></h3>
<ul>
<li><p><strong>伙伴系统（Buddy System）</strong>：Linux
内核采用了伙伴系统来进行物理内存的分配和回收。伙伴系统将物理内存划分为大小相同的块，每个块的大小为
2
的幂。每当一个块被分配或回收时，系统会检查是否能与其他相邻块合并或分裂，保持内存的高效利用。</p></li>
<li><p><strong>页分配器（Page
Allocator）</strong>：内核使用页分配器管理物理内存的分配和回收。当进程或内核需要内存时，页分配器会在空闲页中分配所需的内存。</p></li>
<li><p><strong>Slab 分配器（Slab
Allocator）</strong>：专门用于管理内核对象的内存分配，如进程控制块（PCB）、文件描述符等。Slab
分配器通过对象缓存池的机制减少了内存碎片，提高了内存的分配效率。</p></li>
<li><p>Slab 分配器（Slab Allocator）是 Linux
内核中用于高效管理内存的一种内存分配机制，特别是在管理内核对象（如进程控制块、文件描述符、网络缓存等）时，具有很大的优势。理解
Slab 分配器的动机，我们需要从以下几个方面来看：</p>
<h3 id="内核对象的内存分配特点">1.
<strong>内核对象的内存分配特点</strong></h3>
<ul>
<li><strong>内核对象大小固定且数量众多</strong>：Linux
内核中的许多对象（如
<code>task_struct</code>、<code>file</code>、<code>inode</code>
等）大小固定，且数量非常多。如果每次为这些对象动态分配内存，会导致频繁的内存分配和释放，增加内存碎片的风险。</li>
<li><strong>频繁的内存分配和释放</strong>：内核中需要不断创建和销毁这些对象，尤其是在高负载的系统上。传统的内存分配器（如伙伴系统）会因分配和释放过于频繁而产生内存碎片，影响系统性能。</li>
</ul>
<h3 id="slab-分配器的工作原理">2. <strong>Slab
分配器的工作原理</strong></h3>
<p>Slab
分配器通过为同一类内核对象预先分配一大块内存，并将其切分成若干块来管理每个对象。每个内核对象都会从一个称为“缓存”的内存块中分配，而这个缓存是专门为某种类型的对象准备的。</p>
<p>Slab 分配器的工作原理可以分为以下几个步骤：</p>
<ul>
<li><strong>Slab（内存块）</strong>：Slab
是一个内存区域，通常被分为多个对象的内存块。一个 Slab
可以包含多个内核对象实例。这些对象具有相同的大小，适用于某种特定的内核对象。</li>
<li><strong>Cache（缓存）</strong>：Cache 是 Slab
分配器为每种类型的内核对象维护的一组 Slab。例如，为
<code>task_struct</code> 类型的内核对象分配一个缓存，为
<code>file</code> 类型的内核对象分配另一个缓存。每种缓存会维护多个
Slab，这些 Slab 会随着内存使用的增加或减少而动态变化。</li>
<li><strong>预分配与回收</strong>：当内核需要一个新对象时，Slab
分配器会从相应的缓存中取出一个空闲的 Slab。如果缓存中没有足够的空闲
Slab，分配器会分配一个新的 Slab。当对象不再需要时，Slab
分配器会将其回收到缓存池中。</li>
</ul>
<h3 id="slab-分配器的优点">3. <strong>Slab 分配器的优点</strong></h3>
<ul>
<li><strong>减少内存碎片</strong>：Slab
分配器通过将内核对象划分为大小固定的内存块来避免内存碎片问题。如果每个内核对象的大小相同，Slab
分配器能够在不产生碎片的情况下高效管理内存。</li>
<li><strong>提高性能</strong>：由于 Slab
分配器预分配了内存块，内核对象的分配和回收变得非常快速，避免了每次动态分配内存时的开销。尤其是在需要频繁分配和销毁内核对象的情况下，Slab
分配器能够极大地提高性能。</li>
<li><strong>缓存友好</strong>：Slab 分配器利用 CPU
缓存的特性，确保相同类型的内核对象被存储在内存的相邻位置。这提高了缓存的命中率，减少了访问延迟。</li>
<li><strong>内存对齐</strong>：Slab
分配器确保每个分配的对象都按照适当的内存对齐要求进行分配，避免了性能问题。</li>
<li><strong>高效的内存回收</strong>：Slab
分配器通过将已分配的对象按缓存进行管理，可以在内存回收时很高效地清理和复用内存，避免了传统内存分配机制中的频繁内存回收导致的性能下降。</li>
</ul>
<h3 id="为什么-linux-需要-slab-分配器">4. <strong>为什么 Linux 需要 Slab
分配器</strong></h3>
<ul>
<li><strong>内核内存需求特殊</strong>：与用户空间应用不同，内核的内存需求更为特殊，通常需要频繁地创建和销毁相同大小的对象。传统的内存分配机制在处理这些内存需求时，可能会产生较高的内存碎片和分配开销。</li>
<li><strong>高效管理内核对象</strong>：Slab
分配器提供了一个专门为内核对象设计的高效管理方案，它通过缓存池和预分配机制，使得内核对象的分配与回收更加高效、减少了碎片化问题。</li>
<li><strong>避免内存碎片化</strong>：在长时间运行的系统中，内存碎片化会影响系统性能。Slab
分配器的设计通过确保内核对象内存块大小一致，有效避免了碎片问题。</li>
</ul>
<h3 id="与其他内存分配方式的对比">5.
<strong>与其他内存分配方式的对比</strong></h3>
<ul>
<li><strong>伙伴系统（Buddy
System）</strong>：伙伴系统适用于大块内存的分配和回收，而 Slab
分配器更适合内存需求较小、固定大小的内核对象。Slab
分配器在小对象的管理上更加高效。</li>
<li><strong>页分配器（Page
Allocator）</strong>：页分配器是为了管理大块内存而设计的，而 Slab
分配器针对小型对象的内存管理进行优化。Slab
分配器能大大减少内存碎片，提升内存分配的速度。</li>
</ul>
<h3 id="总结">总结</h3>
<p>Slab
分配器的设计目的在于优化内核对象的内存分配，解决频繁分配和回收内存时可能出现的碎片化问题。通过预分配内存、将对象大小固定化并分配为“Slab”内存块，Slab
分配器提供了高效的内存分配和回收机制，降低了内存碎片，提升了性能。因此，Linux
内核引入 Slab 分配器，使得内核的内存管理更加高效、稳定。</p></li>
</ul>
<h1 id="linux内核完全注释">Linux内核完全注释</h1>
<h2 id="微型计算机组成原理">微型计算机组成原理</h2>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224170104931.png"
alt="image-20241224170104931" />
<figcaption aria-hidden="true">image-20241224170104931</figcaption>
</figure>
<h3 id="io端口寻址">I/O端口寻址</h3>
<p>CPU
要访问IO接口需要得到它们的地址，成为端口地址。它有两种方式：统一编址和独立编址</p>
<ul>
<li>统一编址：和存储器公用</li>
<li>独立编址：有单独地址空间</li>
</ul>
<p>IBM PC 采用独立编址的方式</p>
<p><code>/proc/ioports</code> 文件可以查看地址的范围</p>
<figure>
<img
src="C:\Users\fyind\AppData\Roaming\Typora\typora-user-images\image-20241224170429711.png"
alt="image-20241224170429711" />
<figcaption aria-hidden="true">image-20241224170429711</figcaption>
</figure>
<h3 id="接口的访问控制">接口的访问控制</h3>
<p>PC机IO接口数据传输的方式</p>
<ul>
<li>程序循环查询：循环查询设备控制器的状态变量来判断是否数据交互</li>
<li>中断处理：IO设备通过中断向CPU提出处理请求</li>
<li>DMA: 用于批量数据传输</li>
</ul>
<h3 id="主存储器bios和cmos">主存储器，BIOS和CMOS</h3>
<h4 id="主存储器">主存储器</h4>
<p>就是RAM内存。计算机上电后，物理内存被设置成从0开始的连续区域。除了<code>0xA0000-0xFFFFF</code>
和 <code>0xFFFE000-0xFFFFFFF</code>
是用于IO和BIOS外，其他都可以用作系统内存</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224171237284.png"
alt="image-20241224171237284" />
<figcaption aria-hidden="true">image-20241224171237284</figcaption>
</figure>
<h4 id="bios">BIOS</h4>
<p>开机自检，建立各种配置表，中断向量表，硬盘参数表</p>
<p>上电时，CPU把代码段寄存器CS设置为 <code>0xF000</code> 基地址为
<code>0xFFFF0000</code> 段长度是64kb, IP 设置为 <code>0xFFF0</code>
所以第一行代码指向 <code>0xFFFFFFF0</code> 这里。这里是一个jmp.</p>
<p>BIOS大小通常1M-2M, 所以可以用Big Mode
把数据段寄存器设置为4G,来访问其他数据</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224171726175.png"
alt="image-20241224171726175" />
<figcaption aria-hidden="true">image-20241224171726175</figcaption>
</figure>
<h4 id="cmos">CMOS</h4>
<p>Complementary Metal Oxide Semiconductor
存储时钟信息，硬件配置信息</p>
<h3 id="控制器和控制卡">控制器和控制卡</h3>
<h4 id="中断控制器">中断控制器</h4>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224172720244.png"
alt="image-20241224172720244" />
<figcaption aria-hidden="true">image-20241224172720244</figcaption>
</figure>
<p>开机时候，这个请求号会被设置成中断向量号</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224172755988.png"
alt="image-20241224172755988" />
<figcaption aria-hidden="true">image-20241224172755988</figcaption>
</figure>
<h4 id="dma控制器">DMA控制器</h4>
<p>可以让外部设备直接和内存交互，不经过cpu.</p>
<h4 id="定时器计数器">定时器/计数器</h4>
<p>处理精确时间延迟</p>
<h4 id="键盘控制器">键盘控制器</h4>
<p>扫描键盘按下和松开的码</p>
<p>有三套扫描集</p>
<ol type="1">
<li>原始XT键盘扫描集</li>
<li>AT扫描集，现代键盘默认</li>
<li>PS/2扫描集</li>
</ol>
<p>键盘控制器会转换成XT扫描集</p>
<h4 id="串行控制卡">串行控制卡</h4>
<p>计算机直接的语言是通信协议.</p>
<p>串行通信是在线路上一个bit一个bit传输的通信方式, 分为同步和异步.</p>
<ul>
<li>异步：一个字符为一个单位</li>
<li>同步：多个字符或字节为一帧数据</li>
</ul>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224173750344.png"
alt="image-20241224173750344" />
<figcaption aria-hidden="true">image-20241224173750344</figcaption>
</figure>
<p>为了实现串行通信,使用异步发送/接受控制芯片 UART 组成的串行控制器</p>
<h4 id="显示控制">显示控制</h4>
<p>MDA 标准：仅支持黑白</p>
<p>CGA 标准: 有7种色彩和图形的显示方式</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20241224174303519.png"
alt="image-20241224174303519" />
<figcaption aria-hidden="true">image-20241224174303519</figcaption>
</figure>
<h4 id="软盘和硬盘控制器">软盘和硬盘控制器</h4>
<p>略</p>
<h2 id="内核编程语言和环境">内核编程语言和环境</h2>
<h3 id="as86汇编器">as86汇编器</h3>
<p>as86 可以产生16位代码, 连接器 <code>ld86</code>; 还有 GNU的汇编器
gas. 可以把低级汇编语言编译成机器码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as [option] -o objfile srcfile</span><br></pre></td></tr></table></figure>
<p>objfile 通常有3个段 <code>section, .text, .data, .bss</code></p>
<h4 id="as86汇编程序">as86汇编程序</h4>
<p>注释是 <code>!, ;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global begtext, begdata, begbss, endtext enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line">BOOTSEG = 0x07c0</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">	jmpi go, BOOTSEG</span><br><span class="line">go: mov ax, cs</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov [msg1+17], ah ! 鸣叫</span><br><span class="line">	mov cx, #20</span><br><span class="line">	mov dx, #0x1004</span><br><span class="line">	mov bx, #0x00c</span><br><span class="line">	mov bp, #msg1</span><br><span class="line">	mov ax, #0x1301</span><br><span class="line">	int 0x10 ! BIOS 中断调用 0x10 功能19，子功能1</span><br><span class="line">loop1: jmp loop1 ! 死循环</span><br><span class="line">msg1: .ascii &quot;Loading system ...&quot; </span><br><span class="line">	.byte 13, 10</span><br><span class="line">.org 510 ! 定义当前汇编位置</span><br><span class="line">	.word 0xAA55 ! 定义内存变量</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure>
<h4 id="段寄存器">段寄存器</h4>
<p>段寄存器（Segment Register）是 x86
架构中用来存储段地址的特殊寄存器。在早期的 x86 处理器中，内存地址是由
<strong>段地址</strong>（Segment Address）和
<strong>偏移量</strong>（Offset）两部分组成的，因此需要用段寄存器来指定段的基址。段寄存器和偏移量一起，确定了访问内存的具体位置。</p>
<p><code>物理地址 = (段寄存器的值 × 16) + 偏移量</code></p>
<p>x86 处理器有 6 个段寄存器，分别用于不同的目的：</p>
<ol type="1">
<li><strong>CS</strong>（Code
Segment）：代码段寄存器，指向当前执行代码的段。程序从这个段加载并执行指令。</li>
<li><strong>DS</strong>（Data
Segment）：数据段寄存器，通常用于访问程序中的全局数据、局部变量等。</li>
<li><strong>SS</strong>（Stack
Segment）：堆栈段寄存器，用于指向程序的栈（stack）。栈用于存储函数调用时的返回地址、局部变量等数据。</li>
<li><strong>ES</strong>（Extra
Segment）：额外段寄存器，通常用于某些特殊数据结构的存储，比如字符串操作、图像数据等。</li>
<li><strong>FS</strong>：通常用于操作系统的特定数据，像是线程信息、局部存储等。</li>
<li><strong>GS</strong>：与 <code>FS</code>
类似，也是用于操作系统的数据存储，通常用来访问线程局部存储（TLS）等。</li>
</ol>
<h4 id="编译链接">编译链接</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as86 -0 -a -o boot.o boot.s # -0 是生成8086的16位目标程序, -a 生成和gnu as和ld部分兼容代码</span><br><span class="line">ld86 -0 -s -o boot boot.o # -s 去符号链接</span><br><span class="line">dd bs=32 if=boot of=/dev/fd0 skip=1 # 写入</span><br></pre></td></tr></table></figure>
<h3 id="buchs">Buchs</h3>
<ul>
<li><p>nasm</p></li>
<li><p>dd for windows</p></li>
</ul>
<p>http://www.chrysocome.net/download</p>
<p>配置文件 <code>bochsrc-fda.bxrc</code> 路径需要更改,
<code>a.img</code> 是镜像文件，可以用 <code>bximage</code> 来生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">megs: 32</span><br><span class="line">romimage: file=&quot;C:\Program Files\Bochs-2.8\BIOS-bochs-latest&quot;</span><br><span class="line">vgaromimage: file=&quot;C:\Program Files\Bochs-2.8\VGABIOS-elpin-2.40&quot;</span><br><span class="line"></span><br><span class="line">floppya: 1_44=a.img, status=inserted</span><br><span class="line"></span><br><span class="line">boot: floppy</span><br><span class="line">log: bochsout.txt</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard: keymap=&quot;C:\Program Files\Bochs-2.8\keymaps\x11-pc-us.map&quot;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    mov ax, 0xb800</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">    mov byte [0x00],0x41</span><br><span class="line">    mov byte [0x01],0x0e</span><br><span class="line"></span><br><span class="line">    mov byte [0x02], &#x27;s&#x27;</span><br><span class="line">    mov byte [0x03], 0x0e</span><br><span class="line">again:</span><br><span class="line">    jmp again</span><br><span class="line">current:</span><br><span class="line">    times 510-(current-start) db 0</span><br><span class="line">    db 0x55, 0xaa</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm test.asm -o test.bin</span><br></pre></td></tr></table></figure>
<p>写入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test.bin of=a.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc-fda.bxrc</span><br></pre></td></tr></table></figure>
<p>快速运行脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm <span class="variable">$1</span>.asm -o <span class="variable">$1</span>.bin -l <span class="variable">$1</span>.lst</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=<span class="variable">$1</span>.bin of=asm.img bs=512 count=1 conv=notrunc</span><br><span class="line">bochs -q -f bochsrc-fda.bxrc -rc debug.cfg</span><br></pre></td></tr></table></figure>
<p><code>debug.cfg</code> windows 没有这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b 0x7c00</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h2 id="x86保护模式及其编程">80x86保护模式及其编程</h2>
<h4 id="标志寄存器eflags">标志寄存器EFLAGS</h4>
<figure>
<img src="https://fyindex.work/PicGo/image-20241231153055863.png"
alt="image-20241231153055863" />
<figcaption aria-hidden="true">image-20241231153055863</figcaption>
</figure>
<h2 id="linux内核体系结构">Linux内核体系结构</h2>
<p>操作系统由硬件，系统内核，操作系统服务，和用户应用组成</p>
<p>内核分为进程调度模块，内存管理模块，文件系统模块，进程间通信模块，网络接口模块</p>
<h3 id="物理内存">物理内存</h3>
<p>系统初始化时，分为几个区</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20241231153808220.png"
alt="image-20241231153808220" />
<figcaption aria-hidden="true">image-20241231153808220</figcaption>
</figure>
<h1 id="selinux-by-example">SELinux by example</h1>
<h2 id="背景">背景</h2>
<h3 id="操作系统中访问控制安全的演变">操作系统中访问控制安全的演变</h3>
<ul>
<li><p>Discretionary Access Control (DAC)
个别用户，通常是资源的“拥有者”，可以指定谁可以或不可以访问该资源</p></li>
<li><p>Mandatory Access Control (MAC) 为了避免DAC的短板</p></li>
</ul>
<p>SELinux 提供了一个灵活可配置的MAC机制</p>
<h4 id="reference-monitor-concept">Reference monitor concept</h4>
<p>在参考监视器中，操作系统将被动资源隔离成独立的对象，参考监视器机制（称为参考验证机制）随后通过应用一套访问控制规则所体现的安全策略来验证主体与对象之间的访问。</p>
<figure>
<img src="https://fyindex.work/PicGo/image-20241231202653033.png"
alt="image-20241231202653033" />
<figcaption aria-hidden="true">image-20241231202653033</figcaption>
</figure>
<p>设计目标：</p>
<ul>
<li>Tamper-proof 不能被恶意更改</li>
<li>Nonbypassable 不能逃离访问控制决策</li>
<li>Verifiable 正确的并且实现可以被演示</li>
</ul>
<h4 id="dac的问题">DAC的问题</h4>
<p>大多数DAC是基于用户身份。Linux里面有 owner-group-world permission
mode</p>
<p>DAC 的弱点是不能识别人类和计算机程序。</p>
<h4 id="mac的起源">MAC的起源</h4>
<p>我们想要实现一种组织的安全策略，不受程序行为的影响。</p>
<p>Multilevel security (MLS) 每个主体和个体都有一个安全等级。</p>
<p>弱点是它非常严格，不灵活。</p>
<h3 id="type-enforcement">Type Enforcement</h3>
<h3 id="os-security">OS Security</h3>
<ol type="1">
<li><strong>身份认证与访问控制（Authentication and Access
Control）</strong></li>
</ol>
<ul>
<li><p><strong>身份认证</strong>：确保系统只允许合法用户访问，防止未经授权的用户进入系统。常见的身份认证方法包括用户名/密码、双因素认证（2FA）、生物识别等。</p></li>
<li><p>访问控制</p>
<p>：通过访问控制策略限制用户和程序对系统资源（如文件、设备、进程等）的访问。访问控制模型包括：</p>
<ul>
<li><strong>自主访问控制（DAC）</strong>：由资源的所有者控制访问权限。</li>
<li><strong>强制访问控制（MAC）</strong>：由系统根据策略强制限制访问权限。</li>
<li><strong>基于角色的访问控制（RBAC）</strong>：基于用户角色定义访问权限。</li>
<li><strong>基于属性的访问控制（ABAC）</strong>：基于属性（如用户、资源、环境等）来动态管理访问权限。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>内核安全（Kernel Security）</strong></li>
</ol>
<ul>
<li><p>内核防护</p>
<p>：内核是操作系统的核心，负责管理硬件资源和系统功能，因此它需要额外的保护措施。内核漏洞可能被恶意攻击者利用来提升权限或执行恶意操作。常见的防护措施包括：</p>
<ul>
<li><strong>内核空间和用户空间隔离</strong>：确保应用程序与内核代码分离，避免用户程序破坏系统核心功能。</li>
<li><strong>内核完整性检查</strong>：使用技术（如数字签名、哈希校验）确保内核文件未被篡改。</li>
<li><strong>内核漏洞修补</strong>：及时修复内核中的安全漏洞，以防被攻击者利用。</li>
</ul></li>
<li><p><strong>系统调用过滤</strong>：通过限制系统调用的使用，避免恶意程序通过系统调用执行危险操作。</p></li>
</ul>
<ol start="3" type="1">
<li><strong>进程和线程安全（Process and Thread Security）</strong></li>
</ol>
<ul>
<li><strong>进程隔离</strong>：每个进程应当被隔离，防止恶意进程通过共享内存或通信方式访问其他进程的敏感信息或控制其他进程。操作系统通过进程隔离确保进程间互不干扰，提供安全的执行环境。</li>
<li><strong>沙盒（Sandboxing）</strong>：在一个受限的环境中运行应用程序，使其无法对主系统造成威胁或进行不安全的操作。沙盒技术通常用于浏览器、虚拟机等场景。</li>
<li><strong>内存保护</strong>：防止进程越权访问内存区域（例如通过堆溢出或栈溢出等漏洞攻击）。</li>
</ul>
<ol start="4" type="1">
<li><strong>文件系统安全（File System Security）</strong></li>
</ol>
<ul>
<li><strong>加密文件系统</strong>：通过加密技术保护存储在磁盘上的敏感数据。即使磁盘被盗，数据也无法被读取。</li>
<li><strong>文件访问控制</strong>：通过访问控制列表（ACLs）或权限设置，限制谁可以访问、修改或删除文件。</li>
<li><strong>审计和日志记录</strong>：记录所有对文件系统的访问，以便后期分析和审计，检测异常操作。</li>
</ul>
<ol start="5" type="1">
<li><strong>系统日志与审计（System Logging and Auditing）</strong></li>
</ol>
<ul>
<li><strong>日志记录</strong>：操作系统通常记录安全事件和用户行为。通过日志文件，管理员可以检测到潜在的安全威胁（如未经授权的访问尝试、文件篡改等）。</li>
<li><strong>审计</strong>：审计涉及对系统活动的监控和记录，确保合规性并帮助追踪安全事件的根源。安全审计可以帮助管理员识别可疑活动，及时响应攻击。</li>
</ul>
<ol start="6" type="1">
<li><strong>恶意软件防护（Malware Protection）</strong></li>
</ol>
<ul>
<li><strong>病毒、蠕虫、木马防护</strong>：操作系统需要防止恶意软件的感染和传播。操作系统通过防病毒工具、反恶意软件程序、沙盒技术等防护措施，阻止恶意程序的执行。</li>
<li><strong>恶意代码检测与清除</strong>：通过监控系统中的进程、文件和网络流量，检测潜在的恶意活动并清除病毒、木马等恶意软件。</li>
<li><strong>执行控制</strong>：防止不受信任的程序或恶意代码执行，例如通过限制可执行文件的来源或数字签名验证。</li>
</ul>
<ol start="7" type="1">
<li><strong>网络安全（Network Security）</strong></li>
</ol>
<ul>
<li><strong>防火墙（Firewall）</strong>：操作系统通常包含防火墙功能，用于过滤进入或离开网络的数据包，控制不同网络之间的通信。</li>
<li><strong>入侵检测与防御系统（IDS/IPS）</strong>：通过监控网络流量，检测并防止潜在的攻击行为（如网络扫描、拒绝服务攻击等）。</li>
<li><strong>加密与安全通信</strong>：操作系统可以使用加密技术（如SSL/TLS）来确保数据传输的安全性，防止数据被中途篡改或窃取。</li>
</ul>
<ol start="8" type="1">
<li><strong>安全更新与补丁管理（Patch Management）</strong></li>
</ol>
<ul>
<li><strong>补丁管理</strong>：操作系统必须能够及时发布安全补丁，以修复已知的安全漏洞。通过自动更新系统，确保操作系统不受已知漏洞的攻击。</li>
<li><strong>零日漏洞防护</strong>：对于尚未公开或尚未修补的漏洞，操作系统需要通过加强防护措施（如使用应用程序沙盒、防止特定攻击方式）来减少其被利用的风险。</li>
</ul>
<ol start="9" type="1">
<li><strong>虚拟化安全（Virtualization Security）</strong></li>
</ol>
<ul>
<li><strong>虚拟机安全</strong>：在虚拟化环境中，操作系统需要确保不同虚拟机之间的隔离，防止攻击者通过一个虚拟机攻击其他虚拟机或宿主机。</li>
<li><strong>虚拟化监控</strong>：虚拟化平台（如Hypervisor）需要能够有效监控虚拟机的行为，并限制不安全的操作。</li>
</ul>
<ol start="10" type="1">
<li><strong>防止拒绝服务攻击（DoS/DDoS Prevention）</strong></li>
</ol>
<ul>
<li><strong>拒绝服务攻击（DoS）和分布式拒绝服务攻击（DDoS）</strong>：操作系统需要能够识别并阻止大规模的流量攻击，防止系统资源被恶意消耗或瘫痪。</li>
<li><strong>负载均衡和流量过滤</strong>：通过负载均衡、流量限制、速率控制等措施，防止过多请求消耗系统资源。</li>
</ul>
<ol start="11" type="1">
<li><strong>系统配置与硬化（System Hardening）</strong></li>
</ol>
<ul>
<li><strong>操作系统硬化</strong>：硬化是指通过禁用不必要的服务、关闭不必要的端口、删除不需要的账户、应用最小权限原则等措施，降低系统受攻击的面。</li>
<li><strong>最小化攻击面</strong>：仅启用必需的功能和服务，减少操作系统暴露给攻击者的潜在入口。</li>
</ul>
<h1 id="phd">PhD</h1>
<p>工业博士：</p>
<p>题目是工业感兴趣的，sponsered by industrie</p>
<p>based in a company, full time</p>
<p>题目是应用向的，在university注册，有一个导师</p>
<p>教授和公司没有关系</p>
<p>可以自己找，也可以帮忙找</p>
<p>academic phd</p>
<p>公司会拥有你的成果</p>
<p>要联系公司是否可以作为博士论文</p>
<p>在早期就要确认是否可以发表</p>
<p>和工业专家联系多，市场倾向，成果对工业界很感兴趣，对就业有帮助。博士也作为工作经验.</p>
<p>如果博士毕业后想去公司，那么工业博士是好的</p>
<p>从经济层面差别很小</p>
<p>如果没有读出来，很容易在公司找工作。</p>
<p>和大学，教授的联系很少， 但和公司同事联系多。</p>
<p>非常可能在同一个公司得到工作</p>
<p>也可以去其他做相同事情的公司，</p>
<p>也可以去学术，但大部分去公司</p>
<p>based in university, funded from university or scholarship</p>
<p>题目是scientific的， 题目的选择比较多</p>
<p>更加理论的。对Post doc比较好</p>
<h3 id="刚开始的">刚开始的</h3>
<p>regular meeting with supervisor</p>
<p>build relationship</p>
<p>认识其他人在干什么</p>
<h4 id="skill-building">skill building</h4>
<p>学习基本技能</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://fyind.de">Fyind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://fyind.de/2025/04/22/Linux%E5%86%85%E6%A0%B8/">http://fyind.de/2025/04/22/Linux%E5%86%85%E6%A0%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/pic1.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" title="嵌入式开发"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">嵌入式开发</div></div><div class="info-2"><div class="info-item-1">野火STM32F407 配置 下载 arm 编译器： https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads 在这里拉下去下载 设置里面如果缺少的话，用target 里面 compiler version 6 </div></div></div></a><a class="pagination-related" href="/2025/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">计算机组成原理</div></div><div class="info-2"><div class="info-item-1">计算机组成原理 计算机基本组成 现代计算机硬件   image-20250330110412805  存储器基本组成   image-20250330110557695  控制器基本组成   image-20250330110701305  完成一条指令的过程   image-20250330110807132  计算机硬件的主要技术指标 机器字长 CPU 一次能处理数据的位数 ， 与 CPU 中的 寄存器位数 有关 运算速度  主频 核数，每个核支持的线程数 吉普森法  CPI 执行一条指令所需时钟周期数  MIPS 每秒执行百万条指令 FLOPS 每秒浮点运算次数  存储容量 总线 总线是连接各个部件的信息传输线， 是 各个部件共享的传输介质 并行和串行   image-20250330111037133  总线的性能指标  总线宽度 ：数据线 的根数 标准传输率，每秒传输的最大字节数（MBps） 时钟同步/异步 总线复用：地址线 与 数据线 复用 信号线数 总线控制方式 其他指标  总线标准   image-20250330111218648  总线结构 单总线结构   i...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/pic1.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fyind</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fyind"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Fyind" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:tarjan0025@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=d0kMY0nN" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来逛逛我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">中断的工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jiffies"><span class="toc-number">2.1.</span> <span class="toc-text">jiffies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dotimer"><span class="toc-number">2.1.1.</span> <span class="toc-text">dotimer</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">Linux内核设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-1"><span class="toc-number">1.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">进程描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%AD%98%E6%94%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程描述符的存放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">设置当前进程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%B6%E6%97%8F%E6%A0%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">进程的家族树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.1.</span> <span class="toc-text">写时拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork"><span class="toc-number">1.2.2.</span> <span class="toc-text">fork()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">内核线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">进程终结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.1.</span> <span class="toc-text">多任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.</span> <span class="toc-text">策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E6%B6%88%E8%80%97%E5%9E%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E6%B6%88%E8%80%97%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">I&#x2F;O消耗型进程和处理器消耗型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">Linux调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B1%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">调度器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.2.</span> <span class="toc-text">公平调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E7%9A%84%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">Linux的调度实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%AE%B0%E8%B4%A6"><span class="toc-number">2.4.1.</span> <span class="toc-text">时间记账</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.2.</span> <span class="toc-text">进程选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%85%A5%E5%8F%A3"><span class="toc-number">2.4.3.</span> <span class="toc-text">调度器入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-number">2.4.4.</span> <span class="toc-text">睡眠和唤醒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">抢占和上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">2.6.</span> <span class="toc-text">实时调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">与调度相关的系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#posix"><span class="toc-number">3.0.1.</span> <span class="toc-text">POSIX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"><span class="toc-number">3.0.2.</span> <span class="toc-text">系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5"><span class="toc-number">4.1.</span> <span class="toc-text">页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">4.2.</span> <span class="toc-text">3. 内存区域的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">内存分配机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">1.
内核对象的内存分配特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">2. Slab
分配器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.6.</span> <span class="toc-text">3. Slab 分配器的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-linux-%E9%9C%80%E8%A6%81-slab-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text">4. 为什么 Linux 需要 Slab
分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.8.</span> <span class="toc-text">5.
与其他内存分配方式的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A"><span class="toc-number"></span> <span class="toc-text">Linux内核完全注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">微型计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E7%AB%AF%E5%8F%A3%E5%AF%BB%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text">I&#x2F;O端口寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">接口的访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8bios%E5%92%8Ccmos"><span class="toc-number">1.3.</span> <span class="toc-text">主存储器，BIOS和CMOS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">主存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bios"><span class="toc-number">1.3.2.</span> <span class="toc-text">BIOS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmos"><span class="toc-number">1.3.3.</span> <span class="toc-text">CMOS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8D%A1"><span class="toc-number">1.4.</span> <span class="toc-text">控制器和控制卡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">中断控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dma%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">DMA控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">定时器&#x2F;计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">键盘控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%8D%A1"><span class="toc-number">1.4.5.</span> <span class="toc-text">串行控制卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">显示控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E7%9B%98%E5%92%8C%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">软盘和硬盘控制器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">内核编程语言和环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#as86%E6%B1%87%E7%BC%96%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">as86汇编器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#as86%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">as86汇编程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.3.</span> <span class="toc-text">编译链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buchs"><span class="toc-number">2.2.</span> <span class="toc-text">Buchs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">80x86保护模式及其编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8eflags"><span class="toc-number">3.0.1.</span> <span class="toc-text">标志寄存器EFLAGS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Linux内核体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">物理内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#selinux-by-example"><span class="toc-number"></span> <span class="toc-text">SELinux by example</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AE%89%E5%85%A8%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统中访问控制安全的演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reference-monitor-concept"><span class="toc-number">1.1.1.</span> <span class="toc-text">Reference monitor concept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dac%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">DAC的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mac%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">MAC的起源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-enforcement"><span class="toc-number">1.2.</span> <span class="toc-text">Type Enforcement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-security"><span class="toc-number">1.3.</span> <span class="toc-text">OS Security</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#phd"><span class="toc-number"></span> <span class="toc-text">PhD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9A%E5%BC%80%E5%A7%8B%E7%9A%84"><span class="toc-number">0.1.</span> <span class="toc-text">刚开始的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#skill-building"><span class="toc-number">0.1.1.</span> <span class="toc-text">skill building</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/17/C-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" title="C++高性能编程">C++高性能编程</a><time datetime="2025-07-17T19:47:19.000Z" title="Created 2025-07-17 19:47:19">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="操作系统概念">操作系统概念</a><time datetime="2025-07-16T20:55:14.000Z" title="Created 2025-07-16 20:55:14">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/Kubuntu%E9%85%8D%E7%BD%AE/" title="Kubuntu配置">Kubuntu配置</a><time datetime="2025-07-15T05:25:37.000Z" title="Created 2025-07-15 05:25:37">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E6%88%91%E4%BB%AC%E5%9C%A8AI%E6%97%B6%E4%BB%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/" title="我们在AI时代该如何学习">我们在AI时代该如何学习</a><time datetime="2025-07-12T23:12:19.000Z" title="Created 2025-07-12 23:12:19">2025-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CA-Top-Down-Approach/" title="计算机网络A Top Down Approach">计算机网络A Top Down Approach</a><time datetime="2025-07-12T22:02:58.000Z" title="Created 2025-07-12 22:02:58">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fyind</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>